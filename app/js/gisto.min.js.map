{
  "version": 3,
  "file": "gisto.min.js",
  "sources": [
    "app/lib/jquery/jquery-2.0.0.js",
    "app/lib/angular/angular.js",
    "app/lib/socket-io/socket.io.min.js",
    "app/lib/socket-io/socket.js",
    "app/lib/angular-ui/ui-utils.min.js",
    "app/js/controllers/commentsController.js",
    "app/js/controllers/createController.js",
    "app/js/controllers/headerController.js",
    "app/js/controllers/listController.js",
    "app/js/controllers/loginController.js",
    "app/js/controllers/mainController.js",
    "app/js/controllers/settingsController.js",
    "app/js/controllers/sharedController.js",
    "app/js/controllers/singleController.js",
    "app/js/directives/editorDirective.js",
    "app/js/directives/scrollDirective.js",
    "app/js/filters/markdownFilter.js",
    "app/js/filters/publicOrPrivateFilter.js",
    "app/js/filters/removeTagSymbolFilter.js",
    "app/js/filters/removeTagsFilter.js",
    "app/js/filters/syntaxFilter.js",
    "app/js/filters/truncateFilter.js",
    "app/js/services/gistDataService.js",
    "app/js/services/githubApiService.js",
    "app/js/services/notificationService.js",
    "app/js/services/onlineStatusService.js",
    "app/js/services/requestHandlerService.js",
    "app/js/services/settingsService.js",
    "app/js/app.js",
    "app/lib/showdown.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACljRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oN;AC3+gBA;AACA,6p3C;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;AClFA;AACA;AACA;AACA;AACA;AACA;AACA,o9X;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;AC7TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,M;ACRA;AACA;AACA;AACA;AACA;AACA;AACA,O;ACNA;AACA;AACA;AACA;AACA;AACA;AACA,O;ACNA;AACA;AACA;AACA;AACA;AACA;AACA,O;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G",
  "sourcesContent": [
    "/*!\r\n * jQuery JavaScript Library v2.0.0\r\n * http://jquery.com/\r\n *\r\n * Includes Sizzle.js\r\n * http://sizzlejs.com/\r\n *\r\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\r\n * Released under the MIT license\r\n * http://jquery.org/license\r\n *\r\n * Date: 2013-04-18\r\n */\r\n(function( window, undefined ) {\r\n\r\n// Can't do this because several apps including ASP.NET trace\r\n// the stack via arguments.caller.callee and Firefox dies if\r\n// you try to trace through \"use strict\" call chains. (#13335)\r\n// Support: Firefox 18+\r\n//\"use strict\";\r\nvar\r\n\t// A central reference to the root jQuery(document)\r\n\trootjQuery,\r\n\r\n\t// The deferred used on DOM ready\r\n\treadyList,\r\n\r\n\t// Support: IE9\r\n\t// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\r\n\tcore_strundefined = typeof undefined,\r\n\r\n\t// Use the correct document accordingly with window argument (sandbox)\r\n\tlocation = window.location,\r\n\tdocument = window.document,\r\n\tdocElem = document.documentElement,\r\n\r\n\t// Map over jQuery in case of overwrite\r\n\t_jQuery = window.jQuery,\r\n\r\n\t// Map over the $ in case of overwrite\r\n\t_$ = window.$,\r\n\r\n\t// [[Class]] -> type pairs\r\n\tclass2type = {},\r\n\r\n\t// List of deleted data cache ids, so we can reuse them\r\n\tcore_deletedIds = [],\r\n\r\n\tcore_version = \"2.0.0\",\r\n\r\n\t// Save a reference to some core methods\r\n\tcore_concat = core_deletedIds.concat,\r\n\tcore_push = core_deletedIds.push,\r\n\tcore_slice = core_deletedIds.slice,\r\n\tcore_indexOf = core_deletedIds.indexOf,\r\n\tcore_toString = class2type.toString,\r\n\tcore_hasOwn = class2type.hasOwnProperty,\r\n\tcore_trim = core_version.trim,\r\n\r\n\t// Define a local copy of jQuery\r\n\tjQuery = function( selector, context ) {\r\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\r\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\r\n\t},\r\n\r\n\t// Used for matching numbers\r\n\tcore_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\r\n\r\n\t// Used for splitting on whitespace\r\n\tcore_rnotwhite = /\\S+/g,\r\n\r\n\t// A simple way to check for HTML strings\r\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\r\n\t// Strict HTML recognition (#11290: must start with <)\r\n\trquickExpr = /^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\r\n\r\n\t// Match a standalone tag\r\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\r\n\r\n\t// Matches dashed string for camelizing\r\n\trmsPrefix = /^-ms-/,\r\n\trdashAlpha = /-([\\da-z])/gi,\r\n\r\n\t// Used by jQuery.camelCase as callback to replace()\r\n\tfcamelCase = function( all, letter ) {\r\n\t\treturn letter.toUpperCase();\r\n\t},\r\n\r\n\t// The ready event handler and self cleanup method\r\n\tcompleted = function() {\r\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\r\n\t\twindow.removeEventListener( \"load\", completed, false );\r\n\t\tjQuery.ready();\r\n\t};\r\n\r\njQuery.fn = jQuery.prototype = {\r\n\t// The current version of jQuery being used\r\n\tjquery: core_version,\r\n\r\n\tconstructor: jQuery,\r\n\tinit: function( selector, context, rootjQuery ) {\r\n\t\tvar match, elem;\r\n\r\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\r\n\t\tif ( !selector ) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\t// Handle HTML strings\r\n\t\tif ( typeof selector === \"string\" ) {\r\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\r\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\r\n\t\t\t\tmatch = [ null, selector, null ];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tmatch = rquickExpr.exec( selector );\r\n\t\t\t}\r\n\r\n\t\t\t// Match html or make sure no context is specified for #id\r\n\t\t\tif ( match && (match[1] || !context) ) {\r\n\r\n\t\t\t\t// HANDLE: $(html) -> $(array)\r\n\t\t\t\tif ( match[1] ) {\r\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\r\n\r\n\t\t\t\t\t// scripts is true for back-compat\r\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\r\n\t\t\t\t\t\tmatch[1],\r\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\r\n\t\t\t\t\t\ttrue\r\n\t\t\t\t\t) );\r\n\r\n\t\t\t\t\t// HANDLE: $(html, props)\r\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\r\n\t\t\t\t\t\tfor ( match in context ) {\r\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\r\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\r\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\r\n\r\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t// HANDLE: $(#id)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telem = document.getElementById( match[2] );\r\n\r\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\r\n\t\t\t\t\t// nodes that are no longer in the document #6963\r\n\t\t\t\t\tif ( elem && elem.parentNode ) {\r\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\r\n\t\t\t\t\t\tthis.length = 1;\r\n\t\t\t\t\t\tthis[0] = elem;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.context = document;\r\n\t\t\t\t\tthis.selector = selector;\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\r\n\t\t\t// HANDLE: $(expr, $(...))\r\n\t\t\t} else if ( !context || context.jquery ) {\r\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\r\n\r\n\t\t\t// HANDLE: $(expr, context)\r\n\t\t\t// (which is just equivalent to: $(context).find(expr)\r\n\t\t\t} else {\r\n\t\t\t\treturn this.constructor( context ).find( selector );\r\n\t\t\t}\r\n\r\n\t\t// HANDLE: $(DOMElement)\r\n\t\t} else if ( selector.nodeType ) {\r\n\t\t\tthis.context = this[0] = selector;\r\n\t\t\tthis.length = 1;\r\n\t\t\treturn this;\r\n\r\n\t\t// HANDLE: $(function)\r\n\t\t// Shortcut for document ready\r\n\t\t} else if ( jQuery.isFunction( selector ) ) {\r\n\t\t\treturn rootjQuery.ready( selector );\r\n\t\t}\r\n\r\n\t\tif ( selector.selector !== undefined ) {\r\n\t\t\tthis.selector = selector.selector;\r\n\t\t\tthis.context = selector.context;\r\n\t\t}\r\n\r\n\t\treturn jQuery.makeArray( selector, this );\r\n\t},\r\n\r\n\t// Start with an empty selector\r\n\tselector: \"\",\r\n\r\n\t// The default length of a jQuery object is 0\r\n\tlength: 0,\r\n\r\n\ttoArray: function() {\r\n\t\treturn core_slice.call( this );\r\n\t},\r\n\r\n\t// Get the Nth element in the matched element set OR\r\n\t// Get the whole matched element set as a clean array\r\n\tget: function( num ) {\r\n\t\treturn num == null ?\r\n\r\n\t\t\t// Return a 'clean' array\r\n\t\t\tthis.toArray() :\r\n\r\n\t\t\t// Return just the object\r\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\r\n\t},\r\n\r\n\t// Take an array of elements and push it onto the stack\r\n\t// (returning the new matched element set)\r\n\tpushStack: function( elems ) {\r\n\r\n\t\t// Build a new jQuery matched element set\r\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\r\n\r\n\t\t// Add the old object onto the stack (as a reference)\r\n\t\tret.prevObject = this;\r\n\t\tret.context = this.context;\r\n\r\n\t\t// Return the newly-formed element set\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// Execute a callback for every element in the matched set.\r\n\t// (You can seed the arguments with an array of args, but this is\r\n\t// only used internally.)\r\n\teach: function( callback, args ) {\r\n\t\treturn jQuery.each( this, callback, args );\r\n\t},\r\n\r\n\tready: function( fn ) {\r\n\t\t// Add the callback\r\n\t\tjQuery.ready.promise().done( fn );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tslice: function() {\r\n\t\treturn this.pushStack( core_slice.apply( this, arguments ) );\r\n\t},\r\n\r\n\tfirst: function() {\r\n\t\treturn this.eq( 0 );\r\n\t},\r\n\r\n\tlast: function() {\r\n\t\treturn this.eq( -1 );\r\n\t},\r\n\r\n\teq: function( i ) {\r\n\t\tvar len = this.length,\r\n\t\t\tj = +i + ( i < 0 ? len : 0 );\r\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\r\n\t},\r\n\r\n\tmap: function( callback ) {\r\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\r\n\t\t\treturn callback.call( elem, i, elem );\r\n\t\t}));\r\n\t},\r\n\r\n\tend: function() {\r\n\t\treturn this.prevObject || this.constructor(null);\r\n\t},\r\n\r\n\t// For internal use only.\r\n\t// Behaves like an Array's method, not like a jQuery method.\r\n\tpush: core_push,\r\n\tsort: [].sort,\r\n\tsplice: [].splice\r\n};\r\n\r\n// Give the init function the jQuery prototype for later instantiation\r\njQuery.fn.init.prototype = jQuery.fn;\r\n\r\njQuery.extend = jQuery.fn.extend = function() {\r\n\tvar options, name, src, copy, copyIsArray, clone,\r\n\t\ttarget = arguments[0] || {},\r\n\t\ti = 1,\r\n\t\tlength = arguments.length,\r\n\t\tdeep = false;\r\n\r\n\t// Handle a deep copy situation\r\n\tif ( typeof target === \"boolean\" ) {\r\n\t\tdeep = target;\r\n\t\ttarget = arguments[1] || {};\r\n\t\t// skip the boolean and the target\r\n\t\ti = 2;\r\n\t}\r\n\r\n\t// Handle case when target is a string or something (possible in deep copy)\r\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\r\n\t\ttarget = {};\r\n\t}\r\n\r\n\t// extend jQuery itself if only one argument is passed\r\n\tif ( length === i ) {\r\n\t\ttarget = this;\r\n\t\t--i;\r\n\t}\r\n\r\n\tfor ( ; i < length; i++ ) {\r\n\t\t// Only deal with non-null/undefined values\r\n\t\tif ( (options = arguments[ i ]) != null ) {\r\n\t\t\t// Extend the base object\r\n\t\t\tfor ( name in options ) {\r\n\t\t\t\tsrc = target[ name ];\r\n\t\t\t\tcopy = options[ name ];\r\n\r\n\t\t\t\t// Prevent never-ending loop\r\n\t\t\t\tif ( target === copy ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Recurse if we're merging plain objects or arrays\r\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\r\n\t\t\t\t\tif ( copyIsArray ) {\r\n\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Never move original objects, clone them\r\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\r\n\r\n\t\t\t\t// Don't bring in undefined values\r\n\t\t\t\t} else if ( copy !== undefined ) {\r\n\t\t\t\t\ttarget[ name ] = copy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the modified object\r\n\treturn target;\r\n};\r\n\r\njQuery.extend({\r\n\t// Unique for each copy of jQuery on the page\r\n\texpando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\r\n\r\n\tnoConflict: function( deep ) {\r\n\t\tif ( window.$ === jQuery ) {\r\n\t\t\twindow.$ = _$;\r\n\t\t}\r\n\r\n\t\tif ( deep && window.jQuery === jQuery ) {\r\n\t\t\twindow.jQuery = _jQuery;\r\n\t\t}\r\n\r\n\t\treturn jQuery;\r\n\t},\r\n\r\n\t// Is the DOM ready to be used? Set to true once it occurs.\r\n\tisReady: false,\r\n\r\n\t// A counter to track how many items to wait for before\r\n\t// the ready event fires. See #6781\r\n\treadyWait: 1,\r\n\r\n\t// Hold (or release) the ready event\r\n\tholdReady: function( hold ) {\r\n\t\tif ( hold ) {\r\n\t\t\tjQuery.readyWait++;\r\n\t\t} else {\r\n\t\t\tjQuery.ready( true );\r\n\t\t}\r\n\t},\r\n\r\n\t// Handle when the DOM is ready\r\n\tready: function( wait ) {\r\n\r\n\t\t// Abort if there are pending holds or we're already ready\r\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Remember that the DOM is ready\r\n\t\tjQuery.isReady = true;\r\n\r\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\r\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// If there are functions bound, to execute\r\n\t\treadyList.resolveWith( document, [ jQuery ] );\r\n\r\n\t\t// Trigger any bound ready events\r\n\t\tif ( jQuery.fn.trigger ) {\r\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\r\n\t\t}\r\n\t},\r\n\r\n\t// See test/unit/core.js for details concerning isFunction.\r\n\t// Since version 1.3, DOM methods and functions like alert\r\n\t// aren't supported. They return false on IE (#2968).\r\n\tisFunction: function( obj ) {\r\n\t\treturn jQuery.type(obj) === \"function\";\r\n\t},\r\n\r\n\tisArray: Array.isArray,\r\n\r\n\tisWindow: function( obj ) {\r\n\t\treturn obj != null && obj === obj.window;\r\n\t},\r\n\r\n\tisNumeric: function( obj ) {\r\n\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\r\n\t},\r\n\r\n\ttype: function( obj ) {\r\n\t\tif ( obj == null ) {\r\n\t\t\treturn String( obj );\r\n\t\t}\r\n\t\t// Support: Safari <= 5.1 (functionish RegExp)\r\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\r\n\t\t\tclass2type[ core_toString.call(obj) ] || \"object\" :\r\n\t\t\ttypeof obj;\r\n\t},\r\n\r\n\tisPlainObject: function( obj ) {\r\n\t\t// Not plain objects:\r\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n\t\t// - DOM nodes\r\n\t\t// - window\r\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Support: Firefox <20\r\n\t\t// The try/catch suppresses exceptions thrown when attempting to access\r\n\t\t// the \"constructor\" property of certain host objects, ie. |window.location|\r\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=814622\r\n\t\ttry {\r\n\t\t\tif ( obj.constructor &&\r\n\t\t\t\t\t!core_hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} catch ( e ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// If the function hasn't returned already, we're confident that\r\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\r\n\t\treturn true;\r\n\t},\r\n\r\n\tisEmptyObject: function( obj ) {\r\n\t\tvar name;\r\n\t\tfor ( name in obj ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\terror: function( msg ) {\r\n\t\tthrow new Error( msg );\r\n\t},\r\n\r\n\t// data: string of html\r\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\r\n\t// keepScripts (optional): If true, will include scripts passed in the html string\r\n\tparseHTML: function( data, context, keepScripts ) {\r\n\t\tif ( !data || typeof data !== \"string\" ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif ( typeof context === \"boolean\" ) {\r\n\t\t\tkeepScripts = context;\r\n\t\t\tcontext = false;\r\n\t\t}\r\n\t\tcontext = context || document;\r\n\r\n\t\tvar parsed = rsingleTag.exec( data ),\r\n\t\t\tscripts = !keepScripts && [];\r\n\r\n\t\t// Single tag\r\n\t\tif ( parsed ) {\r\n\t\t\treturn [ context.createElement( parsed[1] ) ];\r\n\t\t}\r\n\r\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\r\n\r\n\t\tif ( scripts ) {\r\n\t\t\tjQuery( scripts ).remove();\r\n\t\t}\r\n\r\n\t\treturn jQuery.merge( [], parsed.childNodes );\r\n\t},\r\n\r\n\tparseJSON: JSON.parse,\r\n\r\n\t// Cross-browser xml parsing\r\n\tparseXML: function( data ) {\r\n\t\tvar xml, tmp;\r\n\t\tif ( !data || typeof data !== \"string\" ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Support: IE9\r\n\t\ttry {\r\n\t\t\ttmp = new DOMParser();\r\n\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\r\n\t\t} catch ( e ) {\r\n\t\t\txml = undefined;\r\n\t\t}\r\n\r\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\r\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\r\n\t\t}\r\n\t\treturn xml;\r\n\t},\r\n\r\n\tnoop: function() {},\r\n\r\n\t// Evaluates a script in a global context\r\n\tglobalEval: function( code ) {\r\n\t\tvar script,\r\n\t\t\t\tindirect = eval;\r\n\r\n\t\tcode = jQuery.trim( code );\r\n\r\n\t\tif ( code ) {\r\n\t\t\t// If the code includes a valid, prologue position\r\n\t\t\t// strict mode pragma, execute code by injecting a\r\n\t\t\t// script tag into the document.\r\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\r\n\t\t\t\tscript = document.createElement(\"script\");\r\n\t\t\t\tscript.text = code;\r\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\r\n\t\t\t} else {\r\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\r\n\t\t\t// and removal by using an indirect global eval\r\n\t\t\t\tindirect( code );\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// Convert dashed to camelCase; used by the css and data modules\r\n\t// Microsoft forgot to hump their vendor prefix (#9572)\r\n\tcamelCase: function( string ) {\r\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\r\n\t},\r\n\r\n\tnodeName: function( elem, name ) {\r\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\r\n\t},\r\n\r\n\t// args is for internal usage only\r\n\teach: function( obj, callback, args ) {\r\n\t\tvar value,\r\n\t\t\ti = 0,\r\n\t\t\tlength = obj.length,\r\n\t\t\tisArray = isArraylike( obj );\r\n\r\n\t\tif ( args ) {\r\n\t\t\tif ( isArray ) {\r\n\t\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\r\n\r\n\t\t\t\t\tif ( value === false ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( i in obj ) {\r\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\r\n\r\n\t\t\t\t\tif ( value === false ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// A special, fast, case for the most common use of each\r\n\t\t} else {\r\n\t\t\tif ( isArray ) {\r\n\t\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\r\n\r\n\t\t\t\t\tif ( value === false ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( i in obj ) {\r\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\r\n\r\n\t\t\t\t\tif ( value === false ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn obj;\r\n\t},\r\n\r\n\ttrim: function( text ) {\r\n\t\treturn text == null ? \"\" : core_trim.call( text );\r\n\t},\r\n\r\n\t// results is for internal usage only\r\n\tmakeArray: function( arr, results ) {\r\n\t\tvar ret = results || [];\r\n\r\n\t\tif ( arr != null ) {\r\n\t\t\tif ( isArraylike( Object(arr) ) ) {\r\n\t\t\t\tjQuery.merge( ret,\r\n\t\t\t\t\ttypeof arr === \"string\" ?\r\n\t\t\t\t\t[ arr ] : arr\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\tcore_push.call( ret, arr );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t},\r\n\r\n\tinArray: function( elem, arr, i ) {\r\n\t\treturn arr == null ? -1 : core_indexOf.call( arr, elem, i );\r\n\t},\r\n\r\n\tmerge: function( first, second ) {\r\n\t\tvar l = second.length,\r\n\t\t\ti = first.length,\r\n\t\t\tj = 0;\r\n\r\n\t\tif ( typeof l === \"number\" ) {\r\n\t\t\tfor ( ; j < l; j++ ) {\r\n\t\t\t\tfirst[ i++ ] = second[ j ];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\twhile ( second[j] !== undefined ) {\r\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfirst.length = i;\r\n\r\n\t\treturn first;\r\n\t},\r\n\r\n\tgrep: function( elems, callback, inv ) {\r\n\t\tvar retVal,\r\n\t\t\tret = [],\r\n\t\t\ti = 0,\r\n\t\t\tlength = elems.length;\r\n\t\tinv = !!inv;\r\n\r\n\t\t// Go through the array, only saving the items\r\n\t\t// that pass the validator function\r\n\t\tfor ( ; i < length; i++ ) {\r\n\t\t\tretVal = !!callback( elems[ i ], i );\r\n\t\t\tif ( inv !== retVal ) {\r\n\t\t\t\tret.push( elems[ i ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// arg is for internal usage only\r\n\tmap: function( elems, callback, arg ) {\r\n\t\tvar value,\r\n\t\t\ti = 0,\r\n\t\t\tlength = elems.length,\r\n\t\t\tisArray = isArraylike( elems ),\r\n\t\t\tret = [];\r\n\r\n\t\t// Go through the array, translating each of the items to their\r\n\t\tif ( isArray ) {\r\n\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\r\n\r\n\t\t\t\tif ( value != null ) {\r\n\t\t\t\t\tret[ ret.length ] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// Go through every key on the object,\r\n\t\t} else {\r\n\t\t\tfor ( i in elems ) {\r\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\r\n\r\n\t\t\t\tif ( value != null ) {\r\n\t\t\t\t\tret[ ret.length ] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Flatten any nested arrays\r\n\t\treturn core_concat.apply( [], ret );\r\n\t},\r\n\r\n\t// A global GUID counter for objects\r\n\tguid: 1,\r\n\r\n\t// Bind a function to a context, optionally partially applying any\r\n\t// arguments.\r\n\tproxy: function( fn, context ) {\r\n\t\tvar tmp, args, proxy;\r\n\r\n\t\tif ( typeof context === \"string\" ) {\r\n\t\t\ttmp = fn[ context ];\r\n\t\t\tcontext = fn;\r\n\t\t\tfn = tmp;\r\n\t\t}\r\n\r\n\t\t// Quick check to determine if target is callable, in the spec\r\n\t\t// this throws a TypeError, but we will just return undefined.\r\n\t\tif ( !jQuery.isFunction( fn ) ) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// Simulated bind\r\n\t\targs = core_slice.call( arguments, 2 );\r\n\t\tproxy = function() {\r\n\t\t\treturn fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\r\n\t\t};\r\n\r\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\r\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\r\n\r\n\t\treturn proxy;\r\n\t},\r\n\r\n\t// Multifunctional method to get and set values of a collection\r\n\t// The value/s can optionally be executed if it's a function\r\n\taccess: function( elems, fn, key, value, chainable, emptyGet, raw ) {\r\n\t\tvar i = 0,\r\n\t\t\tlength = elems.length,\r\n\t\t\tbulk = key == null;\r\n\r\n\t\t// Sets many values\r\n\t\tif ( jQuery.type( key ) === \"object\" ) {\r\n\t\t\tchainable = true;\r\n\t\t\tfor ( i in key ) {\r\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\r\n\t\t\t}\r\n\r\n\t\t// Sets one value\r\n\t\t} else if ( value !== undefined ) {\r\n\t\t\tchainable = true;\r\n\r\n\t\t\tif ( !jQuery.isFunction( value ) ) {\r\n\t\t\t\traw = true;\r\n\t\t\t}\r\n\r\n\t\t\tif ( bulk ) {\r\n\t\t\t\t// Bulk operations run against the entire set\r\n\t\t\t\tif ( raw ) {\r\n\t\t\t\t\tfn.call( elems, value );\r\n\t\t\t\t\tfn = null;\r\n\r\n\t\t\t\t// ...except when executing function values\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbulk = fn;\r\n\t\t\t\t\tfn = function( elem, key, value ) {\r\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( fn ) {\r\n\t\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn chainable ?\r\n\t\t\telems :\r\n\r\n\t\t\t// Gets\r\n\t\t\tbulk ?\r\n\t\t\t\tfn.call( elems ) :\r\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\r\n\t},\r\n\r\n\tnow: Date.now,\r\n\r\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\r\n\t// Note: this method belongs to the css module but it's needed here for the support module.\r\n\t// If support gets modularized, this method should be moved back to the css module.\r\n\tswap: function( elem, options, callback, args ) {\r\n\t\tvar ret, name,\r\n\t\t\told = {};\r\n\r\n\t\t// Remember the old values, and insert the new ones\r\n\t\tfor ( name in options ) {\r\n\t\t\told[ name ] = elem.style[ name ];\r\n\t\t\telem.style[ name ] = options[ name ];\r\n\t\t}\r\n\r\n\t\tret = callback.apply( elem, args || [] );\r\n\r\n\t\t// Revert the old values\r\n\t\tfor ( name in options ) {\r\n\t\t\telem.style[ name ] = old[ name ];\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n});\r\n\r\njQuery.ready.promise = function( obj ) {\r\n\tif ( !readyList ) {\r\n\r\n\t\treadyList = jQuery.Deferred();\r\n\r\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\r\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\r\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\r\n\t\tif ( document.readyState === \"complete\" ) {\r\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\r\n\t\t\tsetTimeout( jQuery.ready );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Use the handy event callback\r\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\r\n\r\n\t\t\t// A fallback to window.onload, that will always work\r\n\t\t\twindow.addEventListener( \"load\", completed, false );\r\n\t\t}\r\n\t}\r\n\treturn readyList.promise( obj );\r\n};\r\n\r\n// Populate the class2type map\r\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\r\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\r\n});\r\n\r\nfunction isArraylike( obj ) {\r\n\tvar length = obj.length,\r\n\t\ttype = jQuery.type( obj );\r\n\r\n\tif ( jQuery.isWindow( obj ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( obj.nodeType === 1 && length ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn type === \"array\" || type !== \"function\" &&\r\n\t\t( length === 0 ||\r\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\r\n}\r\n\r\n// All jQuery objects should point back to these\r\nrootjQuery = jQuery(document);\r\n/*!\r\n * Sizzle CSS Selector Engine v1.9.2-pre\r\n * http://sizzlejs.com/\r\n *\r\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\r\n * Released under the MIT license\r\n * http://jquery.org/license\r\n *\r\n * Date: 2013-04-16\r\n */\r\n(function( window, undefined ) {\r\n\r\nvar i,\r\n\tcachedruns,\r\n\tExpr,\r\n\tgetText,\r\n\tisXML,\r\n\tcompile,\r\n\toutermostContext,\r\n\tsortInput,\r\n\r\n\t// Local document vars\r\n\tsetDocument,\r\n\tdocument,\r\n\tdocElem,\r\n\tdocumentIsHTML,\r\n\trbuggyQSA,\r\n\trbuggyMatches,\r\n\tmatches,\r\n\tcontains,\r\n\r\n\t// Instance-specific data\r\n\texpando = \"sizzle\" + -(new Date()),\r\n\tpreferredDoc = window.document,\r\n\tsupport = {},\r\n\tdirruns = 0,\r\n\tdone = 0,\r\n\tclassCache = createCache(),\r\n\ttokenCache = createCache(),\r\n\tcompilerCache = createCache(),\r\n\thasDuplicate = false,\r\n\tsortOrder = function() { return 0; },\r\n\r\n\t// General-purpose constants\r\n\tstrundefined = typeof undefined,\r\n\tMAX_NEGATIVE = 1 << 31,\r\n\r\n\t// Array methods\r\n\tarr = [],\r\n\tpop = arr.pop,\r\n\tpush_native = arr.push,\r\n\tpush = arr.push,\r\n\tslice = arr.slice,\r\n\t// Use a stripped-down indexOf if we can't use a native one\r\n\tindexOf = arr.indexOf || function( elem ) {\r\n\t\tvar i = 0,\r\n\t\t\tlen = this.length;\r\n\t\tfor ( ; i < len; i++ ) {\r\n\t\t\tif ( this[i] === elem ) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t},\r\n\r\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\r\n\r\n\t// Regular expressions\r\n\r\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\r\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\r\n\t// http://www.w3.org/TR/css3-syntax/#characters\r\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\r\n\r\n\t// Loosely modeled on CSS identifier characters\r\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\r\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\r\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\r\n\r\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\r\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\r\n\t\t\"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\r\n\r\n\t// Prefer arguments quoted,\r\n\t//   then not containing pseudos/brackets,\r\n\t//   then attribute selectors/non-parenthetical expressions,\r\n\t//   then anything else\r\n\t// These preferences are here to reduce the number of selectors\r\n\t//   needing tokenize in the PSEUDO preFilter\r\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\r\n\r\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\r\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\r\n\r\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\r\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\r\n\r\n\trsibling = new RegExp( whitespace + \"*[+~]\" ),\r\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*)\" + whitespace + \"*\\\\]\", \"g\" ),\r\n\r\n\trpseudo = new RegExp( pseudos ),\r\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\r\n\r\n\tmatchExpr = {\r\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\r\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\r\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\r\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\r\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\r\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\r\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\r\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\r\n\t\t\"boolean\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\r\n\t\t// For use in libraries implementing .is()\r\n\t\t// We use this for POS matching in `select`\r\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\r\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\r\n\t},\r\n\r\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\r\n\r\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\r\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\r\n\r\n\trinputs = /^(?:input|select|textarea|button)$/i,\r\n\trheader = /^h\\d$/i,\r\n\r\n\trescape = /'|\\\\/g,\r\n\r\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\r\n\trunescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\r\n\tfunescape = function( _, escaped ) {\r\n\t\tvar high = \"0x\" + escaped - 0x10000;\r\n\t\t// NaN means non-codepoint\r\n\t\treturn high !== high ?\r\n\t\t\tescaped :\r\n\t\t\t// BMP codepoint\r\n\t\t\thigh < 0 ?\r\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\r\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\r\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\r\n\t};\r\n\r\n// Optimize for push.apply( _, NodeList )\r\ntry {\r\n\tpush.apply(\r\n\t\t(arr = slice.call( preferredDoc.childNodes )),\r\n\t\tpreferredDoc.childNodes\r\n\t);\r\n\t// Support: Android<4.0\r\n\t// Detect silently failing push.apply\r\n\tarr[ preferredDoc.childNodes.length ].nodeType;\r\n} catch ( e ) {\r\n\tpush = { apply: arr.length ?\r\n\r\n\t\t// Leverage slice if possible\r\n\t\tfunction( target, els ) {\r\n\t\t\tpush_native.apply( target, slice.call(els) );\r\n\t\t} :\r\n\r\n\t\t// Support: IE<9\r\n\t\t// Otherwise append directly\r\n\t\tfunction( target, els ) {\r\n\t\t\tvar j = target.length,\r\n\t\t\t\ti = 0;\r\n\t\t\t// Can't trust NodeList.length\r\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\r\n\t\t\ttarget.length = j - 1;\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * For feature detection\r\n * @param {Function} fn The function to test for native support\r\n */\r\nfunction isNative( fn ) {\r\n\treturn rnative.test( fn + \"\" );\r\n}\r\n\r\n/**\r\n * Create key-value caches of limited size\r\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\r\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\r\n *\tdeleting the oldest entry\r\n */\r\nfunction createCache() {\r\n\tvar cache,\r\n\t\tkeys = [];\r\n\r\n\treturn (cache = function( key, value ) {\r\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\r\n\t\tif ( keys.push( key += \" \" ) > Expr.cacheLength ) {\r\n\t\t\t// Only keep the most recent entries\r\n\t\t\tdelete cache[ keys.shift() ];\r\n\t\t}\r\n\t\treturn (cache[ key ] = value);\r\n\t});\r\n}\r\n\r\n/**\r\n * Mark a function for special use by Sizzle\r\n * @param {Function} fn The function to mark\r\n */\r\nfunction markFunction( fn ) {\r\n\tfn[ expando ] = true;\r\n\treturn fn;\r\n}\r\n\r\n/**\r\n * Support testing using an element\r\n * @param {Function} fn Passed the created div and expects a boolean result\r\n */\r\nfunction assert( fn ) {\r\n\tvar div = document.createElement(\"div\");\r\n\r\n\ttry {\r\n\t\treturn !!fn( div );\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t} finally {\r\n\t\tif ( div.parentNode ) {\r\n\t\t\tdiv.parentNode.removeChild( div );\r\n\t\t}\r\n\t\t// release memory in IE\r\n\t\tdiv = null;\r\n\t}\r\n}\r\n\r\nfunction Sizzle( selector, context, results, seed ) {\r\n\tvar match, elem, m, nodeType,\r\n\t\t// QSA vars\r\n\t\ti, groups, old, nid, newContext, newSelector;\r\n\r\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\r\n\t\tsetDocument( context );\r\n\t}\r\n\r\n\tcontext = context || document;\r\n\tresults = results || [];\r\n\r\n\tif ( !selector || typeof selector !== \"string\" ) {\r\n\t\treturn results;\r\n\t}\r\n\r\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tif ( documentIsHTML && !seed ) {\r\n\r\n\t\t// Shortcuts\r\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\r\n\t\t\t// Speed-up: Sizzle(\"#ID\")\r\n\t\t\tif ( (m = match[1]) ) {\r\n\t\t\t\tif ( nodeType === 9 ) {\r\n\t\t\t\t\telem = context.getElementById( m );\r\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\r\n\t\t\t\t\t// nodes that are no longer in the document #6963\r\n\t\t\t\t\tif ( elem && elem.parentNode ) {\r\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\r\n\t\t\t\t\t\t// by name instead of ID\r\n\t\t\t\t\t\tif ( elem.id === m ) {\r\n\t\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Context is not a document\r\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\r\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\r\n\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t// Speed-up: Sizzle(\"TAG\")\r\n\t\t\t} else if ( match[2] ) {\r\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\r\n\t\t\t\treturn results;\r\n\r\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\r\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\r\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\r\n\t\t\t\treturn results;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// QSA path\r\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\r\n\t\t\tnid = old = expando;\r\n\t\t\tnewContext = context;\r\n\t\t\tnewSelector = nodeType === 9 && selector;\r\n\r\n\t\t\t// qSA works strangely on Element-rooted queries\r\n\t\t\t// We can work around this by specifying an extra ID on the root\r\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\r\n\t\t\t// IE 8 doesn't work on object elements\r\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\r\n\t\t\t\tgroups = tokenize( selector );\r\n\r\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\r\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\r\n\t\t\t\t}\r\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\r\n\r\n\t\t\t\ti = groups.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\r\n\t\t\t\t}\r\n\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\r\n\t\t\t\tnewSelector = groups.join(\",\");\r\n\t\t\t}\r\n\r\n\t\t\tif ( newSelector ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tpush.apply( results,\r\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t} catch(qsaError) {\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tif ( !old ) {\r\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// All others\r\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\r\n}\r\n\r\n/**\r\n * Detect xml\r\n * @param {Element|Object} elem An element or a document\r\n */\r\nisXML = Sizzle.isXML = function( elem ) {\r\n\t// documentElement is verified for cases where it doesn't yet exist\r\n\t// (such as loading iframes in IE - #4833)\r\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\r\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\r\n};\r\n\r\n/**\r\n * Sets document-related variables once based on the current document\r\n * @param {Element|Object} [doc] An element or document object to use to set the document\r\n * @returns {Object} Returns the current document\r\n */\r\nsetDocument = Sizzle.setDocument = function( node ) {\r\n\tvar doc = node ? node.ownerDocument || node : preferredDoc;\r\n\r\n\t// If no document and documentElement is available, return\r\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\r\n\t\treturn document;\r\n\t}\r\n\r\n\t// Set our document\r\n\tdocument = doc;\r\n\tdocElem = doc.documentElement;\r\n\r\n\t// Support tests\r\n\tdocumentIsHTML = !isXML( doc );\r\n\r\n\t// Check if getElementsByTagName(\"*\") returns only elements\r\n\tsupport.getElementsByTagName = assert(function( div ) {\r\n\t\tdiv.appendChild( doc.createComment(\"\") );\r\n\t\treturn !div.getElementsByTagName(\"*\").length;\r\n\t});\r\n\r\n\t// Support: IE<8\r\n\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\r\n\tsupport.attributes = assert(function( div ) {\r\n\t\tdiv.className = \"i\";\r\n\t\treturn !div.getAttribute(\"className\");\r\n\t});\r\n\r\n\t// Check if getElementsByClassName can be trusted\r\n\tsupport.getElementsByClassName = assert(function( div ) {\r\n\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\r\n\r\n\t\t// Support: Safari<4\r\n\t\t// Catch class over-caching\r\n\t\tdiv.firstChild.className = \"i\";\r\n\t\t// Support: Opera<10\r\n\t\t// Catch gEBCN failure to find non-leading classes\r\n\t\treturn div.getElementsByClassName(\"i\").length === 2;\r\n\t});\r\n\r\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\r\n\t// Detached nodes confoundingly follow *each other*\r\n\tsupport.sortDetached = assert(function( div1 ) {\r\n\t\t// Should return 1, but returns 4 (following)\r\n\t\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\r\n\t});\r\n\r\n\t// Support: IE<10\r\n\t// Check if getElementById returns elements by name\r\n\t// Support: Windows 8 Native Apps\r\n\t// Assigning innerHTML with \"name\" attributes throws uncatchable exceptions\r\n\t// (http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx)\r\n\t// and the broken getElementById methods don't pick up programatically-set names,\r\n\t// so use a roundabout getElementsByName test\r\n\tsupport.getById = assert(function( div ) {\r\n\t\tdocElem.appendChild( div ).id = expando;\r\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\r\n\t});\r\n\r\n\t// ID find and filter\r\n\tif ( support.getById ) {\r\n\t\tExpr.find[\"ID\"] = function( id, context ) {\r\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\r\n\t\t\t\tvar m = context.getElementById( id );\r\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\r\n\t\t\t\t// nodes that are no longer in the document #6963\r\n\t\t\t\treturn m && m.parentNode ? [m] : [];\r\n\t\t\t}\r\n\t\t};\r\n\t\tExpr.filter[\"ID\"] = function( id ) {\r\n\t\t\tvar attrId = id.replace( runescape, funescape );\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\r\n\t\t\t};\r\n\t\t};\r\n\t} else {\r\n\t\tExpr.find[\"ID\"] = function( id, context ) {\r\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\r\n\t\t\t\tvar m = context.getElementById( id );\r\n\r\n\t\t\t\treturn m ?\r\n\t\t\t\t\tm.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode(\"id\").value === id ?\r\n\t\t\t\t\t\t[m] :\r\n\t\t\t\t\t\tundefined :\r\n\t\t\t\t\t[];\r\n\t\t\t}\r\n\t\t};\r\n\t\tExpr.filter[\"ID\"] =  function( id ) {\r\n\t\t\tvar attrId = id.replace( runescape, funescape );\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\r\n\t\t\t\treturn node && node.value === attrId;\r\n\t\t\t};\r\n\t\t};\r\n\t}\r\n\r\n\t// Tag\r\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\r\n\t\tfunction( tag, context ) {\r\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\r\n\t\t\t\treturn context.getElementsByTagName( tag );\r\n\t\t\t}\r\n\t\t} :\r\n\t\tfunction( tag, context ) {\r\n\t\t\tvar elem,\r\n\t\t\t\ttmp = [],\r\n\t\t\t\ti = 0,\r\n\t\t\t\tresults = context.getElementsByTagName( tag );\r\n\r\n\t\t\t// Filter out possible comments\r\n\t\t\tif ( tag === \"*\" ) {\r\n\t\t\t\twhile ( (elem = results[i++]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\ttmp.push( elem );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn tmp;\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t};\r\n\r\n\t// Class\r\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\r\n\t\tif ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\r\n\t\t\treturn context.getElementsByClassName( className );\r\n\t\t}\r\n\t};\r\n\r\n\t// QSA and matchesSelector support\r\n\r\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\r\n\trbuggyMatches = [];\r\n\r\n\t// qSa(:focus) reports false when true (Chrome 21)\r\n\t// We allow this because of a bug in IE8/9 that throws an error\r\n\t// whenever `document.activeElement` is accessed on an iframe\r\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\r\n\t// See http://bugs.jquery.com/ticket/13378\r\n\trbuggyQSA = [];\r\n\r\n\tif ( (support.qsa = isNative(doc.querySelectorAll)) ) {\r\n\t\t// Build QSA regex\r\n\t\t// Regex strategy adopted from Diego Perini\r\n\t\tassert(function( div ) {\r\n\t\t\t// Select is set to empty string on purpose\r\n\t\t\t// This is to test IE's treatment of not explicitly\r\n\t\t\t// setting a boolean content attribute,\r\n\t\t\t// since its presence should be enough\r\n\t\t\t// http://bugs.jquery.com/ticket/12359\r\n\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\r\n\r\n\t\t\t// Support: IE8\r\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\r\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Webkit/Opera - :checked should return selected option elements\r\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n\t\t\t// IE8 throws error here and will not see later tests\r\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\r\n\t\t\t\trbuggyQSA.push(\":checked\");\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tassert(function( div ) {\r\n\r\n\t\t\t// Support: Opera 10-12/IE8\r\n\t\t\t// ^= $= *= and empty values\r\n\t\t\t// Should not select anything\r\n\t\t\t// Support: Windows 8 Native Apps\r\n\t\t\t// The type attribute is restricted during .innerHTML assignment\r\n\t\t\tvar input = document.createElement(\"input\");\r\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\r\n\t\t\tdiv.appendChild( input ).setAttribute( \"t\", \"\" );\r\n\r\n\t\t\tif ( div.querySelectorAll(\"[t^='']\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\r\n\t\t\t}\r\n\r\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\r\n\t\t\t// IE8 throws error here and will not see later tests\r\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\r\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\r\n\t\t\tdiv.querySelectorAll(\"*,:x\");\r\n\t\t\trbuggyQSA.push(\",.*:\");\r\n\t\t});\r\n\t}\r\n\r\n\tif ( (support.matchesSelector = isNative( (matches = docElem.webkitMatchesSelector ||\r\n\t\tdocElem.mozMatchesSelector ||\r\n\t\tdocElem.oMatchesSelector ||\r\n\t\tdocElem.msMatchesSelector) )) ) {\r\n\r\n\t\tassert(function( div ) {\r\n\t\t\t// Check to see if it's possible to do matchesSelector\r\n\t\t\t// on a disconnected node (IE 9)\r\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\r\n\r\n\t\t\t// This should fail with an exception\r\n\t\t\t// Gecko does not error, returns false instead\r\n\t\t\tmatches.call( div, \"[s!='']:x\" );\r\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\r\n\t\t});\r\n\t}\r\n\r\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\r\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\r\n\r\n\t// Element contains another\r\n\t// Purposefully does not implement inclusive descendent\r\n\t// As in, an element does not contain itself\r\n\tcontains = isNative(docElem.contains) || docElem.compareDocumentPosition ?\r\n\t\tfunction( a, b ) {\r\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\r\n\t\t\t\tbup = b && b.parentNode;\r\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\r\n\t\t\t\tadown.contains ?\r\n\t\t\t\t\tadown.contains( bup ) :\r\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\r\n\t\t\t));\r\n\t\t} :\r\n\t\tfunction( a, b ) {\r\n\t\t\tif ( b ) {\r\n\t\t\t\twhile ( (b = b.parentNode) ) {\r\n\t\t\t\t\tif ( b === a ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n\t// Document order sorting\r\n\tsortOrder = docElem.compareDocumentPosition ?\r\n\tfunction( a, b ) {\r\n\r\n\t\t// Flag for duplicate removal\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tvar compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );\r\n\r\n\t\tif ( compare ) {\r\n\t\t\t// Disconnected nodes\r\n\t\t\tif ( compare & 1 ||\r\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\r\n\r\n\t\t\t\t// Choose the first element that is related to our preferred document\r\n\t\t\t\tif ( a === doc || contains(preferredDoc, a) ) {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t\tif ( b === doc || contains(preferredDoc, b) ) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Maintain original order\r\n\t\t\t\treturn sortInput ?\r\n\t\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\r\n\t\t\t\t\t0;\r\n\t\t\t}\r\n\r\n\t\t\treturn compare & 4 ? -1 : 1;\r\n\t\t}\r\n\r\n\t\t// Not directly comparable, sort on existence of method\r\n\t\treturn a.compareDocumentPosition ? -1 : 1;\r\n\t} :\r\n\tfunction( a, b ) {\r\n\t\tvar cur,\r\n\t\t\ti = 0,\r\n\t\t\taup = a.parentNode,\r\n\t\t\tbup = b.parentNode,\r\n\t\t\tap = [ a ],\r\n\t\t\tbp = [ b ];\r\n\r\n\t\t// Exit early if the nodes are identical\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\r\n\t\t// Parentless nodes are either documents or disconnected\r\n\t\t} else if ( !aup || !bup ) {\r\n\t\t\treturn a === doc ? -1 :\r\n\t\t\t\tb === doc ? 1 :\r\n\t\t\t\taup ? -1 :\r\n\t\t\t\tbup ? 1 :\r\n\t\t\t\tsortInput ?\r\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\r\n\t\t\t\t0;\r\n\r\n\t\t// If the nodes are siblings, we can do a quick check\r\n\t\t} else if ( aup === bup ) {\r\n\t\t\treturn siblingCheck( a, b );\r\n\t\t}\r\n\r\n\t\t// Otherwise we need full lists of their ancestors for comparison\r\n\t\tcur = a;\r\n\t\twhile ( (cur = cur.parentNode) ) {\r\n\t\t\tap.unshift( cur );\r\n\t\t}\r\n\t\tcur = b;\r\n\t\twhile ( (cur = cur.parentNode) ) {\r\n\t\t\tbp.unshift( cur );\r\n\t\t}\r\n\r\n\t\t// Walk down the tree looking for a discrepancy\r\n\t\twhile ( ap[i] === bp[i] ) {\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn i ?\r\n\t\t\t// Do a sibling check if the nodes have a common ancestor\r\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\r\n\r\n\t\t\t// Otherwise nodes in our document sort first\r\n\t\t\tap[i] === preferredDoc ? -1 :\r\n\t\t\tbp[i] === preferredDoc ? 1 :\r\n\t\t\t0;\r\n\t};\r\n\r\n\treturn document;\r\n};\r\n\r\nSizzle.matches = function( expr, elements ) {\r\n\treturn Sizzle( expr, null, null, elements );\r\n};\r\n\r\nSizzle.matchesSelector = function( elem, expr ) {\r\n\t// Set document vars if needed\r\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\r\n\t\tsetDocument( elem );\r\n\t}\r\n\r\n\t// Make sure that attribute selectors are quoted\r\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\r\n\r\n\t// rbuggyQSA always contains :focus, so no need for an existence check\r\n\tif ( support.matchesSelector && documentIsHTML &&\r\n\t\t(!rbuggyMatches || !rbuggyMatches.test(expr)) &&\r\n\t\t(!rbuggyQSA     || !rbuggyQSA.test(expr)) ) {\r\n\r\n\t\ttry {\r\n\t\t\tvar ret = matches.call( elem, expr );\r\n\r\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\r\n\t\t\tif ( ret || support.disconnectedMatch ||\r\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\r\n\t\t\t\t\t// fragment in IE 9\r\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t} catch(e) {}\r\n\t}\r\n\r\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\r\n};\r\n\r\nSizzle.contains = function( context, elem ) {\r\n\t// Set document vars if needed\r\n\tif ( ( context.ownerDocument || context ) !== document ) {\r\n\t\tsetDocument( context );\r\n\t}\r\n\treturn contains( context, elem );\r\n};\r\n\r\nSizzle.attr = function( elem, name ) {\r\n\t// Set document vars if needed\r\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\r\n\t\tsetDocument( elem );\r\n\t}\r\n\r\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\r\n\t\tval = fn && fn( elem, name, !documentIsHTML );\r\n\r\n\treturn val === undefined ?\r\n\t\tsupport.attributes || !documentIsHTML ?\r\n\t\t\telem.getAttribute( name ) :\r\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\r\n\t\t\t\tval.value :\r\n\t\t\t\tnull :\r\n\t\tval;\r\n};\r\n\r\nSizzle.error = function( msg ) {\r\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\r\n};\r\n\r\n// Document sorting and removing duplicates\r\nSizzle.uniqueSort = function( results ) {\r\n\tvar elem,\r\n\t\tduplicates = [],\r\n\t\tj = 0,\r\n\t\ti = 0;\r\n\r\n\t// Unless we *know* we can detect duplicates, assume their presence\r\n\thasDuplicate = !support.detectDuplicates;\r\n\tsortInput = !support.sortStable && results.slice( 0 );\r\n\tresults.sort( sortOrder );\r\n\r\n\tif ( hasDuplicate ) {\r\n\t\twhile ( (elem = results[i++]) ) {\r\n\t\t\tif ( elem === results[ i ] ) {\r\n\t\t\t\tj = duplicates.push( i );\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile ( j-- ) {\r\n\t\t\tresults.splice( duplicates[ j ], 1 );\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n};\r\n\r\n/**\r\n * Checks document order of two siblings\r\n * @param {Element} a\r\n * @param {Element} b\r\n * @returns Returns -1 if a precedes b, 1 if a follows b\r\n */\r\nfunction siblingCheck( a, b ) {\r\n\tvar cur = b && a,\r\n\t\tdiff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );\r\n\r\n\t// Use IE sourceIndex if available on both nodes\r\n\tif ( diff ) {\r\n\t\treturn diff;\r\n\t}\r\n\r\n\t// Check if b follows a\r\n\tif ( cur ) {\r\n\t\twhile ( (cur = cur.nextSibling) ) {\r\n\t\t\tif ( cur === b ) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn a ? 1 : -1;\r\n}\r\n\r\n// Fetches boolean attributes by node\r\nfunction boolHandler( elem, name, isXML ) {\r\n\tvar val;\r\n\treturn isXML ?\r\n\t\tundefined :\r\n\t\t(val = elem.getAttributeNode( name )) && val.specified ?\r\n\t\t\tval.value :\r\n\t\t\telem[ name ] === true ? name.toLowerCase() : null;\r\n}\r\n\r\n// Fetches attributes without interpolation\r\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\r\nfunction interpolationHandler( elem, name, isXML ) {\r\n\tvar val;\r\n\treturn isXML ?\r\n\t\tundefined :\r\n\t\t(val = elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 ));\r\n}\r\n\r\n// Returns a function to use in pseudos for input types\r\nfunction createInputPseudo( type ) {\r\n\treturn function( elem ) {\r\n\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\treturn name === \"input\" && elem.type === type;\r\n\t};\r\n}\r\n\r\n// Returns a function to use in pseudos for buttons\r\nfunction createButtonPseudo( type ) {\r\n\treturn function( elem ) {\r\n\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\r\n\t};\r\n}\r\n\r\n// Returns a function to use in pseudos for positionals\r\nfunction createPositionalPseudo( fn ) {\r\n\treturn markFunction(function( argument ) {\r\n\t\targument = +argument;\r\n\t\treturn markFunction(function( seed, matches ) {\r\n\t\t\tvar j,\r\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\r\n\t\t\t\ti = matchIndexes.length;\r\n\r\n\t\t\t// Match elements found at the specified indexes\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\r\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Utility function for retrieving the text value of an array of DOM nodes\r\n * @param {Array|Element} elem\r\n */\r\ngetText = Sizzle.getText = function( elem ) {\r\n\tvar node,\r\n\t\tret = \"\",\r\n\t\ti = 0,\r\n\t\tnodeType = elem.nodeType;\r\n\r\n\tif ( !nodeType ) {\r\n\t\t// If no nodeType, this is expected to be an array\r\n\t\tfor ( ; (node = elem[i]); i++ ) {\r\n\t\t\t// Do not traverse comment nodes\r\n\t\t\tret += getText( node );\r\n\t\t}\r\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\r\n\t\t// Use textContent for elements\r\n\t\t// innerText usage removed for consistency of new lines (see #11153)\r\n\t\tif ( typeof elem.textContent === \"string\" ) {\r\n\t\t\treturn elem.textContent;\r\n\t\t} else {\r\n\t\t\t// Traverse its children\r\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\r\n\t\t\t\tret += getText( elem );\r\n\t\t\t}\r\n\t\t}\r\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\r\n\t\treturn elem.nodeValue;\r\n\t}\r\n\t// Do not include comment or processing instruction nodes\r\n\r\n\treturn ret;\r\n};\r\n\r\nExpr = Sizzle.selectors = {\r\n\r\n\t// Can be adjusted by the user\r\n\tcacheLength: 50,\r\n\r\n\tcreatePseudo: markFunction,\r\n\r\n\tmatch: matchExpr,\r\n\r\n\tattrHandle: {},\r\n\r\n\tfind: {},\r\n\r\n\trelative: {\r\n\t\t\">\": { dir: \"parentNode\", first: true },\r\n\t\t\" \": { dir: \"parentNode\" },\r\n\t\t\"+\": { dir: \"previousSibling\", first: true },\r\n\t\t\"~\": { dir: \"previousSibling\" }\r\n\t},\r\n\r\n\tpreFilter: {\r\n\t\t\"ATTR\": function( match ) {\r\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\r\n\r\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\r\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\r\n\r\n\t\t\tif ( match[2] === \"~=\" ) {\r\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\r\n\t\t\t}\r\n\r\n\t\t\treturn match.slice( 0, 4 );\r\n\t\t},\r\n\r\n\t\t\"CHILD\": function( match ) {\r\n\t\t\t/* matches from matchExpr[\"CHILD\"]\r\n\t\t\t\t1 type (only|nth|...)\r\n\t\t\t\t2 what (child|of-type)\r\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\r\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\r\n\t\t\t\t5 sign of xn-component\r\n\t\t\t\t6 x of xn-component\r\n\t\t\t\t7 sign of y-component\r\n\t\t\t\t8 y of y-component\r\n\t\t\t*/\r\n\t\t\tmatch[1] = match[1].toLowerCase();\r\n\r\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\r\n\t\t\t\t// nth-* requires argument\r\n\t\t\t\tif ( !match[3] ) {\r\n\t\t\t\t\tSizzle.error( match[0] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\r\n\t\t\t\t// remember that false/true cast respectively to 0/1\r\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\r\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\r\n\r\n\t\t\t// other types prohibit arguments\r\n\t\t\t} else if ( match[3] ) {\r\n\t\t\t\tSizzle.error( match[0] );\r\n\t\t\t}\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\r\n\t\t\"PSEUDO\": function( match ) {\r\n\t\t\tvar excess,\r\n\t\t\t\tunquoted = !match[5] && match[2];\r\n\r\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// Accept quoted arguments as-is\r\n\t\t\tif ( match[4] ) {\r\n\t\t\t\tmatch[2] = match[4];\r\n\r\n\t\t\t// Strip excess characters from unquoted arguments\r\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\r\n\t\t\t\t// Get excess from tokenize (recursively)\r\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\r\n\t\t\t\t// advance to the next closing parenthesis\r\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\r\n\r\n\t\t\t\t// excess is a negative index\r\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\r\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\r\n\t\t\t}\r\n\r\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\r\n\t\t\treturn match.slice( 0, 3 );\r\n\t\t}\r\n\t},\r\n\r\n\tfilter: {\r\n\r\n\t\t\"TAG\": function( nodeNameSelector ) {\r\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\r\n\t\t\treturn nodeNameSelector === \"*\" ?\r\n\t\t\t\tfunction() { return true; } :\r\n\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\r\n\t\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"CLASS\": function( className ) {\r\n\t\t\tvar pattern = classCache[ className + \" \" ];\r\n\r\n\t\t\treturn pattern ||\r\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\r\n\t\t\t\tclassCache( className, function( elem ) {\r\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\r\n\t\t\t\t});\r\n\t\t},\r\n\r\n\t\t\"ATTR\": function( name, operator, check ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar result = Sizzle.attr( elem, name );\r\n\r\n\t\t\t\tif ( result == null ) {\r\n\t\t\t\t\treturn operator === \"!=\";\r\n\t\t\t\t}\r\n\t\t\t\tif ( !operator ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult += \"\";\r\n\r\n\t\t\t\treturn operator === \"=\" ? result === check :\r\n\t\t\t\t\toperator === \"!=\" ? result !== check :\r\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\r\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\r\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\r\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\r\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\r\n\t\t\t\t\tfalse;\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\r\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\r\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\r\n\t\t\t\tofType = what === \"of-type\";\r\n\r\n\t\t\treturn first === 1 && last === 0 ?\r\n\r\n\t\t\t\t// Shortcut for :nth-*(n)\r\n\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\treturn !!elem.parentNode;\r\n\t\t\t\t} :\r\n\r\n\t\t\t\tfunction( elem, context, xml ) {\r\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\r\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\r\n\t\t\t\t\t\tparent = elem.parentNode,\r\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\r\n\t\t\t\t\t\tuseCache = !xml && !ofType;\r\n\r\n\t\t\t\t\tif ( parent ) {\r\n\r\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\r\n\t\t\t\t\t\tif ( simple ) {\r\n\t\t\t\t\t\t\twhile ( dir ) {\r\n\t\t\t\t\t\t\t\tnode = elem;\r\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\r\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\r\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\r\n\r\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\r\n\t\t\t\t\t\tif ( forward && useCache ) {\r\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\r\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\r\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\r\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\r\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\r\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\r\n\r\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\r\n\r\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\r\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\r\n\r\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\r\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\r\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Use previously-cached element index if available\r\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\r\n\t\t\t\t\t\t\tdiff = cache[1];\r\n\r\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\r\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\r\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\r\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\r\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\r\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\r\n\t\t\t\t\t\tdiff -= last;\r\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"PSEUDO\": function( pseudo, argument ) {\r\n\t\t\t// pseudo-class names are case-insensitive\r\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\r\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\r\n\t\t\t// Remember that setFilters inherits from pseudos\r\n\t\t\tvar args,\r\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\r\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\r\n\r\n\t\t\t// The user may use createPseudo to indicate that\r\n\t\t\t// arguments are needed to create the filter function\r\n\t\t\t// just as Sizzle does\r\n\t\t\tif ( fn[ expando ] ) {\r\n\t\t\t\treturn fn( argument );\r\n\t\t\t}\r\n\r\n\t\t\t// But maintain support for old signatures\r\n\t\t\tif ( fn.length > 1 ) {\r\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\r\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\r\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\r\n\t\t\t\t\t\tvar idx,\r\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\r\n\t\t\t\t\t\t\ti = matched.length;\r\n\t\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\r\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}) :\r\n\t\t\t\t\tfunction( elem ) {\r\n\t\t\t\t\t\treturn fn( elem, 0, args );\r\n\t\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn fn;\r\n\t\t}\r\n\t},\r\n\r\n\tpseudos: {\r\n\t\t// Potentially complex pseudos\r\n\t\t\"not\": markFunction(function( selector ) {\r\n\t\t\t// Trim the selector passed to compile\r\n\t\t\t// to avoid treating leading and trailing\r\n\t\t\t// spaces as combinators\r\n\t\t\tvar input = [],\r\n\t\t\t\tresults = [],\r\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\r\n\r\n\t\t\treturn matcher[ expando ] ?\r\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\r\n\t\t\t\t\tvar elem,\r\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\r\n\t\t\t\t\t\ti = seed.length;\r\n\r\n\t\t\t\t\t// Match elements unmatched by `matcher`\r\n\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\r\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}) :\r\n\t\t\t\tfunction( elem, context, xml ) {\r\n\t\t\t\t\tinput[0] = elem;\r\n\t\t\t\t\tmatcher( input, null, xml, results );\r\n\t\t\t\t\treturn !results.pop();\r\n\t\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"has\": markFunction(function( selector ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"contains\": markFunction(function( text ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t// \"Whether an element is represented by a :lang() selector\r\n\t\t// is based solely on the element's language value\r\n\t\t// being equal to the identifier C,\r\n\t\t// or beginning with the identifier C immediately followed by \"-\".\r\n\t\t// The matching of C against the element's language value is performed case-insensitively.\r\n\t\t// The identifier C does not have to be a valid language name.\"\r\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\r\n\t\t\"lang\": markFunction( function( lang ) {\r\n\t\t\t// lang value must be a valid identifier\r\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\r\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\r\n\t\t\t}\r\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar elemLang;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\r\n\t\t\t\t\t\telem.lang :\r\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\r\n\r\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\r\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t// Miscellaneous\r\n\t\t\"target\": function( elem ) {\r\n\t\t\tvar hash = window.location && window.location.hash;\r\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\r\n\t\t},\r\n\r\n\t\t\"root\": function( elem ) {\r\n\t\t\treturn elem === docElem;\r\n\t\t},\r\n\r\n\t\t\"focus\": function( elem ) {\r\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\r\n\t\t},\r\n\r\n\t\t// Boolean properties\r\n\t\t\"enabled\": function( elem ) {\r\n\t\t\treturn elem.disabled === false;\r\n\t\t},\r\n\r\n\t\t\"disabled\": function( elem ) {\r\n\t\t\treturn elem.disabled === true;\r\n\t\t},\r\n\r\n\t\t\"checked\": function( elem ) {\r\n\t\t\t// In CSS3, :checked should return both checked and selected elements\r\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\r\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\r\n\t\t},\r\n\r\n\t\t\"selected\": function( elem ) {\r\n\t\t\t// Accessing this property makes selected-by-default\r\n\t\t\t// options in Safari work properly\r\n\t\t\tif ( elem.parentNode ) {\r\n\t\t\t\telem.parentNode.selectedIndex;\r\n\t\t\t}\r\n\r\n\t\t\treturn elem.selected === true;\r\n\t\t},\r\n\r\n\t\t// Contents\r\n\t\t\"empty\": function( elem ) {\r\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\r\n\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\r\n\t\t\t//   not comment, processing instructions, or others\r\n\t\t\t// Thanks to Diego Perini for the nodeName shortcut\r\n\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\r\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\r\n\t\t\t\tif ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t\"parent\": function( elem ) {\r\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\r\n\t\t},\r\n\r\n\t\t// Element/input types\r\n\t\t\"header\": function( elem ) {\r\n\t\t\treturn rheader.test( elem.nodeName );\r\n\t\t},\r\n\r\n\t\t\"input\": function( elem ) {\r\n\t\t\treturn rinputs.test( elem.nodeName );\r\n\t\t},\r\n\r\n\t\t\"button\": function( elem ) {\r\n\t\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\r\n\t\t},\r\n\r\n\t\t\"text\": function( elem ) {\r\n\t\t\tvar attr;\r\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\r\n\t\t\t// use getAttribute instead to test this case\r\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\r\n\t\t\t\telem.type === \"text\" &&\r\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\r\n\t\t},\r\n\r\n\t\t// Position-in-collection\r\n\t\t\"first\": createPositionalPseudo(function() {\r\n\t\t\treturn [ 0 ];\r\n\t\t}),\r\n\r\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\treturn [ length - 1 ];\r\n\t\t}),\r\n\r\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\r\n\t\t}),\r\n\r\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor ( ; i < length; i += 2 ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\r\n\t\t\tvar i = 1;\r\n\t\t\tfor ( ; i < length; i += 2 ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\tvar i = argument < 0 ? argument + length : argument;\r\n\t\t\tfor ( ; --i >= 0; ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t}),\r\n\r\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\r\n\t\t\tvar i = argument < 0 ? argument + length : argument;\r\n\t\t\tfor ( ; ++i < length; ) {\r\n\t\t\t\tmatchIndexes.push( i );\r\n\t\t\t}\r\n\t\t\treturn matchIndexes;\r\n\t\t})\r\n\t}\r\n};\r\n\r\n// Add button/input type pseudos\r\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\r\n\tExpr.pseudos[ i ] = createInputPseudo( i );\r\n}\r\nfor ( i in { submit: true, reset: true } ) {\r\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\r\n}\r\n\r\nfunction tokenize( selector, parseOnly ) {\r\n\tvar matched, match, tokens, type,\r\n\t\tsoFar, groups, preFilters,\r\n\t\tcached = tokenCache[ selector + \" \" ];\r\n\r\n\tif ( cached ) {\r\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\r\n\t}\r\n\r\n\tsoFar = selector;\r\n\tgroups = [];\r\n\tpreFilters = Expr.preFilter;\r\n\r\n\twhile ( soFar ) {\r\n\r\n\t\t// Comma and first run\r\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\r\n\t\t\tif ( match ) {\r\n\t\t\t\t// Don't consume trailing commas as valid\r\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\r\n\t\t\t}\r\n\t\t\tgroups.push( tokens = [] );\r\n\t\t}\r\n\r\n\t\tmatched = false;\r\n\r\n\t\t// Combinators\r\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\r\n\t\t\tmatched = match.shift();\r\n\t\t\ttokens.push( {\r\n\t\t\t\tvalue: matched,\r\n\t\t\t\t// Cast descendant combinators to space\r\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\r\n\t\t\t} );\r\n\t\t\tsoFar = soFar.slice( matched.length );\r\n\t\t}\r\n\r\n\t\t// Filters\r\n\t\tfor ( type in Expr.filter ) {\r\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\r\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\r\n\t\t\t\tmatched = match.shift();\r\n\t\t\t\ttokens.push( {\r\n\t\t\t\t\tvalue: matched,\r\n\t\t\t\t\ttype: type,\r\n\t\t\t\t\tmatches: match\r\n\t\t\t\t} );\r\n\t\t\t\tsoFar = soFar.slice( matched.length );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( !matched ) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the length of the invalid excess\r\n\t// if we're just parsing\r\n\t// Otherwise, throw an error or return tokens\r\n\treturn parseOnly ?\r\n\t\tsoFar.length :\r\n\t\tsoFar ?\r\n\t\t\tSizzle.error( selector ) :\r\n\t\t\t// Cache the tokens\r\n\t\t\ttokenCache( selector, groups ).slice( 0 );\r\n}\r\n\r\nfunction toSelector( tokens ) {\r\n\tvar i = 0,\r\n\t\tlen = tokens.length,\r\n\t\tselector = \"\";\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tselector += tokens[i].value;\r\n\t}\r\n\treturn selector;\r\n}\r\n\r\nfunction addCombinator( matcher, combinator, base ) {\r\n\tvar dir = combinator.dir,\r\n\t\tcheckNonElements = base && dir === \"parentNode\",\r\n\t\tdoneName = done++;\r\n\r\n\treturn combinator.first ?\r\n\t\t// Check against closest ancestor/preceding element\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\treturn matcher( elem, context, xml );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\r\n\t\t// Check against all ancestor/preceding elements\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\tvar data, cache, outerCache,\r\n\t\t\t\tdirkey = dirruns + \" \" + doneName;\r\n\r\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\r\n\t\t\tif ( xml ) {\r\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\r\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\r\n\t\t\t\t\t\tif ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\r\n\t\t\t\t\t\t\tif ( (data = cache[1]) === true || data === cachedruns ) {\r\n\t\t\t\t\t\t\t\treturn data === true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcache = outerCache[ dir ] = [ dirkey ];\r\n\t\t\t\t\t\t\tcache[1] = matcher( elem, context, xml ) || cachedruns;\r\n\t\t\t\t\t\t\tif ( cache[1] === true ) {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n}\r\n\r\nfunction elementMatcher( matchers ) {\r\n\treturn matchers.length > 1 ?\r\n\t\tfunction( elem, context, xml ) {\r\n\t\t\tvar i = matchers.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t} :\r\n\t\tmatchers[0];\r\n}\r\n\r\nfunction condense( unmatched, map, filter, context, xml ) {\r\n\tvar elem,\r\n\t\tnewUnmatched = [],\r\n\t\ti = 0,\r\n\t\tlen = unmatched.length,\r\n\t\tmapped = map != null;\r\n\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tif ( (elem = unmatched[i]) ) {\r\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\r\n\t\t\t\tnewUnmatched.push( elem );\r\n\t\t\t\tif ( mapped ) {\r\n\t\t\t\t\tmap.push( i );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn newUnmatched;\r\n}\r\n\r\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\r\n\tif ( postFilter && !postFilter[ expando ] ) {\r\n\t\tpostFilter = setMatcher( postFilter );\r\n\t}\r\n\tif ( postFinder && !postFinder[ expando ] ) {\r\n\t\tpostFinder = setMatcher( postFinder, postSelector );\r\n\t}\r\n\treturn markFunction(function( seed, results, context, xml ) {\r\n\t\tvar temp, i, elem,\r\n\t\t\tpreMap = [],\r\n\t\t\tpostMap = [],\r\n\t\t\tpreexisting = results.length,\r\n\r\n\t\t\t// Get initial elements from seed or context\r\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\r\n\r\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\r\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\r\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\r\n\t\t\t\telems,\r\n\r\n\t\t\tmatcherOut = matcher ?\r\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\r\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\r\n\r\n\t\t\t\t\t// ...intermediate processing is necessary\r\n\t\t\t\t\t[] :\r\n\r\n\t\t\t\t\t// ...otherwise use results directly\r\n\t\t\t\t\tresults :\r\n\t\t\t\tmatcherIn;\r\n\r\n\t\t// Find primary matches\r\n\t\tif ( matcher ) {\r\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\r\n\t\t}\r\n\r\n\t\t// Apply postFilter\r\n\t\tif ( postFilter ) {\r\n\t\t\ttemp = condense( matcherOut, postMap );\r\n\t\t\tpostFilter( temp, [], context, xml );\r\n\r\n\t\t\t// Un-match failing elements by moving them back to matcherIn\r\n\t\t\ti = temp.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tif ( (elem = temp[i]) ) {\r\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( seed ) {\r\n\t\t\tif ( postFinder || preFilter ) {\r\n\t\t\t\tif ( postFinder ) {\r\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\r\n\t\t\t\t\ttemp = [];\r\n\t\t\t\t\ti = matcherOut.length;\r\n\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\r\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\r\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\r\n\t\t\t\ti = matcherOut.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\r\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\r\n\r\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// Add elements to results, through postFinder if defined\r\n\t\t} else {\r\n\t\t\tmatcherOut = condense(\r\n\t\t\t\tmatcherOut === results ?\r\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\r\n\t\t\t\t\tmatcherOut\r\n\t\t\t);\r\n\t\t\tif ( postFinder ) {\r\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\r\n\t\t\t} else {\r\n\t\t\t\tpush.apply( results, matcherOut );\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction matcherFromTokens( tokens ) {\r\n\tvar checkContext, matcher, j,\r\n\t\tlen = tokens.length,\r\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\r\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\r\n\t\ti = leadingRelative ? 1 : 0,\r\n\r\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\r\n\t\tmatchContext = addCombinator( function( elem ) {\r\n\t\t\treturn elem === checkContext;\r\n\t\t}, implicitRelative, true ),\r\n\t\tmatchAnyContext = addCombinator( function( elem ) {\r\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\r\n\t\t}, implicitRelative, true ),\r\n\t\tmatchers = [ function( elem, context, xml ) {\r\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\r\n\t\t\t\t(checkContext = context).nodeType ?\r\n\t\t\t\t\tmatchContext( elem, context, xml ) :\r\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\r\n\t\t} ];\r\n\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\r\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\r\n\t\t} else {\r\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\r\n\r\n\t\t\t// Return special upon seeing a positional matcher\r\n\t\t\tif ( matcher[ expando ] ) {\r\n\t\t\t\t// Find the next relative operator (if any) for proper handling\r\n\t\t\t\tj = ++i;\r\n\t\t\t\tfor ( ; j < len; j++ ) {\r\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn setMatcher(\r\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\r\n\t\t\t\t\ti > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, \"$1\" ),\r\n\t\t\t\t\tmatcher,\r\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\r\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\r\n\t\t\t\t\tj < len && toSelector( tokens )\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tmatchers.push( matcher );\r\n\t\t}\r\n\t}\r\n\r\n\treturn elementMatcher( matchers );\r\n}\r\n\r\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\r\n\t// A counter to specify which element is currently being matched\r\n\tvar matcherCachedRuns = 0,\r\n\t\tbySet = setMatchers.length > 0,\r\n\t\tbyElement = elementMatchers.length > 0,\r\n\t\tsuperMatcher = function( seed, context, xml, results, expandContext ) {\r\n\t\t\tvar elem, j, matcher,\r\n\t\t\t\tsetMatched = [],\r\n\t\t\t\tmatchedCount = 0,\r\n\t\t\t\ti = \"0\",\r\n\t\t\t\tunmatched = seed && [],\r\n\t\t\t\toutermost = expandContext != null,\r\n\t\t\t\tcontextBackup = outermostContext,\r\n\t\t\t\t// We must always have either seed elements or context\r\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\r\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\r\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\r\n\r\n\t\t\tif ( outermost ) {\r\n\t\t\t\toutermostContext = context !== document && context;\r\n\t\t\t\tcachedruns = matcherCachedRuns;\r\n\t\t\t}\r\n\r\n\t\t\t// Add elements passing elementMatchers directly to results\r\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\r\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\r\n\t\t\t\tif ( byElement && elem ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\r\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\r\n\t\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( outermost ) {\r\n\t\t\t\t\t\tdirruns = dirrunsUnique;\r\n\t\t\t\t\t\tcachedruns = ++matcherCachedRuns;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Track unmatched elements for set filters\r\n\t\t\t\tif ( bySet ) {\r\n\t\t\t\t\t// They will have gone through all possible matchers\r\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\r\n\t\t\t\t\t\tmatchedCount--;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Lengthen the array for every element, matched or not\r\n\t\t\t\t\tif ( seed ) {\r\n\t\t\t\t\t\tunmatched.push( elem );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Apply set filters to unmatched elements\r\n\t\t\tmatchedCount += i;\r\n\t\t\tif ( bySet && i !== matchedCount ) {\r\n\t\t\t\tj = 0;\r\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\r\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( seed ) {\r\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\r\n\t\t\t\t\tif ( matchedCount > 0 ) {\r\n\t\t\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\r\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\r\n\t\t\t\t\tsetMatched = condense( setMatched );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add matches to results\r\n\t\t\t\tpush.apply( results, setMatched );\r\n\r\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\r\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\r\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\r\n\r\n\t\t\t\t\tSizzle.uniqueSort( results );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Override manipulation of globals by nested matchers\r\n\t\t\tif ( outermost ) {\r\n\t\t\t\tdirruns = dirrunsUnique;\r\n\t\t\t\toutermostContext = contextBackup;\r\n\t\t\t}\r\n\r\n\t\t\treturn unmatched;\r\n\t\t};\r\n\r\n\treturn bySet ?\r\n\t\tmarkFunction( superMatcher ) :\r\n\t\tsuperMatcher;\r\n}\r\n\r\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\r\n\tvar i,\r\n\t\tsetMatchers = [],\r\n\t\telementMatchers = [],\r\n\t\tcached = compilerCache[ selector + \" \" ];\r\n\r\n\tif ( !cached ) {\r\n\t\t// Generate a function of recursive functions that can be used to check each element\r\n\t\tif ( !group ) {\r\n\t\t\tgroup = tokenize( selector );\r\n\t\t}\r\n\t\ti = group.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tcached = matcherFromTokens( group[i] );\r\n\t\t\tif ( cached[ expando ] ) {\r\n\t\t\t\tsetMatchers.push( cached );\r\n\t\t\t} else {\r\n\t\t\t\telementMatchers.push( cached );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Cache the compiled function\r\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\r\n\t}\r\n\treturn cached;\r\n};\r\n\r\nfunction multipleContexts( selector, contexts, results ) {\r\n\tvar i = 0,\r\n\t\tlen = contexts.length;\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tSizzle( selector, contexts[i], results );\r\n\t}\r\n\treturn results;\r\n}\r\n\r\nfunction select( selector, context, results, seed ) {\r\n\tvar i, tokens, token, type, find,\r\n\t\tmatch = tokenize( selector );\r\n\r\n\tif ( !seed ) {\r\n\t\t// Try to minimize operations if there is only one group\r\n\t\tif ( match.length === 1 ) {\r\n\r\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\r\n\t\t\ttokens = match[0] = match[0].slice( 0 );\r\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\r\n\t\t\t\t\tcontext.nodeType === 9 && documentIsHTML &&\r\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\r\n\r\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\r\n\t\t\t\tif ( !context ) {\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\r\n\t\t\t}\r\n\r\n\t\t\t// Fetch a seed set for right-to-left matching\r\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\ttoken = tokens[i];\r\n\r\n\t\t\t\t// Abort if we hit a combinator\r\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\r\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\r\n\t\t\t\t\tif ( (seed = find(\r\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\r\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && context.parentNode || context\r\n\t\t\t\t\t)) ) {\r\n\r\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\r\n\t\t\t\t\t\ttokens.splice( i, 1 );\r\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\r\n\t\t\t\t\t\tif ( !selector ) {\r\n\t\t\t\t\t\t\tpush.apply( results, seed );\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Compile and execute a filtering function\r\n\t// Provide `match` to avoid retokenization if we modified the selector above\r\n\tcompile( selector, match )(\r\n\t\tseed,\r\n\t\tcontext,\r\n\t\t!documentIsHTML,\r\n\t\tresults,\r\n\t\trsibling.test( selector )\r\n\t);\r\n\treturn results;\r\n}\r\n\r\n// Deprecated\r\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\r\n\r\n// Easy API for creating new setFilters\r\nfunction setFilters() {}\r\nsetFilters.prototype = Expr.filters = Expr.pseudos;\r\nExpr.setFilters = new setFilters();\r\n\r\n// One-time assignments\r\n\r\n// Sort stability\r\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\r\n\r\n// Initialize against the default document\r\nsetDocument();\r\n\r\n// Support: Chrome<<14\r\n// Always assume duplicates if they aren't passed to the comparison function\r\n[0, 0].sort( sortOrder );\r\nsupport.detectDuplicates = hasDuplicate;\r\n\r\n// Support: IE<8\r\n// Prevent attribute/property \"interpolation\"\r\nassert(function( div ) {\r\n\tdiv.innerHTML = \"<a href='#'></a>\";\r\n\tif ( div.firstChild.getAttribute(\"href\") !== \"#\" ) {\r\n\t\tvar attrs = \"type|href|height|width\".split(\"|\"),\r\n\t\t\ti = attrs.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tExpr.attrHandle[ attrs[i] ] = interpolationHandler;\r\n\t\t}\r\n\t}\r\n});\r\n\r\n// Support: IE<9\r\n// Use getAttributeNode to fetch booleans when getAttribute lies\r\nassert(function( div ) {\r\n\tif ( div.getAttribute(\"disabled\") != null ) {\r\n\t\tvar attrs = booleans.split(\"|\"),\r\n\t\t\ti = attrs.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tExpr.attrHandle[ attrs[i] ] = boolHandler;\r\n\t\t}\r\n\t}\r\n});\r\n\r\njQuery.find = Sizzle;\r\njQuery.expr = Sizzle.selectors;\r\njQuery.expr[\":\"] = jQuery.expr.pseudos;\r\njQuery.unique = Sizzle.uniqueSort;\r\njQuery.text = Sizzle.getText;\r\njQuery.isXMLDoc = Sizzle.isXML;\r\njQuery.contains = Sizzle.contains;\r\n\r\n\r\n})( window );\r\n// String to Object options format cache\r\nvar optionsCache = {};\r\n\r\n// Convert String-formatted options into Object-formatted ones and store in cache\r\nfunction createOptions( options ) {\r\n\tvar object = optionsCache[ options ] = {};\r\n\tjQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\r\n\t\tobject[ flag ] = true;\r\n\t});\r\n\treturn object;\r\n}\r\n\r\n/*\r\n * Create a callback list using the following parameters:\r\n *\r\n *\toptions: an optional list of space-separated options that will change how\r\n *\t\t\tthe callback list behaves or a more traditional option object\r\n *\r\n * By default a callback list will act like an event callback list and can be\r\n * \"fired\" multiple times.\r\n *\r\n * Possible options:\r\n *\r\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\r\n *\r\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\r\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\r\n *\t\t\t\t\tvalues (like a Deferred)\r\n *\r\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\r\n *\r\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\r\n *\r\n */\r\njQuery.Callbacks = function( options ) {\r\n\r\n\t// Convert options from String-formatted to Object-formatted if needed\r\n\t// (we check in cache first)\r\n\toptions = typeof options === \"string\" ?\r\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\r\n\t\tjQuery.extend( {}, options );\r\n\r\n\tvar // Last fire value (for non-forgettable lists)\r\n\t\tmemory,\r\n\t\t// Flag to know if list was already fired\r\n\t\tfired,\r\n\t\t// Flag to know if list is currently firing\r\n\t\tfiring,\r\n\t\t// First callback to fire (used internally by add and fireWith)\r\n\t\tfiringStart,\r\n\t\t// End of the loop when firing\r\n\t\tfiringLength,\r\n\t\t// Index of currently firing callback (modified by remove if needed)\r\n\t\tfiringIndex,\r\n\t\t// Actual callback list\r\n\t\tlist = [],\r\n\t\t// Stack of fire calls for repeatable lists\r\n\t\tstack = !options.once && [],\r\n\t\t// Fire callbacks\r\n\t\tfire = function( data ) {\r\n\t\t\tmemory = options.memory && data;\r\n\t\t\tfired = true;\r\n\t\t\tfiringIndex = firingStart || 0;\r\n\t\t\tfiringStart = 0;\r\n\t\t\tfiringLength = list.length;\r\n\t\t\tfiring = true;\r\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\r\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\r\n\t\t\t\t\tmemory = false; // To prevent further calls using add\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfiring = false;\r\n\t\t\tif ( list ) {\r\n\t\t\t\tif ( stack ) {\r\n\t\t\t\t\tif ( stack.length ) {\r\n\t\t\t\t\t\tfire( stack.shift() );\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ( memory ) {\r\n\t\t\t\t\tlist = [];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tself.disable();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t// Actual Callbacks object\r\n\t\tself = {\r\n\t\t\t// Add a callback or a collection of callbacks to the list\r\n\t\t\tadd: function() {\r\n\t\t\t\tif ( list ) {\r\n\t\t\t\t\t// First, we save the current length\r\n\t\t\t\t\tvar start = list.length;\r\n\t\t\t\t\t(function add( args ) {\r\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\r\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\r\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\r\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\r\n\t\t\t\t\t\t\t\t\tlist.push( arg );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\r\n\t\t\t\t\t\t\t\t// Inspect recursively\r\n\t\t\t\t\t\t\t\tadd( arg );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t})( arguments );\r\n\t\t\t\t\t// Do we need to add the callbacks to the\r\n\t\t\t\t\t// current firing batch?\r\n\t\t\t\t\tif ( firing ) {\r\n\t\t\t\t\t\tfiringLength = list.length;\r\n\t\t\t\t\t// With memory, if we're not firing then\r\n\t\t\t\t\t// we should call right away\r\n\t\t\t\t\t} else if ( memory ) {\r\n\t\t\t\t\t\tfiringStart = start;\r\n\t\t\t\t\t\tfire( memory );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Remove a callback from the list\r\n\t\t\tremove: function() {\r\n\t\t\t\tif ( list ) {\r\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\r\n\t\t\t\t\t\tvar index;\r\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\r\n\t\t\t\t\t\t\tlist.splice( index, 1 );\r\n\t\t\t\t\t\t\t// Handle firing indexes\r\n\t\t\t\t\t\t\tif ( firing ) {\r\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\r\n\t\t\t\t\t\t\t\t\tfiringLength--;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\r\n\t\t\t\t\t\t\t\t\tfiringIndex--;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Check if a given callback is in the list.\r\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\r\n\t\t\thas: function( fn ) {\r\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\r\n\t\t\t},\r\n\t\t\t// Remove all callbacks from the list\r\n\t\t\tempty: function() {\r\n\t\t\t\tlist = [];\r\n\t\t\t\tfiringLength = 0;\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Have the list do nothing anymore\r\n\t\t\tdisable: function() {\r\n\t\t\t\tlist = stack = memory = undefined;\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Is it disabled?\r\n\t\t\tdisabled: function() {\r\n\t\t\t\treturn !list;\r\n\t\t\t},\r\n\t\t\t// Lock the list in its current state\r\n\t\t\tlock: function() {\r\n\t\t\t\tstack = undefined;\r\n\t\t\t\tif ( !memory ) {\r\n\t\t\t\t\tself.disable();\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Is it locked?\r\n\t\t\tlocked: function() {\r\n\t\t\t\treturn !stack;\r\n\t\t\t},\r\n\t\t\t// Call all callbacks with the given context and arguments\r\n\t\t\tfireWith: function( context, args ) {\r\n\t\t\t\targs = args || [];\r\n\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\r\n\t\t\t\tif ( list && ( !fired || stack ) ) {\r\n\t\t\t\t\tif ( firing ) {\r\n\t\t\t\t\t\tstack.push( args );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfire( args );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// Call all the callbacks with the given arguments\r\n\t\t\tfire: function() {\r\n\t\t\t\tself.fireWith( this, arguments );\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\t// To know if the callbacks have already been called at least once\r\n\t\t\tfired: function() {\r\n\t\t\t\treturn !!fired;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\treturn self;\r\n};\r\njQuery.extend({\r\n\r\n\tDeferred: function( func ) {\r\n\t\tvar tuples = [\r\n\t\t\t\t// action, add listener, listener list, final state\r\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\r\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\r\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\r\n\t\t\t],\r\n\t\t\tstate = \"pending\",\r\n\t\t\tpromise = {\r\n\t\t\t\tstate: function() {\r\n\t\t\t\t\treturn state;\r\n\t\t\t\t},\r\n\t\t\t\talways: function() {\r\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\r\n\t\t\t\t\tvar fns = arguments;\r\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\r\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\r\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\r\n\t\t\t\t\t\t\t\tfn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\r\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\r\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\r\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\r\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\r\n\t\t\t\t\t\t\t\t\treturned.promise()\r\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\r\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\r\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tfns = null;\r\n\t\t\t\t\t}).promise();\r\n\t\t\t\t},\r\n\t\t\t\t// Get a promise for this deferred\r\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\r\n\t\t\t\tpromise: function( obj ) {\r\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdeferred = {};\r\n\r\n\t\t// Keep pipe for back-compat\r\n\t\tpromise.pipe = promise.then;\r\n\r\n\t\t// Add list-specific methods\r\n\t\tjQuery.each( tuples, function( i, tuple ) {\r\n\t\t\tvar list = tuple[ 2 ],\r\n\t\t\t\tstateString = tuple[ 3 ];\r\n\r\n\t\t\t// promise[ done | fail | progress ] = list.add\r\n\t\t\tpromise[ tuple[1] ] = list.add;\r\n\r\n\t\t\t// Handle state\r\n\t\t\tif ( stateString ) {\r\n\t\t\t\tlist.add(function() {\r\n\t\t\t\t\t// state = [ resolved | rejected ]\r\n\t\t\t\t\tstate = stateString;\r\n\r\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\r\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\r\n\t\t\t}\r\n\r\n\t\t\t// deferred[ resolve | reject | notify ]\r\n\t\t\tdeferred[ tuple[0] ] = function() {\r\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\r\n\t\t});\r\n\r\n\t\t// Make the deferred a promise\r\n\t\tpromise.promise( deferred );\r\n\r\n\t\t// Call given func if any\r\n\t\tif ( func ) {\r\n\t\t\tfunc.call( deferred, deferred );\r\n\t\t}\r\n\r\n\t\t// All done!\r\n\t\treturn deferred;\r\n\t},\r\n\r\n\t// Deferred helper\r\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\r\n\t\tvar i = 0,\r\n\t\t\tresolveValues = core_slice.call( arguments ),\r\n\t\t\tlength = resolveValues.length,\r\n\r\n\t\t\t// the count of uncompleted subordinates\r\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\r\n\r\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\r\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\r\n\r\n\t\t\t// Update function for both resolve and progress values\r\n\t\t\tupdateFunc = function( i, contexts, values ) {\r\n\t\t\t\treturn function( value ) {\r\n\t\t\t\t\tcontexts[ i ] = this;\r\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\r\n\t\t\t\t\tif( values === progressValues ) {\r\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\r\n\t\t\t\t\t} else if ( !( --remaining ) ) {\r\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t},\r\n\r\n\t\t\tprogressValues, progressContexts, resolveContexts;\r\n\r\n\t\t// add listeners to Deferred subordinates; treat others as resolved\r\n\t\tif ( length > 1 ) {\r\n\t\t\tprogressValues = new Array( length );\r\n\t\t\tprogressContexts = new Array( length );\r\n\t\t\tresolveContexts = new Array( length );\r\n\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\r\n\t\t\t\t\tresolveValues[ i ].promise()\r\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\r\n\t\t\t\t\t\t.fail( deferred.reject )\r\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\t--remaining;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if we're not waiting on anything, resolve the master\r\n\t\tif ( !remaining ) {\r\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\r\n\t\t}\r\n\r\n\t\treturn deferred.promise();\r\n\t}\r\n});\r\njQuery.support = (function( support ) {\r\n\tvar input = document.createElement(\"input\"),\r\n\t\tfragment = document.createDocumentFragment(),\r\n\t\tdiv = document.createElement(\"div\"),\r\n\t\tselect = document.createElement(\"select\"),\r\n\t\topt = select.appendChild( document.createElement(\"option\") );\r\n\r\n\t// Finish early in limited environments\r\n\tif ( !input.type ) {\r\n\t\treturn support;\r\n\t}\r\n\r\n\tinput.type = \"checkbox\";\r\n\r\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\r\n\t// Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\r\n\tsupport.checkOn = input.value !== \"\";\r\n\r\n\t// Must access the parent to make an option select properly\r\n\t// Support: IE9, IE10\r\n\tsupport.optSelected = opt.selected;\r\n\r\n\t// Will be defined later\r\n\tsupport.reliableMarginRight = true;\r\n\tsupport.boxSizingReliable = true;\r\n\tsupport.pixelPosition = false;\r\n\r\n\t// Make sure checked status is properly cloned\r\n\t// Support: IE9, IE10\r\n\tinput.checked = true;\r\n\tsupport.noCloneChecked = input.cloneNode( true ).checked;\r\n\r\n\t// Make sure that the options inside disabled selects aren't marked as disabled\r\n\t// (WebKit marks them as disabled)\r\n\tselect.disabled = true;\r\n\tsupport.optDisabled = !opt.disabled;\r\n\r\n\t// Check if an input maintains its value after becoming a radio\r\n\t// Support: IE9, IE10\r\n\tinput = document.createElement(\"input\");\r\n\tinput.value = \"t\";\r\n\tinput.type = \"radio\";\r\n\tsupport.radioValue = input.value === \"t\";\r\n\r\n\t// #11217 - WebKit loses check when the name is after the checked attribute\r\n\tinput.setAttribute( \"checked\", \"t\" );\r\n\tinput.setAttribute( \"name\", \"t\" );\r\n\r\n\tfragment.appendChild( input );\r\n\r\n\t// Support: Safari 5.1, Android 4.x, Android 2.3\r\n\t// old WebKit doesn't clone checked state correctly in fragments\r\n\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\r\n\r\n\t// Support: Firefox, Chrome, Safari\r\n\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\r\n\tsupport.focusinBubbles = \"onfocusin\" in window;\r\n\r\n\tdiv.style.backgroundClip = \"content-box\";\r\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\r\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\r\n\r\n\t// Run tests that need a body at doc ready\r\n\tjQuery(function() {\r\n\t\tvar container, marginDiv,\r\n\t\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\r\n\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box\",\r\n\t\t\tbody = document.getElementsByTagName(\"body\")[ 0 ];\r\n\r\n\t\tif ( !body ) {\r\n\t\t\t// Return for frameset docs that don't have a body\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcontainer = document.createElement(\"div\");\r\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\r\n\r\n\t\t// Check box-sizing and margin behavior.\r\n\t\tbody.appendChild( container ).appendChild( div );\r\n\t\tdiv.innerHTML = \"\";\r\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\r\n\t\tdiv.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%\";\r\n\r\n\t\t// Workaround failing boxSizing test due to offsetWidth returning wrong value\r\n\t\t// with some non-1 values of body zoom, ticket #13543\r\n\t\tjQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {\r\n\t\t\tsupport.boxSizing = div.offsetWidth === 4;\r\n\t\t});\r\n\r\n\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\r\n\t\tif ( window.getComputedStyle ) {\r\n\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\r\n\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\r\n\r\n\t\t\t// Support: Android 2.3\r\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\r\n\t\t\t// gets computed margin-right based on width of container. (#3333)\r\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\r\n\t\t\tmarginDiv = div.appendChild( document.createElement(\"div\") );\r\n\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\r\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\r\n\t\t\tdiv.style.width = \"1px\";\r\n\r\n\t\t\tsupport.reliableMarginRight =\r\n\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\r\n\t\t}\r\n\r\n\t\tbody.removeChild( container );\r\n\t});\r\n\r\n\treturn support;\r\n})( {} );\r\n\r\n/*\r\n\tImplementation Summary\r\n\r\n\t1. Enforce API surface and semantic compatibility with 1.9.x branch\r\n\t2. Improve the module's maintainability by reducing the storage\r\n\t\tpaths to a single mechanism.\r\n\t3. Use the same single mechanism to support \"private\" and \"user\" data.\r\n\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\r\n\t5. Avoid exposing implementation details on user objects (eg. expando properties)\r\n\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\r\n*/\r\nvar data_user, data_priv,\r\n\trbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\r\n\trmultiDash = /([A-Z])/g;\r\n\r\nfunction Data() {\r\n\t// Support: Android < 4,\r\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\r\n\t// return new empty object instead with no [[set]] accessor\r\n\tObject.defineProperty( this.cache = {}, 0, {\r\n\t\tget: function() {\r\n\t\t\treturn {};\r\n\t\t}\r\n\t});\r\n\r\n\tthis.expando = jQuery.expando + Math.random();\r\n}\r\n\r\nData.uid = 1;\r\n\r\nData.accepts = function( owner ) {\r\n\t// Accepts only:\r\n\t//  - Node\r\n\t//    - Node.ELEMENT_NODE\r\n\t//    - Node.DOCUMENT_NODE\r\n\t//  - Object\r\n\t//    - Any\r\n\treturn owner.nodeType ?\r\n\t\towner.nodeType === 1 || owner.nodeType === 9 : true;\r\n};\r\n\r\nData.prototype = {\r\n\tkey: function( owner ) {\r\n\t\t// We can accept data for non-element nodes in modern browsers,\r\n\t\t// but we should not, see #8335.\r\n\t\t// Always return the key for a frozen object.\r\n\t\tif ( !Data.accepts( owner ) ) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tvar descriptor = {},\r\n\t\t\t// Check if the owner object already has a cache key\r\n\t\t\tunlock = owner[ this.expando ];\r\n\r\n\t\t// If not, create one\r\n\t\tif ( !unlock ) {\r\n\t\t\tunlock = Data.uid++;\r\n\r\n\t\t\t// Secure it in a non-enumerable, non-writable property\r\n\t\t\ttry {\r\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\r\n\t\t\t\tObject.defineProperties( owner, descriptor );\r\n\r\n\t\t\t// Support: Android < 4\r\n\t\t\t// Fallback to a less secure definition\r\n\t\t\t} catch ( e ) {\r\n\t\t\t\tdescriptor[ this.expando ] = unlock;\r\n\t\t\t\tjQuery.extend( owner, descriptor );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Ensure the cache object\r\n\t\tif ( !this.cache[ unlock ] ) {\r\n\t\t\tthis.cache[ unlock ] = {};\r\n\t\t}\r\n\r\n\t\treturn unlock;\r\n\t},\r\n\tset: function( owner, data, value ) {\r\n\t\tvar prop,\r\n\t\t\t// There may be an unlock assigned to this node,\r\n\t\t\t// if there is no entry for this \"owner\", create one inline\r\n\t\t\t// and set the unlock as though an owner entry had always existed\r\n\t\t\tunlock = this.key( owner ),\r\n\t\t\tcache = this.cache[ unlock ];\r\n\r\n\t\t// Handle: [ owner, key, value ] args\r\n\t\tif ( typeof data === \"string\" ) {\r\n\t\t\tcache[ data ] = value;\r\n\r\n\t\t// Handle: [ owner, { properties } ] args\r\n\t\t} else {\r\n\t\t\t// Support an expectation from the old data system where plain\r\n\t\t\t// objects used to initialize would be set to the cache by\r\n\t\t\t// reference, instead of having properties and values copied.\r\n\t\t\t// Note, this will kill the connection between\r\n\t\t\t// \"this.cache[ unlock ]\" and \"cache\"\r\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\r\n\t\t\t\tthis.cache[ unlock ] = data;\r\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\r\n\t\t\t} else {\r\n\t\t\t\tfor ( prop in data ) {\r\n\t\t\t\t\tcache[ prop ] = data[ prop ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tget: function( owner, key ) {\r\n\t\t// Either a valid cache is found, or will be created.\r\n\t\t// New caches will be created and the unlock returned,\r\n\t\t// allowing direct access to the newly created\r\n\t\t// empty data object. A valid owner object must be provided.\r\n\t\tvar cache = this.cache[ this.key( owner ) ];\r\n\r\n\t\treturn key === undefined ?\r\n\t\t\tcache : cache[ key ];\r\n\t},\r\n\taccess: function( owner, key, value ) {\r\n\t\t// In cases where either:\r\n\t\t//\r\n\t\t//   1. No key was specified\r\n\t\t//   2. A string key was specified, but no value provided\r\n\t\t//\r\n\t\t// Take the \"read\" path and allow the get method to determine\r\n\t\t// which value to return, respectively either:\r\n\t\t//\r\n\t\t//   1. The entire cache object\r\n\t\t//   2. The data stored at the key\r\n\t\t//\r\n\t\tif ( key === undefined ||\r\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\r\n\t\t\treturn this.get( owner, key );\r\n\t\t}\r\n\r\n\t\t// [*]When the key is not a string, or both a key and value\r\n\t\t// are specified, set or extend (existing objects) with either:\r\n\t\t//\r\n\t\t//   1. An object of properties\r\n\t\t//   2. A key and value\r\n\t\t//\r\n\t\tthis.set( owner, key, value );\r\n\r\n\t\t// Since the \"set\" path can have two possible entry points\r\n\t\t// return the expected data based on which path was taken[*]\r\n\t\treturn value !== undefined ? value : key;\r\n\t},\r\n\tremove: function( owner, key ) {\r\n\t\tvar i, name,\r\n\t\t\tunlock = this.key( owner ),\r\n\t\t\tcache = this.cache[ unlock ];\r\n\r\n\t\tif ( key === undefined ) {\r\n\t\t\tthis.cache[ unlock ] = {};\r\n\r\n\t\t} else {\r\n\t\t\t// Support array or space separated string of keys\r\n\t\t\tif ( jQuery.isArray( key ) ) {\r\n\t\t\t\t// If \"name\" is an array of keys...\r\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\r\n\t\t\t\t// keys will be converted to camelCase.\r\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\r\n\t\t\t\t// both plain key and camelCase key. #12786\r\n\t\t\t\t// This will only penalize the array argument path.\r\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\r\n\t\t\t} else {\r\n\t\t\t\t// Try the string as a key before any manipulation\r\n\t\t\t\tif ( key in cache ) {\r\n\t\t\t\t\tname = [ key ];\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If a key with the spaces exists, use it.\r\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\r\n\t\t\t\t\tname = jQuery.camelCase( key );\r\n\t\t\t\t\tname = name in cache ?\r\n\t\t\t\t\t\t[ name ] : ( name.match( core_rnotwhite ) || [] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ti = name.length;\r\n\t\t\twhile ( i-- ) {\r\n\t\t\t\tdelete cache[ name[ i ] ];\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\thasData: function( owner ) {\r\n\t\treturn !jQuery.isEmptyObject(\r\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\r\n\t\t);\r\n\t},\r\n\tdiscard: function( owner ) {\r\n\t\tdelete this.cache[ this.key( owner ) ];\r\n\t}\r\n};\r\n\r\n// These may be used throughout the jQuery core codebase\r\ndata_user = new Data();\r\ndata_priv = new Data();\r\n\r\n\r\njQuery.extend({\r\n\tacceptData: Data.accepts,\r\n\r\n\thasData: function( elem ) {\r\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\r\n\t},\r\n\r\n\tdata: function( elem, name, data ) {\r\n\t\treturn data_user.access( elem, name, data );\r\n\t},\r\n\r\n\tremoveData: function( elem, name ) {\r\n\t\tdata_user.remove( elem, name );\r\n\t},\r\n\r\n\t// TODO: Now that all calls to _data and _removeData have been replaced\r\n\t// with direct calls to data_priv methods, these can be deprecated.\r\n\t_data: function( elem, name, data ) {\r\n\t\treturn data_priv.access( elem, name, data );\r\n\t},\r\n\r\n\t_removeData: function( elem, name ) {\r\n\t\tdata_priv.remove( elem, name );\r\n\t}\r\n});\r\n\r\njQuery.fn.extend({\r\n\tdata: function( key, value ) {\r\n\t\tvar attrs, name,\r\n\t\t\telem = this[ 0 ],\r\n\t\t\ti = 0,\r\n\t\t\tdata = null;\r\n\r\n\t\t// Gets all values\r\n\t\tif ( key === undefined ) {\r\n\t\t\tif ( this.length ) {\r\n\t\t\t\tdata = data_user.get( elem );\r\n\r\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\r\n\t\t\t\t\tattrs = elem.attributes;\r\n\t\t\t\t\tfor ( ; i < attrs.length; i++ ) {\r\n\t\t\t\t\t\tname = attrs[ i ].name;\r\n\r\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\r\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.substring(5) );\r\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\t// Sets multiple values\r\n\t\tif ( typeof key === \"object\" ) {\r\n\t\t\treturn this.each(function() {\r\n\t\t\t\tdata_user.set( this, key );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn jQuery.access( this, function( value ) {\r\n\t\t\tvar data,\r\n\t\t\t\tcamelKey = jQuery.camelCase( key );\r\n\r\n\t\t\t// The calling jQuery object (element matches) is not empty\r\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\r\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\r\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\r\n\t\t\t// throw an exception if an attempt to read a data cache is made.\r\n\t\t\tif ( elem && value === undefined ) {\r\n\t\t\t\t// Attempt to get data from the cache\r\n\t\t\t\t// with the key as-is\r\n\t\t\t\tdata = data_user.get( elem, key );\r\n\t\t\t\tif ( data !== undefined ) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Attempt to get data from the cache\r\n\t\t\t\t// with the key camelized\r\n\t\t\t\tdata = data_user.get( elem, camelKey );\r\n\t\t\t\tif ( data !== undefined ) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Attempt to \"discover\" the data in\r\n\t\t\t\t// HTML5 custom data-* attrs\r\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\r\n\t\t\t\tif ( data !== undefined ) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We tried really hard, but the data doesn't exist.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Set the data...\r\n\t\t\tthis.each(function() {\r\n\t\t\t\t// First, attempt to store a copy or reference of any\r\n\t\t\t\t// data that might've been store with a camelCased key.\r\n\t\t\t\tvar data = data_user.get( this, camelKey );\r\n\r\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\r\n\t\t\t\t// store property names with dashes in a camelCase form.\r\n\t\t\t\t// This might not apply to all properties...*\r\n\t\t\t\tdata_user.set( this, camelKey, value );\r\n\r\n\t\t\t\t// *... In the case of properties that might _actually_\r\n\t\t\t\t// have dashes, we need to also store a copy of that\r\n\t\t\t\t// unchanged property.\r\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\r\n\t\t\t\t\tdata_user.set( this, key, value );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}, null, value, arguments.length > 1, null, true );\r\n\t},\r\n\r\n\tremoveData: function( key ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tdata_user.remove( this, key );\r\n\t\t});\r\n\t}\r\n});\r\n\r\nfunction dataAttr( elem, key, data ) {\r\n\tvar name;\r\n\r\n\t// If nothing was found internally, try to fetch any\r\n\t// data from the HTML5 data-* attribute\r\n\tif ( data === undefined && elem.nodeType === 1 ) {\r\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\r\n\t\tdata = elem.getAttribute( name );\r\n\r\n\t\tif ( typeof data === \"string\" ) {\r\n\t\t\ttry {\r\n\t\t\t\tdata = data === \"true\" ? true :\r\n\t\t\t\t\tdata === \"false\" ? false :\r\n\t\t\t\t\tdata === \"null\" ? null :\r\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\r\n\t\t\t\t\t+data + \"\" === data ? +data :\r\n\t\t\t\t\trbrace.test( data ) ? JSON.parse( data ) :\r\n\t\t\t\t\tdata;\r\n\t\t\t} catch( e ) {}\r\n\r\n\t\t\t// Make sure we set the data so it isn't changed later\r\n\t\t\tdata_user.set( elem, key, data );\r\n\t\t} else {\r\n\t\t\tdata = undefined;\r\n\t\t}\r\n\t}\r\n\treturn data;\r\n}\r\njQuery.extend({\r\n\tqueue: function( elem, type, data ) {\r\n\t\tvar queue;\r\n\r\n\t\tif ( elem ) {\r\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\r\n\t\t\tqueue = data_priv.get( elem, type );\r\n\r\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\r\n\t\t\tif ( data ) {\r\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\r\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tqueue.push( data );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn queue || [];\r\n\t\t}\r\n\t},\r\n\r\n\tdequeue: function( elem, type ) {\r\n\t\ttype = type || \"fx\";\r\n\r\n\t\tvar queue = jQuery.queue( elem, type ),\r\n\t\t\tstartLength = queue.length,\r\n\t\t\tfn = queue.shift(),\r\n\t\t\thooks = jQuery._queueHooks( elem, type ),\r\n\t\t\tnext = function() {\r\n\t\t\t\tjQuery.dequeue( elem, type );\r\n\t\t\t};\r\n\r\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\r\n\t\tif ( fn === \"inprogress\" ) {\r\n\t\t\tfn = queue.shift();\r\n\t\t\tstartLength--;\r\n\t\t}\r\n\r\n\t\thooks.cur = fn;\r\n\t\tif ( fn ) {\r\n\r\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\r\n\t\t\t// automatically dequeued\r\n\t\t\tif ( type === \"fx\" ) {\r\n\t\t\t\tqueue.unshift( \"inprogress\" );\r\n\t\t\t}\r\n\r\n\t\t\t// clear up the last queue stop function\r\n\t\t\tdelete hooks.stop;\r\n\t\t\tfn.call( elem, next, hooks );\r\n\t\t}\r\n\r\n\t\tif ( !startLength && hooks ) {\r\n\t\t\thooks.empty.fire();\r\n\t\t}\r\n\t},\r\n\r\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\r\n\t_queueHooks: function( elem, type ) {\r\n\t\tvar key = type + \"queueHooks\";\r\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\r\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\r\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\r\n\t\t\t})\r\n\t\t});\r\n\t}\r\n});\r\n\r\njQuery.fn.extend({\r\n\tqueue: function( type, data ) {\r\n\t\tvar setter = 2;\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tdata = type;\r\n\t\t\ttype = \"fx\";\r\n\t\t\tsetter--;\r\n\t\t}\r\n\r\n\t\tif ( arguments.length < setter ) {\r\n\t\t\treturn jQuery.queue( this[0], type );\r\n\t\t}\r\n\r\n\t\treturn data === undefined ?\r\n\t\t\tthis :\r\n\t\t\tthis.each(function() {\r\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\r\n\r\n\t\t\t\t// ensure a hooks for this queue\r\n\t\t\t\tjQuery._queueHooks( this, type );\r\n\r\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\r\n\t\t\t\t\tjQuery.dequeue( this, type );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t},\r\n\tdequeue: function( type ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tjQuery.dequeue( this, type );\r\n\t\t});\r\n\t},\r\n\t// Based off of the plugin by Clint Helfers, with permission.\r\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\r\n\tdelay: function( time, type ) {\r\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\r\n\t\ttype = type || \"fx\";\r\n\r\n\t\treturn this.queue( type, function( next, hooks ) {\r\n\t\t\tvar timeout = setTimeout( next, time );\r\n\t\t\thooks.stop = function() {\r\n\t\t\t\tclearTimeout( timeout );\r\n\t\t\t};\r\n\t\t});\r\n\t},\r\n\tclearQueue: function( type ) {\r\n\t\treturn this.queue( type || \"fx\", [] );\r\n\t},\r\n\t// Get a promise resolved when queues of a certain type\r\n\t// are emptied (fx is the type by default)\r\n\tpromise: function( type, obj ) {\r\n\t\tvar tmp,\r\n\t\t\tcount = 1,\r\n\t\t\tdefer = jQuery.Deferred(),\r\n\t\t\telements = this,\r\n\t\t\ti = this.length,\r\n\t\t\tresolve = function() {\r\n\t\t\t\tif ( !( --count ) ) {\r\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tobj = type;\r\n\t\t\ttype = undefined;\r\n\t\t}\r\n\t\ttype = type || \"fx\";\r\n\r\n\t\twhile( i-- ) {\r\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\r\n\t\t\tif ( tmp && tmp.empty ) {\r\n\t\t\t\tcount++;\r\n\t\t\t\ttmp.empty.add( resolve );\r\n\t\t\t}\r\n\t\t}\r\n\t\tresolve();\r\n\t\treturn defer.promise( obj );\r\n\t}\r\n});\r\nvar nodeHook, boolHook,\r\n\trclass = /[\\t\\r\\n]/g,\r\n\trreturn = /\\r/g,\r\n\trfocusable = /^(?:input|select|textarea|button)$/i;\r\n\r\njQuery.fn.extend({\r\n\tattr: function( name, value ) {\r\n\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\r\n\t},\r\n\r\n\tremoveAttr: function( name ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tjQuery.removeAttr( this, name );\r\n\t\t});\r\n\t},\r\n\r\n\tprop: function( name, value ) {\r\n\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\r\n\t},\r\n\r\n\tremoveProp: function( name ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\r\n\t\t});\r\n\t},\r\n\r\n\taddClass: function( value ) {\r\n\t\tvar classes, elem, cur, clazz, j,\r\n\t\t\ti = 0,\r\n\t\t\tlen = this.length,\r\n\t\t\tproceed = typeof value === \"string\" && value;\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each(function( j ) {\r\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( proceed ) {\r\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\r\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\r\n\r\n\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\telem = this[ i ];\r\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\r\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\r\n\t\t\t\t\t\" \"\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif ( cur ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\r\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\r\n\t\t\t\t\t\t\tcur += clazz + \" \";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telem.className = jQuery.trim( cur );\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveClass: function( value ) {\r\n\t\tvar classes, elem, cur, clazz, j,\r\n\t\t\ti = 0,\r\n\t\t\tlen = this.length,\r\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each(function( j ) {\r\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\r\n\t\t\t});\r\n\t\t}\r\n\t\tif ( proceed ) {\r\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\r\n\r\n\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\telem = this[ i ];\r\n\t\t\t\t// This expression is here for better compressibility (see addClass)\r\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\r\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\r\n\t\t\t\t\t\"\"\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif ( cur ) {\r\n\t\t\t\t\tj = 0;\r\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\r\n\t\t\t\t\t\t// Remove *all* instances\r\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\r\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telem.className = value ? jQuery.trim( cur ) : \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttoggleClass: function( value, stateVal ) {\r\n\t\tvar type = typeof value,\r\n\t\t\tisBool = typeof stateVal === \"boolean\";\r\n\r\n\t\tif ( jQuery.isFunction( value ) ) {\r\n\t\t\treturn this.each(function( i ) {\r\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\tif ( type === \"string\" ) {\r\n\t\t\t\t// toggle individual class names\r\n\t\t\t\tvar className,\r\n\t\t\t\t\ti = 0,\r\n\t\t\t\t\tself = jQuery( this ),\r\n\t\t\t\t\tstate = stateVal,\r\n\t\t\t\t\tclassNames = value.match( core_rnotwhite ) || [];\r\n\r\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\r\n\t\t\t\t\t// check each className given, space separated list\r\n\t\t\t\t\tstate = isBool ? state : !self.hasClass( className );\r\n\t\t\t\t\tself[ state ? \"addClass\" : \"removeClass\" ]( className );\r\n\t\t\t\t}\r\n\r\n\t\t\t// Toggle whole class name\r\n\t\t\t} else if ( type === core_strundefined || type === \"boolean\" ) {\r\n\t\t\t\tif ( this.className ) {\r\n\t\t\t\t\t// store className if set\r\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\r\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\r\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\r\n\t\t\t\t// falling back to the empty string if nothing was stored.\r\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\thasClass: function( selector ) {\r\n\t\tvar className = \" \" + selector + \" \",\r\n\t\t\ti = 0,\r\n\t\t\tl = this.length;\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tval: function( value ) {\r\n\t\tvar hooks, ret, isFunction,\r\n\t\t\telem = this[0];\r\n\r\n\t\tif ( !arguments.length ) {\r\n\t\t\tif ( elem ) {\r\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\r\n\r\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tret = elem.value;\r\n\r\n\t\t\t\treturn typeof ret === \"string\" ?\r\n\t\t\t\t\t// handle most common string cases\r\n\t\t\t\t\tret.replace(rreturn, \"\") :\r\n\t\t\t\t\t// handle cases where value is null/undef or number\r\n\t\t\t\t\tret == null ? \"\" : ret;\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tisFunction = jQuery.isFunction( value );\r\n\r\n\t\treturn this.each(function( i ) {\r\n\t\t\tvar val,\r\n\t\t\t\tself = jQuery(this);\r\n\r\n\t\t\tif ( this.nodeType !== 1 ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ( isFunction ) {\r\n\t\t\t\tval = value.call( this, i, self.val() );\r\n\t\t\t} else {\r\n\t\t\t\tval = value;\r\n\t\t\t}\r\n\r\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\r\n\t\t\tif ( val == null ) {\r\n\t\t\t\tval = \"\";\r\n\t\t\t} else if ( typeof val === \"number\" ) {\r\n\t\t\t\tval += \"\";\r\n\t\t\t} else if ( jQuery.isArray( val ) ) {\r\n\t\t\t\tval = jQuery.map(val, function ( value ) {\r\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\r\n\r\n\t\t\t// If set returns undefined, fall back to normal setting\r\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\r\n\t\t\t\tthis.value = val;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n});\r\n\r\njQuery.extend({\r\n\tvalHooks: {\r\n\t\toption: {\r\n\t\t\tget: function( elem ) {\r\n\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\r\n\t\t\t\t// uses .value. See #6932\r\n\t\t\t\tvar val = elem.attributes.value;\r\n\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\r\n\t\t\t}\r\n\t\t},\r\n\t\tselect: {\r\n\t\t\tget: function( elem ) {\r\n\t\t\t\tvar value, option,\r\n\t\t\t\t\toptions = elem.options,\r\n\t\t\t\t\tindex = elem.selectedIndex,\r\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\r\n\t\t\t\t\tvalues = one ? null : [],\r\n\t\t\t\t\tmax = one ? index + 1 : options.length,\r\n\t\t\t\t\ti = index < 0 ?\r\n\t\t\t\t\t\tmax :\r\n\t\t\t\t\t\tone ? index : 0;\r\n\r\n\t\t\t\t// Loop through all the selected options\r\n\t\t\t\tfor ( ; i < max; i++ ) {\r\n\t\t\t\t\toption = options[ i ];\r\n\r\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\r\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\r\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\r\n\t\t\t\t\t\t\t( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\r\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\r\n\r\n\t\t\t\t\t\t// Get the specific value for the option\r\n\t\t\t\t\t\tvalue = jQuery( option ).val();\r\n\r\n\t\t\t\t\t\t// We don't need an array for one selects\r\n\t\t\t\t\t\tif ( one ) {\r\n\t\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Multi-Selects return an array\r\n\t\t\t\t\t\tvalues.push( value );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn values;\r\n\t\t\t},\r\n\r\n\t\t\tset: function( elem, value ) {\r\n\t\t\t\tvar optionSet, option,\r\n\t\t\t\t\toptions = elem.options,\r\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\r\n\t\t\t\t\ti = options.length;\r\n\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\toption = options[ i ];\r\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\r\n\t\t\t\t\t\toptionSet = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// force browsers to behave consistently when non-matching value is set\r\n\t\t\t\tif ( !optionSet ) {\r\n\t\t\t\t\telem.selectedIndex = -1;\r\n\t\t\t\t}\r\n\t\t\t\treturn values;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tattr: function( elem, name, value ) {\r\n\t\tvar hooks, ret,\r\n\t\t\tnType = elem.nodeType;\r\n\r\n\t\t// don't get/set attributes on text, comment and attribute nodes\r\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Fallback to prop when attributes are not supported\r\n\t\tif ( typeof elem.getAttribute === core_strundefined ) {\r\n\t\t\treturn jQuery.prop( elem, name, value );\r\n\t\t}\r\n\r\n\t\t// All attributes are lowercase\r\n\t\t// Grab necessary hook if one is defined\r\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\r\n\t\t\tname = name.toLowerCase();\r\n\t\t\thooks = jQuery.attrHooks[ name ] ||\r\n\t\t\t\t( jQuery.expr.match.boolean.test( name ) ? boolHook : nodeHook );\r\n\t\t}\r\n\r\n\t\tif ( value !== undefined ) {\r\n\r\n\t\t\tif ( value === null ) {\r\n\t\t\t\tjQuery.removeAttr( elem, name );\r\n\r\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\r\n\t\t\t\treturn ret;\r\n\r\n\t\t\t} else {\r\n\t\t\t\telem.setAttribute( name, value + \"\" );\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\r\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\r\n\t\t\treturn ret;\r\n\r\n\t\t} else {\r\n\t\t\tret = jQuery.find.attr( elem, name );\r\n\r\n\t\t\t// Non-existent attributes return null, we normalize to undefined\r\n\t\t\treturn ret == null ?\r\n\t\t\t\tundefined :\r\n\t\t\t\tret;\r\n\t\t}\r\n\t},\r\n\r\n\tremoveAttr: function( elem, value ) {\r\n\t\tvar name, propName,\r\n\t\t\ti = 0,\r\n\t\t\tattrNames = value && value.match( core_rnotwhite );\r\n\r\n\t\tif ( attrNames && elem.nodeType === 1 ) {\r\n\t\t\twhile ( (name = attrNames[i++]) ) {\r\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\r\n\r\n\t\t\t\t// Boolean attributes get special treatment (#10870)\r\n\t\t\t\tif ( jQuery.expr.match.boolean.test( name ) ) {\r\n\t\t\t\t\t// Set corresponding property to false\r\n\t\t\t\t\telem[ propName ] = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\telem.removeAttribute( name );\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tattrHooks: {\r\n\t\ttype: {\r\n\t\t\tset: function( elem, value ) {\r\n\t\t\t\tif ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\r\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\r\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\r\n\t\t\t\t\tvar val = elem.value;\r\n\t\t\t\t\telem.setAttribute( \"type\", value );\r\n\t\t\t\t\tif ( val ) {\r\n\t\t\t\t\t\telem.value = val;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tpropFix: {\r\n\t\t\"for\": \"htmlFor\",\r\n\t\t\"class\": \"className\"\r\n\t},\r\n\r\n\tprop: function( elem, name, value ) {\r\n\t\tvar ret, hooks, notxml,\r\n\t\t\tnType = elem.nodeType;\r\n\r\n\t\t// don't get/set properties on text, comment and attribute nodes\r\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\r\n\r\n\t\tif ( notxml ) {\r\n\t\t\t// Fix name and attach hooks\r\n\t\t\tname = jQuery.propFix[ name ] || name;\r\n\t\t\thooks = jQuery.propHooks[ name ];\r\n\t\t}\r\n\r\n\t\tif ( value !== undefined ) {\r\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\r\n\t\t\t\tret :\r\n\t\t\t\t( elem[ name ] = value );\r\n\r\n\t\t} else {\r\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\r\n\t\t\t\tret :\r\n\t\t\t\telem[ name ];\r\n\t\t}\r\n\t},\r\n\r\n\tpropHooks: {\r\n\t\ttabIndex: {\r\n\t\t\tget: function( elem ) {\r\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\r\n\t\t\t\t\telem.tabIndex :\r\n\t\t\t\t\t-1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\n// Hooks for boolean attributes\r\nboolHook = {\r\n\tset: function( elem, value, name ) {\r\n\t\tif ( value === false ) {\r\n\t\t\t// Remove boolean attributes when set to false\r\n\t\t\tjQuery.removeAttr( elem, name );\r\n\t\t} else {\r\n\t\t\telem.setAttribute( name, name );\r\n\t\t}\r\n\t\treturn name;\r\n\t}\r\n};\r\njQuery.each( jQuery.expr.match.boolean.source.match( /\\w+/g ), function( i, name ) {\r\n\tvar getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;\r\n\r\n\tjQuery.expr.attrHandle[ name ] = function( elem, name, isXML ) {\r\n\t\tvar fn = jQuery.expr.attrHandle[ name ],\r\n\t\t\tret = isXML ?\r\n\t\t\t\tundefined :\r\n\t\t\t\t/* jshint eqeqeq: false */\r\n\t\t\t\t// Temporarily disable this handler to check existence\r\n\t\t\t\t(jQuery.expr.attrHandle[ name ] = undefined) !=\r\n\t\t\t\t\tgetter( elem, name, isXML ) ?\r\n\r\n\t\t\t\t\tname.toLowerCase() :\r\n\t\t\t\t\tnull;\r\n\r\n\t\t// Restore handler\r\n\t\tjQuery.expr.attrHandle[ name ] = fn;\r\n\r\n\t\treturn ret;\r\n\t};\r\n});\r\n\r\n// Support: IE9+\r\n// Selectedness for an option in an optgroup can be inaccurate\r\nif ( !jQuery.support.optSelected ) {\r\n\tjQuery.propHooks.selected = {\r\n\t\tget: function( elem ) {\r\n\t\t\tvar parent = elem.parentNode;\r\n\t\t\tif ( parent && parent.parentNode ) {\r\n\t\t\t\tparent.parentNode.selectedIndex;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n}\r\n\r\njQuery.each([\r\n\t\"tabIndex\",\r\n\t\"readOnly\",\r\n\t\"maxLength\",\r\n\t\"cellSpacing\",\r\n\t\"cellPadding\",\r\n\t\"rowSpan\",\r\n\t\"colSpan\",\r\n\t\"useMap\",\r\n\t\"frameBorder\",\r\n\t\"contentEditable\"\r\n], function() {\r\n\tjQuery.propFix[ this.toLowerCase() ] = this;\r\n});\r\n\r\n// Radios and checkboxes getter/setter\r\njQuery.each([ \"radio\", \"checkbox\" ], function() {\r\n\tjQuery.valHooks[ this ] = {\r\n\t\tset: function( elem, value ) {\r\n\t\t\tif ( jQuery.isArray( value ) ) {\r\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tif ( !jQuery.support.checkOn ) {\r\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\r\n\t\t\t// Support: Webkit\r\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\r\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\r\n\t\t};\r\n\t}\r\n});\r\nvar rkeyEvent = /^key/,\r\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\r\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\r\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\r\n\r\nfunction returnTrue() {\r\n\treturn true;\r\n}\r\n\r\nfunction returnFalse() {\r\n\treturn false;\r\n}\r\n\r\nfunction safeActiveElement() {\r\n\ttry {\r\n\t\treturn document.activeElement;\r\n\t} catch ( err ) { }\r\n}\r\n\r\n/*\r\n * Helper functions for managing events -- not part of the public interface.\r\n * Props to Dean Edwards' addEvent library for many of the ideas.\r\n */\r\njQuery.event = {\r\n\r\n\tglobal: {},\r\n\r\n\tadd: function( elem, types, handler, data, selector ) {\r\n\r\n\t\tvar handleObjIn, eventHandle, tmp,\r\n\t\t\tevents, t, handleObj,\r\n\t\t\tspecial, handlers, type, namespaces, origType,\r\n\t\t\telemData = data_priv.get( elem );\r\n\r\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\r\n\t\tif ( !elemData ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Caller can pass in an object of custom data in lieu of the handler\r\n\t\tif ( handler.handler ) {\r\n\t\t\thandleObjIn = handler;\r\n\t\t\thandler = handleObjIn.handler;\r\n\t\t\tselector = handleObjIn.selector;\r\n\t\t}\r\n\r\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\r\n\t\tif ( !handler.guid ) {\r\n\t\t\thandler.guid = jQuery.guid++;\r\n\t\t}\r\n\r\n\t\t// Init the element's event structure and main handler, if this is the first\r\n\t\tif ( !(events = elemData.events) ) {\r\n\t\t\tevents = elemData.events = {};\r\n\t\t}\r\n\t\tif ( !(eventHandle = elemData.handle) ) {\r\n\t\t\teventHandle = elemData.handle = function( e ) {\r\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\r\n\t\t\t\t// when an event is called after a page has unloaded\r\n\t\t\t\treturn typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\r\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\r\n\t\t\t\t\tundefined;\r\n\t\t\t};\r\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\r\n\t\t\teventHandle.elem = elem;\r\n\t\t}\r\n\r\n\t\t// Handle multiple events separated by a space\r\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\r\n\t\tt = types.length;\r\n\t\twhile ( t-- ) {\r\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\r\n\t\t\ttype = origType = tmp[1];\r\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\r\n\r\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\r\n\t\t\tif ( !type ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// If event changes its type, use the special event handlers for the changed type\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\r\n\t\t\t// If selector defined, determine special event api type, otherwise given type\r\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\r\n\r\n\t\t\t// Update special based on newly reset type\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\r\n\t\t\t// handleObj is passed to all event handlers\r\n\t\t\thandleObj = jQuery.extend({\r\n\t\t\t\ttype: type,\r\n\t\t\t\torigType: origType,\r\n\t\t\t\tdata: data,\r\n\t\t\t\thandler: handler,\r\n\t\t\t\tguid: handler.guid,\r\n\t\t\t\tselector: selector,\r\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\r\n\t\t\t\tnamespace: namespaces.join(\".\")\r\n\t\t\t}, handleObjIn );\r\n\r\n\t\t\t// Init the event handler queue if we're the first\r\n\t\t\tif ( !(handlers = events[ type ]) ) {\r\n\t\t\t\thandlers = events[ type ] = [];\r\n\t\t\t\thandlers.delegateCount = 0;\r\n\r\n\t\t\t\t// Only use addEventListener if the special events handler returns false\r\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\r\n\t\t\t\t\tif ( elem.addEventListener ) {\r\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( special.add ) {\r\n\t\t\t\tspecial.add.call( elem, handleObj );\r\n\r\n\t\t\t\tif ( !handleObj.handler.guid ) {\r\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Add to the element's handler list, delegates in front\r\n\t\t\tif ( selector ) {\r\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\r\n\t\t\t} else {\r\n\t\t\t\thandlers.push( handleObj );\r\n\t\t\t}\r\n\r\n\t\t\t// Keep track of which events have ever been used, for event optimization\r\n\t\t\tjQuery.event.global[ type ] = true;\r\n\t\t}\r\n\r\n\t\t// Nullify elem to prevent memory leaks in IE\r\n\t\telem = null;\r\n\t},\r\n\r\n\t// Detach an event or set of events from an element\r\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\r\n\r\n\t\tvar j, origCount, tmp,\r\n\t\t\tevents, t, handleObj,\r\n\t\t\tspecial, handlers, type, namespaces, origType,\r\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\r\n\r\n\t\tif ( !elemData || !(events = elemData.events) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Once for each type.namespace in types; type may be omitted\r\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\r\n\t\tt = types.length;\r\n\t\twhile ( t-- ) {\r\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\r\n\t\t\ttype = origType = tmp[1];\r\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\r\n\r\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\r\n\t\t\tif ( !type ) {\r\n\t\t\t\tfor ( type in events ) {\r\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tspecial = jQuery.event.special[ type ] || {};\r\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\r\n\t\t\thandlers = events[ type ] || [];\r\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\r\n\r\n\t\t\t// Remove matching events\r\n\t\t\torigCount = j = handlers.length;\r\n\t\t\twhile ( j-- ) {\r\n\t\t\t\thandleObj = handlers[ j ];\r\n\r\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\r\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\r\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\r\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\r\n\t\t\t\t\thandlers.splice( j, 1 );\r\n\r\n\t\t\t\t\tif ( handleObj.selector ) {\r\n\t\t\t\t\t\thandlers.delegateCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( special.remove ) {\r\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\r\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\r\n\t\t\tif ( origCount && !handlers.length ) {\r\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\r\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete events[ type ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remove the expando if it's no longer used\r\n\t\tif ( jQuery.isEmptyObject( events ) ) {\r\n\t\t\tdelete elemData.handle;\r\n\t\t\tdata_priv.remove( elem, \"events\" );\r\n\t\t}\r\n\t},\r\n\r\n\ttrigger: function( event, data, elem, onlyHandlers ) {\r\n\r\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\r\n\t\t\teventPath = [ elem || document ],\r\n\t\t\ttype = core_hasOwn.call( event, \"type\" ) ? event.type : event,\r\n\t\t\tnamespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\r\n\r\n\t\tcur = tmp = elem = elem || document;\r\n\r\n\t\t// Don't do events on text and comment nodes\r\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\r\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( type.indexOf(\".\") >= 0 ) {\r\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\r\n\t\t\tnamespaces = type.split(\".\");\r\n\t\t\ttype = namespaces.shift();\r\n\t\t\tnamespaces.sort();\r\n\t\t}\r\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\r\n\r\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\r\n\t\tevent = event[ jQuery.expando ] ?\r\n\t\t\tevent :\r\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\r\n\r\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\r\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\r\n\t\tevent.namespace = namespaces.join(\".\");\r\n\t\tevent.namespace_re = event.namespace ?\r\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\r\n\t\t\tnull;\r\n\r\n\t\t// Clean up the event in case it is being reused\r\n\t\tevent.result = undefined;\r\n\t\tif ( !event.target ) {\r\n\t\t\tevent.target = elem;\r\n\t\t}\r\n\r\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\r\n\t\tdata = data == null ?\r\n\t\t\t[ event ] :\r\n\t\t\tjQuery.makeArray( data, [ event ] );\r\n\r\n\t\t// Allow special events to draw outside the lines\r\n\t\tspecial = jQuery.event.special[ type ] || {};\r\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\r\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\r\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\r\n\r\n\t\t\tbubbleType = special.delegateType || type;\r\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\r\n\t\t\t\tcur = cur.parentNode;\r\n\t\t\t}\r\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\r\n\t\t\t\teventPath.push( cur );\r\n\t\t\t\ttmp = cur;\r\n\t\t\t}\r\n\r\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\r\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\r\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Fire handlers on the event path\r\n\t\ti = 0;\r\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\r\n\r\n\t\t\tevent.type = i > 1 ?\r\n\t\t\t\tbubbleType :\r\n\t\t\t\tspecial.bindType || type;\r\n\r\n\t\t\t// jQuery handler\r\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\r\n\t\t\tif ( handle ) {\r\n\t\t\t\thandle.apply( cur, data );\r\n\t\t\t}\r\n\r\n\t\t\t// Native handler\r\n\t\t\thandle = ontype && cur[ ontype ];\r\n\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t}\r\n\t\t}\r\n\t\tevent.type = type;\r\n\r\n\t\t// If nobody prevented the default action, do it now\r\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\r\n\r\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\r\n\t\t\t\tjQuery.acceptData( elem ) ) {\r\n\r\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\r\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\r\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\r\n\r\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\r\n\t\t\t\t\ttmp = elem[ ontype ];\r\n\r\n\t\t\t\t\tif ( tmp ) {\r\n\t\t\t\t\t\telem[ ontype ] = null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\r\n\t\t\t\t\tjQuery.event.triggered = type;\r\n\t\t\t\t\telem[ type ]();\r\n\t\t\t\t\tjQuery.event.triggered = undefined;\r\n\r\n\t\t\t\t\tif ( tmp ) {\r\n\t\t\t\t\t\telem[ ontype ] = tmp;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn event.result;\r\n\t},\r\n\r\n\tdispatch: function( event ) {\r\n\r\n\t\t// Make a writable jQuery.Event from the native event object\r\n\t\tevent = jQuery.event.fix( event );\r\n\r\n\t\tvar i, j, ret, matched, handleObj,\r\n\t\t\thandlerQueue = [],\r\n\t\t\targs = core_slice.call( arguments ),\r\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\r\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\r\n\r\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\r\n\t\targs[0] = event;\r\n\t\tevent.delegateTarget = this;\r\n\r\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\r\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Determine handlers\r\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\r\n\r\n\t\t// Run delegates first; they may want to stop propagation beneath us\r\n\t\ti = 0;\r\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\r\n\t\t\tevent.currentTarget = matched.elem;\r\n\r\n\t\t\tj = 0;\r\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\r\n\r\n\t\t\t\t// Triggered event must either 1) have no namespace, or\r\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\r\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\r\n\r\n\t\t\t\t\tevent.handleObj = handleObj;\r\n\t\t\t\t\tevent.data = handleObj.data;\r\n\r\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\r\n\t\t\t\t\t\t\t.apply( matched.elem, args );\r\n\r\n\t\t\t\t\tif ( ret !== undefined ) {\r\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\r\n\t\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t\t\tevent.stopPropagation();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Call the postDispatch hook for the mapped type\r\n\t\tif ( special.postDispatch ) {\r\n\t\t\tspecial.postDispatch.call( this, event );\r\n\t\t}\r\n\r\n\t\treturn event.result;\r\n\t},\r\n\r\n\thandlers: function( event, handlers ) {\r\n\t\tvar i, matches, sel, handleObj,\r\n\t\t\thandlerQueue = [],\r\n\t\t\tdelegateCount = handlers.delegateCount,\r\n\t\t\tcur = event.target;\r\n\r\n\t\t// Find delegate handlers\r\n\t\t// Black-hole SVG <use> instance trees (#13180)\r\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\r\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\r\n\r\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\r\n\r\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\r\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\r\n\t\t\t\t\tmatches = [];\r\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\r\n\t\t\t\t\t\thandleObj = handlers[ i ];\r\n\r\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\r\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\r\n\r\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\r\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\r\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\r\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( matches[ sel ] ) {\r\n\t\t\t\t\t\t\tmatches.push( handleObj );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( matches.length ) {\r\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Add the remaining (directly-bound) handlers\r\n\t\tif ( delegateCount < handlers.length ) {\r\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\r\n\t\t}\r\n\r\n\t\treturn handlerQueue;\r\n\t},\r\n\r\n\t// Includes some event props shared by KeyEvent and MouseEvent\r\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\r\n\r\n\tfixHooks: {},\r\n\r\n\tkeyHooks: {\r\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\r\n\t\tfilter: function( event, original ) {\r\n\r\n\t\t\t// Add which for key events\r\n\t\t\tif ( event.which == null ) {\r\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\r\n\t\t\t}\r\n\r\n\t\t\treturn event;\r\n\t\t}\r\n\t},\r\n\r\n\tmouseHooks: {\r\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\r\n\t\tfilter: function( event, original ) {\r\n\t\t\tvar eventDoc, doc, body,\r\n\t\t\t\tbutton = original.button;\r\n\r\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\r\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\r\n\t\t\t\teventDoc = event.target.ownerDocument || document;\r\n\t\t\t\tdoc = eventDoc.documentElement;\r\n\t\t\t\tbody = eventDoc.body;\r\n\r\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\r\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\r\n\t\t\t}\r\n\r\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\r\n\t\t\t// Note: button is not normalized, so don't use it\r\n\t\t\tif ( !event.which && button !== undefined ) {\r\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\r\n\t\t\t}\r\n\r\n\t\t\treturn event;\r\n\t\t}\r\n\t},\r\n\r\n\tfix: function( event ) {\r\n\t\tif ( event[ jQuery.expando ] ) {\r\n\t\t\treturn event;\r\n\t\t}\r\n\r\n\t\t// Create a writable copy of the event object and normalize some properties\r\n\t\tvar i, prop, copy,\r\n\t\t\ttype = event.type,\r\n\t\t\toriginalEvent = event,\r\n\t\t\tfixHook = this.fixHooks[ type ];\r\n\r\n\t\tif ( !fixHook ) {\r\n\t\t\tthis.fixHooks[ type ] = fixHook =\r\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\r\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\r\n\t\t\t\t{};\r\n\t\t}\r\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\r\n\r\n\t\tevent = new jQuery.Event( originalEvent );\r\n\r\n\t\ti = copy.length;\r\n\t\twhile ( i-- ) {\r\n\t\t\tprop = copy[ i ];\r\n\t\t\tevent[ prop ] = originalEvent[ prop ];\r\n\t\t}\r\n\r\n\t\t// Support: Safari 6.0+, Chrome < 28\r\n\t\t// Target should not be a text node (#504, #13143)\r\n\t\tif ( event.target.nodeType === 3 ) {\r\n\t\t\tevent.target = event.target.parentNode;\r\n\t\t}\r\n\r\n\t\treturn fixHook.filter? fixHook.filter( event, originalEvent ) : event;\r\n\t},\r\n\r\n\tspecial: {\r\n\t\tload: {\r\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\r\n\t\t\tnoBubble: true\r\n\t\t},\r\n\t\tfocus: {\r\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\r\n\t\t\t\t\tthis.focus();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdelegateType: \"focusin\"\r\n\t\t},\r\n\t\tblur: {\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\r\n\t\t\t\t\tthis.blur();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdelegateType: \"focusout\"\r\n\t\t},\r\n\t\tclick: {\r\n\t\t\t// For checkbox, fire native event so checked state will be right\r\n\t\t\ttrigger: function() {\r\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\r\n\t\t\t\t\tthis.click();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\r\n\t\t\t_default: function( event ) {\r\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tbeforeunload: {\r\n\t\t\tpostDispatch: function( event ) {\r\n\r\n\t\t\t\t// Support: Firefox 20+\r\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\r\n\t\t\t\tif ( event.result !== undefined ) {\r\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsimulate: function( type, elem, event, bubble ) {\r\n\t\t// Piggyback on a donor event to simulate a different one.\r\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\r\n\t\t// simulated event prevents default then we do the same on the donor.\r\n\t\tvar e = jQuery.extend(\r\n\t\t\tnew jQuery.Event(),\r\n\t\t\tevent,\r\n\t\t\t{\r\n\t\t\t\ttype: type,\r\n\t\t\t\tisSimulated: true,\r\n\t\t\t\toriginalEvent: {}\r\n\t\t\t}\r\n\t\t);\r\n\t\tif ( bubble ) {\r\n\t\t\tjQuery.event.trigger( e, null, elem );\r\n\t\t} else {\r\n\t\t\tjQuery.event.dispatch.call( elem, e );\r\n\t\t}\r\n\t\tif ( e.isDefaultPrevented() ) {\r\n\t\t\tevent.preventDefault();\r\n\t\t}\r\n\t}\r\n};\r\n\r\njQuery.removeEvent = function( elem, type, handle ) {\r\n\tif ( elem.removeEventListener ) {\r\n\t\telem.removeEventListener( type, handle, false );\r\n\t}\r\n};\r\n\r\njQuery.Event = function( src, props ) {\r\n\t// Allow instantiation without the 'new' keyword\r\n\tif ( !(this instanceof jQuery.Event) ) {\r\n\t\treturn new jQuery.Event( src, props );\r\n\t}\r\n\r\n\t// Event object\r\n\tif ( src && src.type ) {\r\n\t\tthis.originalEvent = src;\r\n\t\tthis.type = src.type;\r\n\r\n\t\t// Events bubbling up the document may have been marked as prevented\r\n\t\t// by a handler lower down the tree; reflect the correct value.\r\n\t\tthis.isDefaultPrevented = ( src.defaultPrevented ||\r\n\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\r\n\r\n\t// Event type\r\n\t} else {\r\n\t\tthis.type = src;\r\n\t}\r\n\r\n\t// Put explicitly provided properties onto the event object\r\n\tif ( props ) {\r\n\t\tjQuery.extend( this, props );\r\n\t}\r\n\r\n\t// Create a timestamp if incoming event doesn't have one\r\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\r\n\r\n\t// Mark it as fixed\r\n\tthis[ jQuery.expando ] = true;\r\n};\r\n\r\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\r\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\r\njQuery.Event.prototype = {\r\n\tisDefaultPrevented: returnFalse,\r\n\tisPropagationStopped: returnFalse,\r\n\tisImmediatePropagationStopped: returnFalse,\r\n\r\n\tpreventDefault: function() {\r\n\t\tvar e = this.originalEvent;\r\n\r\n\t\tthis.isDefaultPrevented = returnTrue;\r\n\r\n\t\tif ( e && e.preventDefault ) {\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t},\r\n\tstopPropagation: function() {\r\n\t\tvar e = this.originalEvent;\r\n\r\n\t\tthis.isPropagationStopped = returnTrue;\r\n\r\n\t\tif ( e && e.stopPropagation ) {\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\t},\r\n\tstopImmediatePropagation: function() {\r\n\t\tthis.isImmediatePropagationStopped = returnTrue;\r\n\t\tthis.stopPropagation();\r\n\t}\r\n};\r\n\r\n// Create mouseenter/leave events using mouseover/out and event-time checks\r\n// Support: Chrome 15+\r\njQuery.each({\r\n\tmouseenter: \"mouseover\",\r\n\tmouseleave: \"mouseout\"\r\n}, function( orig, fix ) {\r\n\tjQuery.event.special[ orig ] = {\r\n\t\tdelegateType: fix,\r\n\t\tbindType: fix,\r\n\r\n\t\thandle: function( event ) {\r\n\t\t\tvar ret,\r\n\t\t\t\ttarget = this,\r\n\t\t\t\trelated = event.relatedTarget,\r\n\t\t\t\thandleObj = event.handleObj;\r\n\r\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\r\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\r\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\r\n\t\t\t\tevent.type = handleObj.origType;\r\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\r\n\t\t\t\tevent.type = fix;\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n// Create \"bubbling\" focus and blur events\r\n// Support: Firefox, Chrome, Safari\r\nif ( !jQuery.support.focusinBubbles ) {\r\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\r\n\r\n\t\t// Attach a single capturing handler while someone wants focusin/focusout\r\n\t\tvar attaches = 0,\r\n\t\t\thandler = function( event ) {\r\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\r\n\t\t\t};\r\n\r\n\t\tjQuery.event.special[ fix ] = {\r\n\t\t\tsetup: function() {\r\n\t\t\t\tif ( attaches++ === 0 ) {\r\n\t\t\t\t\tdocument.addEventListener( orig, handler, true );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tteardown: function() {\r\n\t\t\t\tif ( --attaches === 0 ) {\r\n\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t});\r\n}\r\n\r\njQuery.fn.extend({\r\n\r\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\r\n\t\tvar origFn, type;\r\n\r\n\t\t// Types can be a map of types/handlers\r\n\t\tif ( typeof types === \"object\" ) {\r\n\t\t\t// ( types-Object, selector, data )\r\n\t\t\tif ( typeof selector !== \"string\" ) {\r\n\t\t\t\t// ( types-Object, data )\r\n\t\t\t\tdata = data || selector;\r\n\t\t\t\tselector = undefined;\r\n\t\t\t}\r\n\t\t\tfor ( type in types ) {\r\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ( data == null && fn == null ) {\r\n\t\t\t// ( types, fn )\r\n\t\t\tfn = selector;\r\n\t\t\tdata = selector = undefined;\r\n\t\t} else if ( fn == null ) {\r\n\t\t\tif ( typeof selector === \"string\" ) {\r\n\t\t\t\t// ( types, selector, fn )\r\n\t\t\t\tfn = data;\r\n\t\t\t\tdata = undefined;\r\n\t\t\t} else {\r\n\t\t\t\t// ( types, data, fn )\r\n\t\t\t\tfn = data;\r\n\t\t\t\tdata = selector;\r\n\t\t\t\tselector = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ( fn === false ) {\r\n\t\t\tfn = returnFalse;\r\n\t\t} else if ( !fn ) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ( one === 1 ) {\r\n\t\t\torigFn = fn;\r\n\t\t\tfn = function( event ) {\r\n\t\t\t\t// Can use an empty set, since event contains the info\r\n\t\t\t\tjQuery().off( event );\r\n\t\t\t\treturn origFn.apply( this, arguments );\r\n\t\t\t};\r\n\t\t\t// Use same guid so caller can remove using origFn\r\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\r\n\t\t}\r\n\t\treturn this.each( function() {\r\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\r\n\t\t});\r\n\t},\r\n\tone: function( types, selector, data, fn ) {\r\n\t\treturn this.on( types, selector, data, fn, 1 );\r\n\t},\r\n\toff: function( types, selector, fn ) {\r\n\t\tvar handleObj, type;\r\n\t\tif ( types && types.preventDefault && types.handleObj ) {\r\n\t\t\t// ( event )  dispatched jQuery.Event\r\n\t\t\thandleObj = types.handleObj;\r\n\t\t\tjQuery( types.delegateTarget ).off(\r\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\r\n\t\t\t\thandleObj.selector,\r\n\t\t\t\thandleObj.handler\r\n\t\t\t);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif ( typeof types === \"object\" ) {\r\n\t\t\t// ( types-object [, selector] )\r\n\t\t\tfor ( type in types ) {\r\n\t\t\t\tthis.off( type, selector, types[ type ] );\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif ( selector === false || typeof selector === \"function\" ) {\r\n\t\t\t// ( types [, fn] )\r\n\t\t\tfn = selector;\r\n\t\t\tselector = undefined;\r\n\t\t}\r\n\t\tif ( fn === false ) {\r\n\t\t\tfn = returnFalse;\r\n\t\t}\r\n\t\treturn this.each(function() {\r\n\t\t\tjQuery.event.remove( this, types, fn, selector );\r\n\t\t});\r\n\t},\r\n\r\n\ttrigger: function( type, data ) {\r\n\t\treturn this.each(function() {\r\n\t\t\tjQuery.event.trigger( type, data, this );\r\n\t\t});\r\n\t},\r\n\ttriggerHandler: function( type, data ) {\r\n\t\tvar elem = this[0];\r\n\t\tif ( elem ) {\r\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\r\n\t\t}\r\n\t}\r\n});\r\nvar isSimple = /^.[^:#\\[\\.,]*$/,\r\n\trneedsContext = jQuery.expr.match.needsContext,\r\n\t// methods guaranteed to produce a unique set when starting from a unique set\r\n\tguaranteedUnique = {\r\n\t\tchildren: true,\r\n\t\tcontents: true,\r\n\t\tnext: true,\r\n\t\tprev: true\r\n\t};\r\n\r\njQuery.fn.extend({\r\n\tfind: function( selector ) {\r\n\t\tvar self, matched, i,\r\n\t\t\tl = this.length;\r\n\r\n\t\tif ( typeof selector !== \"string\" ) {\r\n\t\t\tself = this;\r\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\r\n\t\t\t\tfor ( i = 0; i < l; i++ ) {\r\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}) );\r\n\t\t}\r\n\r\n\t\tmatched = [];\r\n\t\tfor ( i = 0; i < l; i++ ) {\r\n\t\t\tjQuery.find( selector, this[ i ], matched );\r\n\t\t}\r\n\r\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\r\n\t\tmatched = this.pushStack( l > 1 ? jQuery.unique( matched ) : matched );\r\n\t\tmatched.selector = ( this.selector ? this.selector + \" \" : \"\" ) + selector;\r\n\t\treturn matched;\r\n\t},\r\n\r\n\thas: function( target ) {\r\n\t\tvar targets = jQuery( target, this ),\r\n\t\t\tl = targets.length;\r\n\r\n\t\treturn this.filter(function() {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tnot: function( selector ) {\r\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\r\n\t},\r\n\r\n\tfilter: function( selector ) {\r\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\r\n\t},\r\n\r\n\tis: function( selector ) {\r\n\t\treturn !!selector && (\r\n\t\t\ttypeof selector === \"string\" ?\r\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\r\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\r\n\t\t\t\trneedsContext.test( selector ) ?\r\n\t\t\t\t\tjQuery( selector, this.context ).index( this[ 0 ] ) >= 0 :\r\n\t\t\t\t\tjQuery.filter( selector, this ).length > 0 :\r\n\t\t\t\tthis.filter( selector ).length > 0 );\r\n\t},\r\n\r\n\tclosest: function( selectors, context ) {\r\n\t\tvar cur,\r\n\t\t\ti = 0,\r\n\t\t\tl = this.length,\r\n\t\t\tmatched = [],\r\n\t\t\tpos = ( rneedsContext.test( selectors ) || typeof selectors !== \"string\" ) ?\r\n\t\t\t\tjQuery( selectors, context || this.context ) :\r\n\t\t\t\t0;\r\n\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\r\n\t\t\t\t// Always skip document fragments\r\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\r\n\t\t\t\t\tpos.index(cur) > -1 :\r\n\r\n\t\t\t\t\t// Don't pass non-elements to Sizzle\r\n\t\t\t\t\tcur.nodeType === 1 &&\r\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\r\n\r\n\t\t\t\t\tcur = matched.push( cur );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\r\n\t},\r\n\r\n\t// Determine the position of an element within\r\n\t// the matched set of elements\r\n\tindex: function( elem ) {\r\n\r\n\t\t// No argument, return index in parent\r\n\t\tif ( !elem ) {\r\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\r\n\t\t}\r\n\r\n\t\t// index in selector\r\n\t\tif ( typeof elem === \"string\" ) {\r\n\t\t\treturn core_indexOf.call( jQuery( elem ), this[ 0 ] );\r\n\t\t}\r\n\r\n\t\t// Locate the position of the desired element\r\n\t\treturn core_indexOf.call( this,\r\n\r\n\t\t\t// If it receives a jQuery object, the first element is used\r\n\t\t\telem.jquery ? elem[ 0 ] : elem\r\n\t\t);\r\n\t},\r\n\r\n\tadd: function( selector, context ) {\r\n\t\tvar set = typeof selector === \"string\" ?\r\n\t\t\t\tjQuery( selector, context ) :\r\n\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\r\n\t\t\tall = jQuery.merge( this.get(), set );\r\n\r\n\t\treturn this.pushStack( jQuery.unique(all) );\r\n\t},\r\n\r\n\taddBack: function( selector ) {\r\n\t\treturn this.add( selector == null ?\r\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\r\n\t\t);\r\n\t}\r\n});\r\n\r\nfunction sibling( cur, dir ) {\r\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\r\n\r\n\treturn cur;\r\n}\r\n\r\njQuery.each({\r\n\tparent: function( elem ) {\r\n\t\tvar parent = elem.parentNode;\r\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\r\n\t},\r\n\tparents: function( elem ) {\r\n\t\treturn jQuery.dir( elem, \"parentNode\" );\r\n\t},\r\n\tparentsUntil: function( elem, i, until ) {\r\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\r\n\t},\r\n\tnext: function( elem ) {\r\n\t\treturn sibling( elem, \"nextSibling\" );\r\n\t},\r\n\tprev: function( elem ) {\r\n\t\treturn sibling( elem, \"previousSibling\" );\r\n\t},\r\n\tnextAll: function( elem ) {\r\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\r\n\t},\r\n\tprevAll: function( elem ) {\r\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\r\n\t},\r\n\tnextUntil: function( elem, i, until ) {\r\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\r\n\t},\r\n\tprevUntil: function( elem, i, until ) {\r\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\r\n\t},\r\n\tsiblings: function( elem ) {\r\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\r\n\t},\r\n\tchildren: function( elem ) {\r\n\t\treturn jQuery.sibling( elem.firstChild );\r\n\t},\r\n\tcontents: function( elem ) {\r\n\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\r\n\t\t\telem.contentDocument || elem.contentWindow.document :\r\n\t\t\tjQuery.merge( [], elem.childNodes );\r\n\t}\r\n}, function( name, fn ) {\r\n\tjQuery.fn[ name ] = function( until, selector ) {\r\n\t\tvar matched = jQuery.map( this, fn, until );\r\n\r\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\r\n\t\t\tselector = until;\r\n\t\t}\r\n\r\n\t\tif ( selector && typeof selector === \"string\" ) {\r\n\t\t\tmatched = jQuery.filter( selector, matched );\r\n\t\t}\r\n\r\n\t\tif ( this.length > 1 ) {\r\n\t\t\t// Remove duplicates\r\n\t\t\tif ( !guaranteedUnique[ name ] ) {\r\n\t\t\t\tjQuery.unique( matched );\r\n\t\t\t}\r\n\r\n\t\t\t// Reverse order for parents* and prev*\r\n\t\t\tif ( name[ 0 ] === \"p\" ) {\r\n\t\t\t\tmatched.reverse();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( matched );\r\n\t};\r\n});\r\n\r\njQuery.extend({\r\n\tfilter: function( expr, elems, not ) {\r\n\t\tvar elem = elems[ 0 ];\r\n\r\n\t\tif ( not ) {\r\n\t\t\texpr = \":not(\" + expr + \")\";\r\n\t\t}\r\n\r\n\t\treturn elems.length === 1 && elem.nodeType === 1 ?\r\n\t\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\r\n\t\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\r\n\t\t\t\treturn elem.nodeType === 1;\r\n\t\t\t}));\r\n\t},\r\n\r\n\tdir: function( elem, dir, until ) {\r\n\t\tvar matched = [],\r\n\t\t\ttruncate = until !== undefined;\r\n\r\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\r\n\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tmatched.push( elem );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn matched;\r\n\t},\r\n\r\n\tsibling: function( n, elem ) {\r\n\t\tvar matched = [];\r\n\r\n\t\tfor ( ; n; n = n.nextSibling ) {\r\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\r\n\t\t\t\tmatched.push( n );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn matched;\r\n\t}\r\n});\r\n\r\n// Implement the identical functionality for filter and not\r\nfunction winnow( elements, qualifier, not ) {\r\n\tif ( jQuery.isFunction( qualifier ) ) {\r\n\t\treturn jQuery.grep( elements, function( elem, i ) {\r\n\t\t\t/* jshint -W018 */\r\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tif ( qualifier.nodeType ) {\r\n\t\treturn jQuery.grep( elements, function( elem ) {\r\n\t\t\treturn ( elem === qualifier ) !== not;\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tif ( typeof qualifier === \"string\" ) {\r\n\t\tif ( isSimple.test( qualifier ) ) {\r\n\t\t\treturn jQuery.filter( qualifier, elements, not );\r\n\t\t}\r\n\r\n\t\tqualifier = jQuery.filter( qualifier, elements );\r\n\t}\r\n\r\n\treturn jQuery.grep( elements, function( elem ) {\r\n\t\treturn ( core_indexOf.call( qualifier, elem ) >= 0 ) !== not;\r\n\t});\r\n}\r\nvar rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\r\n\trtagName = /<([\\w:]+)/,\r\n\trhtml = /<|&#?\\w+;/,\r\n\trnoInnerhtml = /<(?:script|style|link)/i,\r\n\tmanipulation_rcheckableType = /^(?:checkbox|radio)$/i,\r\n\t// checked=\"checked\" or checked\r\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\r\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\r\n\trscriptTypeMasked = /^true\\/(.*)/,\r\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\r\n\r\n\t// We have to close these tags to support XHTML (#13200)\r\n\twrapMap = {\r\n\r\n\t\t// Support: IE 9\r\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\r\n\r\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\r\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\r\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\r\n\r\n\t\t_default: [ 0, \"\", \"\" ]\r\n\t};\r\n\r\n// Support: IE 9\r\nwrapMap.optgroup = wrapMap.option;\r\n\r\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.col = wrapMap.thead;\r\nwrapMap.th = wrapMap.td;\r\n\r\njQuery.fn.extend({\r\n\ttext: function( value ) {\r\n\t\treturn jQuery.access( this, function( value ) {\r\n\t\t\treturn value === undefined ?\r\n\t\t\t\tjQuery.text( this ) :\r\n\t\t\t\tthis.empty().append( ( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value ) );\r\n\t\t}, null, value, arguments.length );\r\n\t},\r\n\r\n\tappend: function() {\r\n\t\treturn this.domManip( arguments, function( elem ) {\r\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\r\n\t\t\t\tvar target = manipulationTarget( this, elem );\r\n\t\t\t\ttarget.appendChild( elem );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tprepend: function() {\r\n\t\treturn this.domManip( arguments, function( elem ) {\r\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\r\n\t\t\t\tvar target = manipulationTarget( this, elem );\r\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tbefore: function() {\r\n\t\treturn this.domManip( arguments, function( elem ) {\r\n\t\t\tif ( this.parentNode ) {\r\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tafter: function() {\r\n\t\treturn this.domManip( arguments, function( elem ) {\r\n\t\t\tif ( this.parentNode ) {\r\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t// keepData is for internal use only--do not document\r\n\tremove: function( selector, keepData ) {\r\n\t\tvar elem,\r\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\r\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\r\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\r\n\t\t\t}\r\n\r\n\t\t\tif ( elem.parentNode ) {\r\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\r\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\r\n\t\t\t\t}\r\n\t\t\t\telem.parentNode.removeChild( elem );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tempty: function() {\r\n\t\tvar elem,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\r\n\t\t\tif ( elem.nodeType === 1 ) {\r\n\r\n\t\t\t\t// Prevent memory leaks\r\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\r\n\r\n\t\t\t\t// Remove any remaining nodes\r\n\t\t\t\telem.textContent = \"\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\r\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\r\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\r\n\r\n\t\treturn this.map( function () {\r\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\r\n\t\t});\r\n\t},\r\n\r\n\thtml: function( value ) {\r\n\t\treturn jQuery.access( this, function( value ) {\r\n\t\t\tvar elem = this[ 0 ] || {},\r\n\t\t\t\ti = 0,\r\n\t\t\t\tl = this.length;\r\n\r\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\r\n\t\t\t\treturn elem.innerHTML;\r\n\t\t\t}\r\n\r\n\t\t\t// See if we can take a shortcut and just use innerHTML\r\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\r\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\r\n\r\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\t\telem = this[ i ] || {};\r\n\r\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\r\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\r\n\t\t\t\t\t\t\telem.innerHTML = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\telem = 0;\r\n\r\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\r\n\t\t\t\t} catch( e ) {}\r\n\t\t\t}\r\n\r\n\t\t\tif ( elem ) {\r\n\t\t\t\tthis.empty().append( value );\r\n\t\t\t}\r\n\t\t}, null, value, arguments.length );\r\n\t},\r\n\r\n\treplaceWith: function() {\r\n\t\tvar\r\n\t\t\t// Snapshot the DOM in case .domManip sweeps something relevant into its fragment\r\n\t\t\targs = jQuery.map( this, function( elem ) {\r\n\t\t\t\treturn [ elem.nextSibling, elem.parentNode ];\r\n\t\t\t}),\r\n\t\t\ti = 0;\r\n\r\n\t\t// Make the changes, replacing each context element with the new content\r\n\t\tthis.domManip( arguments, function( elem ) {\r\n\t\t\tvar next = args[ i++ ],\r\n\t\t\t\tparent = args[ i++ ];\r\n\r\n\t\t\tif ( parent ) {\r\n\t\t\t\tjQuery( this ).remove();\r\n\t\t\t\tparent.insertBefore( elem, next );\r\n\t\t\t}\r\n\t\t// Allow new content to include elements from the context set\r\n\t\t}, true );\r\n\r\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\r\n\t\treturn i ? this : this.remove();\r\n\t},\r\n\r\n\tdetach: function( selector ) {\r\n\t\treturn this.remove( selector, true );\r\n\t},\r\n\r\n\tdomManip: function( args, callback, allowIntersection ) {\r\n\r\n\t\t// Flatten any nested arrays\r\n\t\targs = core_concat.apply( [], args );\r\n\r\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\r\n\t\t\ti = 0,\r\n\t\t\tl = this.length,\r\n\t\t\tset = this,\r\n\t\t\tiNoClone = l - 1,\r\n\t\t\tvalue = args[ 0 ],\r\n\t\t\tisFunction = jQuery.isFunction( value );\r\n\r\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\r\n\t\tif ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\r\n\t\t\treturn this.each(function( index ) {\r\n\t\t\t\tvar self = set.eq( index );\r\n\t\t\t\tif ( isFunction ) {\r\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\r\n\t\t\t\t}\r\n\t\t\t\tself.domManip( args, callback, allowIntersection );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( l ) {\r\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );\r\n\t\t\tfirst = fragment.firstChild;\r\n\r\n\t\t\tif ( fragment.childNodes.length === 1 ) {\r\n\t\t\t\tfragment = first;\r\n\t\t\t}\r\n\r\n\t\t\tif ( first ) {\r\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\r\n\t\t\t\thasScripts = scripts.length;\r\n\r\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\r\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\r\n\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\tnode = fragment;\r\n\r\n\t\t\t\t\tif ( i !== iNoClone ) {\r\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\r\n\r\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\r\n\t\t\t\t\t\tif ( hasScripts ) {\r\n\t\t\t\t\t\t\t// Support: QtWebKit\r\n\t\t\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\r\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcallback.call( this[ i ], node, i );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasScripts ) {\r\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\r\n\r\n\t\t\t\t\t// Reenable scripts\r\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\r\n\r\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\r\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\r\n\t\t\t\t\t\tnode = scripts[ i ];\r\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\r\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\r\n\r\n\t\t\t\t\t\t\tif ( node.src ) {\r\n\t\t\t\t\t\t\t\t// Hope ajax is available...\r\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\njQuery.each({\r\n\tappendTo: \"append\",\r\n\tprependTo: \"prepend\",\r\n\tinsertBefore: \"before\",\r\n\tinsertAfter: \"after\",\r\n\treplaceAll: \"replaceWith\"\r\n}, function( name, original ) {\r\n\tjQuery.fn[ name ] = function( selector ) {\r\n\t\tvar elems,\r\n\t\t\tret = [],\r\n\t\t\tinsert = jQuery( selector ),\r\n\t\t\tlast = insert.length - 1,\r\n\t\t\ti = 0;\r\n\r\n\t\tfor ( ; i <= last; i++ ) {\r\n\t\t\telems = i === last ? this : this.clone( true );\r\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\r\n\r\n\t\t\t// Support: QtWebKit\r\n\t\t\t// .get() because core_push.apply(_, arraylike) throws\r\n\t\t\tcore_push.apply( ret, elems.get() );\r\n\t\t}\r\n\r\n\t\treturn this.pushStack( ret );\r\n\t};\r\n});\r\n\r\njQuery.extend({\r\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\r\n\t\tvar i, l, srcElements, destElements,\r\n\t\t\tclone = elem.cloneNode( true ),\r\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\r\n\r\n\t\t// Support: IE >= 9\r\n\t\t// Fix Cloning issues\r\n\t\tif ( !jQuery.support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {\r\n\r\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\r\n\t\t\tdestElements = getAll( clone );\r\n\t\t\tsrcElements = getAll( elem );\r\n\r\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\r\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Copy the events from the original to the clone\r\n\t\tif ( dataAndEvents ) {\r\n\t\t\tif ( deepDataAndEvents ) {\r\n\t\t\t\tsrcElements = srcElements || getAll( elem );\r\n\t\t\t\tdestElements = destElements || getAll( clone );\r\n\r\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\r\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcloneCopyEvent( elem, clone );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Preserve script evaluation history\r\n\t\tdestElements = getAll( clone, \"script\" );\r\n\t\tif ( destElements.length > 0 ) {\r\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\r\n\t\t}\r\n\r\n\t\t// Return the cloned set\r\n\t\treturn clone;\r\n\t},\r\n\r\n\tbuildFragment: function( elems, context, scripts, selection ) {\r\n\t\tvar elem, tmp, tag, wrap, contains, j,\r\n\t\t\ti = 0,\r\n\t\t\tl = elems.length,\r\n\t\t\tfragment = context.createDocumentFragment(),\r\n\t\t\tnodes = [];\r\n\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\telem = elems[ i ];\r\n\r\n\t\t\tif ( elem || elem === 0 ) {\r\n\r\n\t\t\t\t// Add nodes directly\r\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\r\n\t\t\t\t\t// Support: QtWebKit\r\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\r\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\r\n\r\n\t\t\t\t// Convert non-html into a text node\r\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\r\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\r\n\r\n\t\t\t\t// Convert html into DOM nodes\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\r\n\r\n\t\t\t\t\t// Deserialize a standard representation\r\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[ 1 ].toLowerCase();\r\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\r\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\r\n\r\n\t\t\t\t\t// Descend through wrappers to the right content\r\n\t\t\t\t\tj = wrap[ 0 ];\r\n\t\t\t\t\twhile ( j-- ) {\r\n\t\t\t\t\t\ttmp = tmp.firstChild;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Support: QtWebKit\r\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\r\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\r\n\r\n\t\t\t\t\t// Remember the top-level container\r\n\t\t\t\t\ttmp = fragment.firstChild;\r\n\r\n\t\t\t\t\t// Fixes #12346\r\n\t\t\t\t\t// Support: Webkit, IE\r\n\t\t\t\t\ttmp.textContent = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remove wrapper from fragment\r\n\t\tfragment.textContent = \"\";\r\n\r\n\t\ti = 0;\r\n\t\twhile ( (elem = nodes[ i++ ]) ) {\r\n\r\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\r\n\t\t\t// that element, do not do anything\r\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\r\n\r\n\t\t\t// Append to fragment\r\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\r\n\r\n\t\t\t// Preserve script evaluation history\r\n\t\t\tif ( contains ) {\r\n\t\t\t\tsetGlobalEval( tmp );\r\n\t\t\t}\r\n\r\n\t\t\t// Capture executables\r\n\t\t\tif ( scripts ) {\r\n\t\t\t\tj = 0;\r\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\r\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\r\n\t\t\t\t\t\tscripts.push( elem );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fragment;\r\n\t},\r\n\r\n\tcleanData: function( elems ) {\r\n\t\tvar data, elem, type,\r\n\t\t\tl = elems.length,\r\n\t\t\ti = 0,\r\n\t\t\tspecial = jQuery.event.special;\r\n\r\n\t\tfor ( ; i < l; i++ ) {\r\n\t\t\telem = elems[ i ];\r\n\r\n\t\t\tif ( jQuery.acceptData( elem ) ) {\r\n\r\n\t\t\t\tdata = data_priv.access( elem );\r\n\r\n\t\t\t\tif ( data ) {\r\n\t\t\t\t\tfor ( type in data.events ) {\r\n\t\t\t\t\t\tif ( special[ type ] ) {\r\n\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\r\n\r\n\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Discard any remaining `private` and `user` data\r\n\t\t\t// One day we'll replace the dual arrays with a WeakMap and this won't be an issue.\r\n\t\t\t// (Splices the data objects out of the internal cache arrays)\r\n\t\t\tdata_user.discard( elem );\r\n\t\t\tdata_priv.discard( elem );\r\n\t\t}\r\n\t},\r\n\r\n\t_evalUrl: function( url ) {\r\n\t\treturn jQuery.ajax({\r\n\t\t\turl: url,\r\n\t\t\ttype: \"GET\",\r\n\t\t\tdataType: \"text\",\r\n\t\t\tasync: false,\r\n\t\t\tglobal: false,\r\n\t\t\tsuccess: jQuery.globalEval\r\n\t\t});\r\n\t}\r\n});\r\n\r\n// Support: 1.x compatibility\r\n// Manipulating tables requires a tbody\r\nfunction manipulationTarget( elem, content ) {\r\n\treturn jQuery.nodeName( elem, \"table\" ) &&\r\n\t\tjQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, \"tr\" ) ?\r\n\r\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\r\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\r\n\t\telem;\r\n}\r\n\r\n// Replace/restore the type attribute of script elements for safe DOM manipulation\r\nfunction disableScript( elem ) {\r\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\r\n\treturn elem;\r\n}\r\nfunction restoreScript( elem ) {\r\n\tvar match = rscriptTypeMasked.exec( elem.type );\r\n\r\n\tif ( match ) {\r\n\t\telem.type = match[ 1 ];\r\n\t} else {\r\n\t\telem.removeAttribute(\"type\");\r\n\t}\r\n\r\n\treturn elem;\r\n}\r\n\r\n// Mark scripts as having already been evaluated\r\nfunction setGlobalEval( elems, refElements ) {\r\n\tvar l = elems.length,\r\n\t\ti = 0;\r\n\r\n\tfor ( ; i < l; i++ ) {\r\n\t\tdata_priv.set(\r\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction cloneCopyEvent( src, dest ) {\r\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\r\n\r\n\tif ( dest.nodeType !== 1 ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 1. Copy private data: events, handlers, etc.\r\n\tif ( data_priv.hasData( src ) ) {\r\n\t\tpdataOld = data_priv.access( src );\r\n\t\tpdataCur = jQuery.extend( {}, pdataOld );\r\n\t\tevents = pdataOld.events;\r\n\r\n\t\tdata_priv.set( dest, pdataCur );\r\n\r\n\t\tif ( events ) {\r\n\t\t\tdelete pdataCur.handle;\r\n\t\t\tpdataCur.events = {};\r\n\r\n\t\t\tfor ( type in events ) {\r\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\r\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// 2. Copy user data\r\n\tif ( data_user.hasData( src ) ) {\r\n\t\tudataOld = data_user.access( src );\r\n\t\tudataCur = jQuery.extend( {}, udataOld );\r\n\r\n\t\tdata_user.set( dest, udataCur );\r\n\t}\r\n}\r\n\r\n\r\nfunction getAll( context, tag ) {\r\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\r\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\r\n\t\t\t[];\r\n\r\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\r\n\t\tjQuery.merge( [ context ], ret ) :\r\n\t\tret;\r\n}\r\n\r\n// Support: IE >= 9\r\nfunction fixInput( src, dest ) {\r\n\tvar nodeName = dest.nodeName.toLowerCase();\r\n\r\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\r\n\tif ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\r\n\t\tdest.checked = src.checked;\r\n\r\n\t// Fails to return the selected option to the default selected state when cloning options\r\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\r\n\t\tdest.defaultValue = src.defaultValue;\r\n\t}\r\n}\r\njQuery.fn.extend({\r\n\twrapAll: function( html ) {\r\n\t\tvar wrap;\r\n\r\n\t\tif ( jQuery.isFunction( html ) ) {\r\n\t\t\treturn this.each(function( i ) {\r\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( this[ 0 ] ) {\r\n\r\n\t\t\t// The elements to wrap the target around\r\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\r\n\r\n\t\t\tif ( this[ 0 ].parentNode ) {\r\n\t\t\t\twrap.insertBefore( this[ 0 ] );\r\n\t\t\t}\r\n\r\n\t\t\twrap.map(function() {\r\n\t\t\t\tvar elem = this;\r\n\r\n\t\t\t\twhile ( elem.firstElementChild ) {\r\n\t\t\t\t\telem = elem.firstElementChild;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn elem;\r\n\t\t\t}).append( this );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\twrapInner: function( html ) {\r\n\t\tif ( jQuery.isFunction( html ) ) {\r\n\t\t\treturn this.each(function( i ) {\r\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\tvar self = jQuery( this ),\r\n\t\t\t\tcontents = self.contents();\r\n\r\n\t\t\tif ( contents.length ) {\r\n\t\t\t\tcontents.wrapAll( html );\r\n\r\n\t\t\t} else {\r\n\t\t\t\tself.append( html );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\twrap: function( html ) {\r\n\t\tvar isFunction = jQuery.isFunction( html );\r\n\r\n\t\treturn this.each(function( i ) {\r\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\r\n\t\t});\r\n\t},\r\n\r\n\tunwrap: function() {\r\n\t\treturn this.parent().each(function() {\r\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\r\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\r\n\t\t\t}\r\n\t\t}).end();\r\n\t}\r\n});\r\nvar curCSS, iframe,\r\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\r\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\r\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\r\n\trmargin = /^margin/,\r\n\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\r\n\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\r\n\trrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\r\n\telemdisplay = { BODY: \"block\" },\r\n\r\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\r\n\tcssNormalTransform = {\r\n\t\tletterSpacing: 0,\r\n\t\tfontWeight: 400\r\n\t},\r\n\r\n\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\r\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\r\n\r\n// return a css property mapped to a potentially vendor prefixed property\r\nfunction vendorPropName( style, name ) {\r\n\r\n\t// shortcut for names that are not vendor prefixed\r\n\tif ( name in style ) {\r\n\t\treturn name;\r\n\t}\r\n\r\n\t// check for vendor prefixed names\r\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\r\n\t\torigName = name,\r\n\t\ti = cssPrefixes.length;\r\n\r\n\twhile ( i-- ) {\r\n\t\tname = cssPrefixes[ i ] + capName;\r\n\t\tif ( name in style ) {\r\n\t\t\treturn name;\r\n\t\t}\r\n\t}\r\n\r\n\treturn origName;\r\n}\r\n\r\nfunction isHidden( elem, el ) {\r\n\t// isHidden might be called from jQuery#filter function;\r\n\t// in that case, element will be second argument\r\n\telem = el || elem;\r\n\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\r\n}\r\n\r\n// NOTE: we've included the \"window\" in window.getComputedStyle\r\n// because jsdom on node.js will break without it.\r\nfunction getStyles( elem ) {\r\n\treturn window.getComputedStyle( elem, null );\r\n}\r\n\r\nfunction showHide( elements, show ) {\r\n\tvar display, elem, hidden,\r\n\t\tvalues = [],\r\n\t\tindex = 0,\r\n\t\tlength = elements.length;\r\n\r\n\tfor ( ; index < length; index++ ) {\r\n\t\telem = elements[ index ];\r\n\t\tif ( !elem.style ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\r\n\t\tdisplay = elem.style.display;\r\n\t\tif ( show ) {\r\n\t\t\t// Reset the inline display of this element to learn if it is\r\n\t\t\t// being hidden by cascaded rules or not\r\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\r\n\t\t\t\telem.style.display = \"\";\r\n\t\t\t}\r\n\r\n\t\t\t// Set elements which have been overridden with display: none\r\n\t\t\t// in a stylesheet to whatever the default browser style is\r\n\t\t\t// for such an element\r\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\r\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\r\n\t\t\t}\r\n\t\t} else {\r\n\r\n\t\t\tif ( !values[ index ] ) {\r\n\t\t\t\thidden = isHidden( elem );\r\n\r\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\r\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\") );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Set the display of most of the elements in a second loop\r\n\t// to avoid the constant reflow\r\n\tfor ( index = 0; index < length; index++ ) {\r\n\t\telem = elements[ index ];\r\n\t\tif ( !elem.style ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\r\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\r\n\t\t}\r\n\t}\r\n\r\n\treturn elements;\r\n}\r\n\r\njQuery.fn.extend({\r\n\tcss: function( name, value ) {\r\n\t\treturn jQuery.access( this, function( elem, name, value ) {\r\n\t\t\tvar styles, len,\r\n\t\t\t\tmap = {},\r\n\t\t\t\ti = 0;\r\n\r\n\t\t\tif ( jQuery.isArray( name ) ) {\r\n\t\t\t\tstyles = getStyles( elem );\r\n\t\t\t\tlen = name.length;\r\n\r\n\t\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn map;\r\n\t\t\t}\r\n\r\n\t\t\treturn value !== undefined ?\r\n\t\t\t\tjQuery.style( elem, name, value ) :\r\n\t\t\t\tjQuery.css( elem, name );\r\n\t\t}, name, value, arguments.length > 1 );\r\n\t},\r\n\tshow: function() {\r\n\t\treturn showHide( this, true );\r\n\t},\r\n\thide: function() {\r\n\t\treturn showHide( this );\r\n\t},\r\n\ttoggle: function( state ) {\r\n\t\tvar bool = typeof state === \"boolean\";\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\tif ( bool ? state : isHidden( this ) ) {\r\n\t\t\t\tjQuery( this ).show();\r\n\t\t\t} else {\r\n\t\t\t\tjQuery( this ).hide();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n});\r\n\r\njQuery.extend({\r\n\t// Add in style property hooks for overriding the default\r\n\t// behavior of getting and setting a style property\r\n\tcssHooks: {\r\n\t\topacity: {\r\n\t\t\tget: function( elem, computed ) {\r\n\t\t\t\tif ( computed ) {\r\n\t\t\t\t\t// We should always get a number back from opacity\r\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\r\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// Exclude the following css properties to add px\r\n\tcssNumber: {\r\n\t\t\"columnCount\": true,\r\n\t\t\"fillOpacity\": true,\r\n\t\t\"fontWeight\": true,\r\n\t\t\"lineHeight\": true,\r\n\t\t\"opacity\": true,\r\n\t\t\"orphans\": true,\r\n\t\t\"widows\": true,\r\n\t\t\"zIndex\": true,\r\n\t\t\"zoom\": true\r\n\t},\r\n\r\n\t// Add in properties whose names you wish to fix before\r\n\t// setting or getting the value\r\n\tcssProps: {\r\n\t\t// normalize float css property\r\n\t\t\"float\": \"cssFloat\"\r\n\t},\r\n\r\n\t// Get and set the style property on a DOM Node\r\n\tstyle: function( elem, name, value, extra ) {\r\n\t\t// Don't set styles on text and comment nodes\r\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Make sure that we're working with the right name\r\n\t\tvar ret, type, hooks,\r\n\t\t\torigName = jQuery.camelCase( name ),\r\n\t\t\tstyle = elem.style;\r\n\r\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\r\n\r\n\t\t// gets hook for the prefixed version\r\n\t\t// followed by the unprefixed version\r\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\r\n\r\n\t\t// Check if we're setting a value\r\n\t\tif ( value !== undefined ) {\r\n\t\t\ttype = typeof value;\r\n\r\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\r\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\r\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\r\n\t\t\t\t// Fixes bug #9237\r\n\t\t\t\ttype = \"number\";\r\n\t\t\t}\r\n\r\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\r\n\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\r\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\r\n\t\t\t\tvalue += \"px\";\r\n\t\t\t}\r\n\r\n\t\t\t// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\r\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\r\n\t\t\tif ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\r\n\t\t\t\tstyle[ name ] = \"inherit\";\r\n\t\t\t}\r\n\r\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\r\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\r\n\t\t\t\tstyle[ name ] = value;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t// If a hook was provided get the non-computed value from there\r\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise just get the value from the style object\r\n\t\t\treturn style[ name ];\r\n\t\t}\r\n\t},\r\n\r\n\tcss: function( elem, name, extra, styles ) {\r\n\t\tvar val, num, hooks,\r\n\t\t\torigName = jQuery.camelCase( name );\r\n\r\n\t\t// Make sure that we're working with the right name\r\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\r\n\r\n\t\t// gets hook for the prefixed version\r\n\t\t// followed by the unprefixed version\r\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\r\n\r\n\t\t// If a hook was provided get the computed value from there\r\n\t\tif ( hooks && \"get\" in hooks ) {\r\n\t\t\tval = hooks.get( elem, true, extra );\r\n\t\t}\r\n\r\n\t\t// Otherwise, if a way to get the computed value exists, use that\r\n\t\tif ( val === undefined ) {\r\n\t\t\tval = curCSS( elem, name, styles );\r\n\t\t}\r\n\r\n\t\t//convert \"normal\" to computed value\r\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\r\n\t\t\tval = cssNormalTransform[ name ];\r\n\t\t}\r\n\r\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\r\n\t\tif ( extra === \"\" || extra ) {\r\n\t\t\tnum = parseFloat( val );\r\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\r\n\t\t}\r\n\t\treturn val;\r\n\t}\r\n});\r\n\r\ncurCSS = function( elem, name, _computed ) {\r\n\tvar width, minWidth, maxWidth,\r\n\t\tcomputed = _computed || getStyles( elem ),\r\n\r\n\t\t// Support: IE9\r\n\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\r\n\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\r\n\t\tstyle = elem.style;\r\n\r\n\tif ( computed ) {\r\n\r\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\r\n\t\t\tret = jQuery.style( elem, name );\r\n\t\t}\r\n\r\n\t\t// Support: Safari 5.1\r\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\r\n\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\r\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\r\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\r\n\r\n\t\t\t// Remember the original values\r\n\t\t\twidth = style.width;\r\n\t\t\tminWidth = style.minWidth;\r\n\t\t\tmaxWidth = style.maxWidth;\r\n\r\n\t\t\t// Put in the new values to get a computed value out\r\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\r\n\t\t\tret = computed.width;\r\n\r\n\t\t\t// Revert the changed values\r\n\t\t\tstyle.width = width;\r\n\t\t\tstyle.minWidth = minWidth;\r\n\t\t\tstyle.maxWidth = maxWidth;\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n};\r\n\r\n\r\nfunction setPositiveNumber( elem, value, subtract ) {\r\n\tvar matches = rnumsplit.exec( value );\r\n\treturn matches ?\r\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\r\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\r\n\t\tvalue;\r\n}\r\n\r\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\r\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\r\n\t\t// If we already have the right measurement, avoid augmentation\r\n\t\t4 :\r\n\t\t// Otherwise initialize for horizontal or vertical properties\r\n\t\tname === \"width\" ? 1 : 0,\r\n\r\n\t\tval = 0;\r\n\r\n\tfor ( ; i < 4; i += 2 ) {\r\n\t\t// both box models exclude margin, so add it if we want it\r\n\t\tif ( extra === \"margin\" ) {\r\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\r\n\t\t}\r\n\r\n\t\tif ( isBorderBox ) {\r\n\t\t\t// border-box includes padding, so remove it if we want content\r\n\t\t\tif ( extra === \"content\" ) {\r\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\r\n\t\t\t}\r\n\r\n\t\t\t// at this point, extra isn't border nor margin, so remove border\r\n\t\t\tif ( extra !== \"margin\" ) {\r\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// at this point, extra isn't content, so add padding\r\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\r\n\r\n\t\t\t// at this point, extra isn't content nor padding, so add border\r\n\t\t\tif ( extra !== \"padding\" ) {\r\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn val;\r\n}\r\n\r\nfunction getWidthOrHeight( elem, name, extra ) {\r\n\r\n\t// Start with offset property, which is equivalent to the border-box value\r\n\tvar valueIsBorderBox = true,\r\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\r\n\t\tstyles = getStyles( elem ),\r\n\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\r\n\r\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\r\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\r\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\r\n\tif ( val <= 0 || val == null ) {\r\n\t\t// Fall back to computed then uncomputed css if necessary\r\n\t\tval = curCSS( elem, name, styles );\r\n\t\tif ( val < 0 || val == null ) {\r\n\t\t\tval = elem.style[ name ];\r\n\t\t}\r\n\r\n\t\t// Computed unit is not pixels. Stop here and return.\r\n\t\tif ( rnumnonpx.test(val) ) {\r\n\t\t\treturn val;\r\n\t\t}\r\n\r\n\t\t// we need the check for style in case a browser which returns unreliable values\r\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\r\n\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\r\n\r\n\t\t// Normalize \"\", auto, and prepare for extra\r\n\t\tval = parseFloat( val ) || 0;\r\n\t}\r\n\r\n\t// use the active box-sizing model to add/subtract irrelevant styles\r\n\treturn ( val +\r\n\t\taugmentWidthOrHeight(\r\n\t\t\telem,\r\n\t\t\tname,\r\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\r\n\t\t\tvalueIsBorderBox,\r\n\t\t\tstyles\r\n\t\t)\r\n\t) + \"px\";\r\n}\r\n\r\n// Try to determine the default display value of an element\r\nfunction css_defaultDisplay( nodeName ) {\r\n\tvar doc = document,\r\n\t\tdisplay = elemdisplay[ nodeName ];\r\n\r\n\tif ( !display ) {\r\n\t\tdisplay = actualDisplay( nodeName, doc );\r\n\r\n\t\t// If the simple way fails, read from inside an iframe\r\n\t\tif ( display === \"none\" || !display ) {\r\n\t\t\t// Use the already-created iframe if possible\r\n\t\t\tiframe = ( iframe ||\r\n\t\t\t\tjQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\r\n\t\t\t\t.css( \"cssText\", \"display:block !important\" )\r\n\t\t\t).appendTo( doc.documentElement );\r\n\r\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\r\n\t\t\tdoc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\r\n\t\t\tdoc.write(\"<!doctype html><html><body>\");\r\n\t\t\tdoc.close();\r\n\r\n\t\t\tdisplay = actualDisplay( nodeName, doc );\r\n\t\t\tiframe.detach();\r\n\t\t}\r\n\r\n\t\t// Store the correct default display\r\n\t\telemdisplay[ nodeName ] = display;\r\n\t}\r\n\r\n\treturn display;\r\n}\r\n\r\n// Called ONLY from within css_defaultDisplay\r\nfunction actualDisplay( name, doc ) {\r\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\r\n\t\tdisplay = jQuery.css( elem[0], \"display\" );\r\n\telem.remove();\r\n\treturn display;\r\n}\r\n\r\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\r\n\tjQuery.cssHooks[ name ] = {\r\n\t\tget: function( elem, computed, extra ) {\r\n\t\t\tif ( computed ) {\r\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\r\n\t\t\t\t// however, it must have a current display style that would benefit from this\r\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\r\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\r\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\r\n\t\t\t\t\t}) :\r\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tset: function( elem, value, extra ) {\r\n\t\t\tvar styles = extra && getStyles( elem );\r\n\t\t\treturn setPositiveNumber( elem, value, extra ?\r\n\t\t\t\taugmentWidthOrHeight(\r\n\t\t\t\t\telem,\r\n\t\t\t\t\tname,\r\n\t\t\t\t\textra,\r\n\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\r\n\t\t\t\t\tstyles\r\n\t\t\t\t) : 0\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n});\r\n\r\n// These hooks cannot be added until DOM ready because the support test\r\n// for it is not run until after DOM ready\r\njQuery(function() {\r\n\t// Support: Android 2.3\r\n\tif ( !jQuery.support.reliableMarginRight ) {\r\n\t\tjQuery.cssHooks.marginRight = {\r\n\t\t\tget: function( elem, computed ) {\r\n\t\t\t\tif ( computed ) {\r\n\t\t\t\t\t// Support: Android 2.3\r\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\r\n\t\t\t\t\t// Work around by temporarily setting element display to inline-block\r\n\t\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\r\n\t\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\r\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\r\n\t// rather than make the css module depend on the offset module, we just check for it here\r\n\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\r\n\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\r\n\t\t\tjQuery.cssHooks[ prop ] = {\r\n\t\t\t\tget: function( elem, computed ) {\r\n\t\t\t\t\tif ( computed ) {\r\n\t\t\t\t\t\tcomputed = curCSS( elem, prop );\r\n\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\r\n\t\t\t\t\t\treturn rnumnonpx.test( computed ) ?\r\n\t\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\r\n\t\t\t\t\t\t\tcomputed;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t});\r\n\t}\r\n\r\n});\r\n\r\nif ( jQuery.expr && jQuery.expr.filters ) {\r\n\tjQuery.expr.filters.hidden = function( elem ) {\r\n\t\t// Support: Opera <= 12.12\r\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\r\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\r\n\t};\r\n\r\n\tjQuery.expr.filters.visible = function( elem ) {\r\n\t\treturn !jQuery.expr.filters.hidden( elem );\r\n\t};\r\n}\r\n\r\n// These hooks are used by animate to expand properties\r\njQuery.each({\r\n\tmargin: \"\",\r\n\tpadding: \"\",\r\n\tborder: \"Width\"\r\n}, function( prefix, suffix ) {\r\n\tjQuery.cssHooks[ prefix + suffix ] = {\r\n\t\texpand: function( value ) {\r\n\t\t\tvar i = 0,\r\n\t\t\t\texpanded = {},\r\n\r\n\t\t\t\t// assumes a single number if not a string\r\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\r\n\r\n\t\t\tfor ( ; i < 4; i++ ) {\r\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\r\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\r\n\t\t\t}\r\n\r\n\t\t\treturn expanded;\r\n\t\t}\r\n\t};\r\n\r\n\tif ( !rmargin.test( prefix ) ) {\r\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\r\n\t}\r\n});\r\nvar r20 = /%20/g,\r\n\trbracket = /\\[\\]$/,\r\n\trCRLF = /\\r?\\n/g,\r\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\r\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\r\n\r\njQuery.fn.extend({\r\n\tserialize: function() {\r\n\t\treturn jQuery.param( this.serializeArray() );\r\n\t},\r\n\tserializeArray: function() {\r\n\t\treturn this.map(function(){\r\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\r\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\r\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\r\n\t\t})\r\n\t\t.filter(function(){\r\n\t\t\tvar type = this.type;\r\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\r\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\r\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\r\n\t\t\t\t( this.checked || !manipulation_rcheckableType.test( type ) );\r\n\t\t})\r\n\t\t.map(function( i, elem ){\r\n\t\t\tvar val = jQuery( this ).val();\r\n\r\n\t\t\treturn val == null ?\r\n\t\t\t\tnull :\r\n\t\t\t\tjQuery.isArray( val ) ?\r\n\t\t\t\t\tjQuery.map( val, function( val ){\r\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\r\n\t\t\t\t\t}) :\r\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\r\n\t\t}).get();\r\n\t}\r\n});\r\n\r\n//Serialize an array of form elements or a set of\r\n//key/values into a query string\r\njQuery.param = function( a, traditional ) {\r\n\tvar prefix,\r\n\t\ts = [],\r\n\t\tadd = function( key, value ) {\r\n\t\t\t// If value is a function, invoke it and return its value\r\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\r\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\r\n\t\t};\r\n\r\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\r\n\tif ( traditional === undefined ) {\r\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\r\n\t}\r\n\r\n\t// If an array was passed in, assume that it is an array of form elements.\r\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\r\n\t\t// Serialize the form elements\r\n\t\tjQuery.each( a, function() {\r\n\t\t\tadd( this.name, this.value );\r\n\t\t});\r\n\r\n\t} else {\r\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\r\n\t\t// did it), otherwise encode params recursively.\r\n\t\tfor ( prefix in a ) {\r\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the resulting serialization\r\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\r\n};\r\n\r\nfunction buildParams( prefix, obj, traditional, add ) {\r\n\tvar name;\r\n\r\n\tif ( jQuery.isArray( obj ) ) {\r\n\t\t// Serialize array item.\r\n\t\tjQuery.each( obj, function( i, v ) {\r\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\r\n\t\t\t\t// Treat each array item as a scalar.\r\n\t\t\t\tadd( prefix, v );\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\r\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\r\n\t\t// Serialize object item.\r\n\t\tfor ( name in obj ) {\r\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\r\n\t\t}\r\n\r\n\t} else {\r\n\t\t// Serialize scalar item.\r\n\t\tadd( prefix, obj );\r\n\t}\r\n}\r\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\r\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\r\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\r\n\r\n\t// Handle event binding\r\n\tjQuery.fn[ name ] = function( data, fn ) {\r\n\t\treturn arguments.length > 0 ?\r\n\t\t\tthis.on( name, null, data, fn ) :\r\n\t\t\tthis.trigger( name );\r\n\t};\r\n});\r\n\r\njQuery.fn.extend({\r\n\thover: function( fnOver, fnOut ) {\r\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\r\n\t},\r\n\r\n\tbind: function( types, data, fn ) {\r\n\t\treturn this.on( types, null, data, fn );\r\n\t},\r\n\tunbind: function( types, fn ) {\r\n\t\treturn this.off( types, null, fn );\r\n\t},\r\n\r\n\tdelegate: function( selector, types, data, fn ) {\r\n\t\treturn this.on( types, selector, data, fn );\r\n\t},\r\n\tundelegate: function( selector, types, fn ) {\r\n\t\t// ( namespace ) or ( selector, types [, fn] )\r\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\r\n\t}\r\n});\r\nvar\r\n\t// Document location\r\n\tajaxLocParts,\r\n\tajaxLocation,\r\n\r\n\tajax_nonce = jQuery.now(),\r\n\r\n\tajax_rquery = /\\?/,\r\n\trhash = /#.*$/,\r\n\trts = /([?&])_=[^&]*/,\r\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\r\n\t// #7653, #8125, #8152: local protocol detection\r\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\r\n\trnoContent = /^(?:GET|HEAD)$/,\r\n\trprotocol = /^\\/\\//,\r\n\trurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\r\n\r\n\t// Keep a copy of the old load method\r\n\t_load = jQuery.fn.load,\r\n\r\n\t/* Prefilters\r\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\r\n\t * 2) These are called:\r\n\t *    - BEFORE asking for a transport\r\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\r\n\t * 3) key is the dataType\r\n\t * 4) the catchall symbol \"*\" can be used\r\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\r\n\t */\r\n\tprefilters = {},\r\n\r\n\t/* Transports bindings\r\n\t * 1) key is the dataType\r\n\t * 2) the catchall symbol \"*\" can be used\r\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\r\n\t */\r\n\ttransports = {},\r\n\r\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\r\n\tallTypes = \"*/\".concat(\"*\");\r\n\r\n// #8138, IE may throw an exception when accessing\r\n// a field from window.location if document.domain has been set\r\ntry {\r\n\tajaxLocation = location.href;\r\n} catch( e ) {\r\n\t// Use the href attribute of an A element\r\n\t// since IE will modify it given document.location\r\n\tajaxLocation = document.createElement( \"a\" );\r\n\tajaxLocation.href = \"\";\r\n\tajaxLocation = ajaxLocation.href;\r\n}\r\n\r\n// Segment location into parts\r\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\r\n\r\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\r\nfunction addToPrefiltersOrTransports( structure ) {\r\n\r\n\t// dataTypeExpression is optional and defaults to \"*\"\r\n\treturn function( dataTypeExpression, func ) {\r\n\r\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\r\n\t\t\tfunc = dataTypeExpression;\r\n\t\t\tdataTypeExpression = \"*\";\r\n\t\t}\r\n\r\n\t\tvar dataType,\r\n\t\t\ti = 0,\r\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\r\n\r\n\t\tif ( jQuery.isFunction( func ) ) {\r\n\t\t\t// For each dataType in the dataTypeExpression\r\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\r\n\t\t\t\t// Prepend if requested\r\n\t\t\t\tif ( dataType[0] === \"+\" ) {\r\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\r\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\r\n\r\n\t\t\t\t// Otherwise append\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n// Base inspection function for prefilters and transports\r\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\r\n\r\n\tvar inspected = {},\r\n\t\tseekingTransport = ( structure === transports );\r\n\r\n\tfunction inspect( dataType ) {\r\n\t\tvar selected;\r\n\t\tinspected[ dataType ] = true;\r\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\r\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\r\n\t\t\tif( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\r\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\r\n\t\t\t\tinspect( dataTypeOrTransport );\r\n\t\t\t\treturn false;\r\n\t\t\t} else if ( seekingTransport ) {\r\n\t\t\t\treturn !( selected = dataTypeOrTransport );\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn selected;\r\n\t}\r\n\r\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\r\n}\r\n\r\n// A special extend for ajax options\r\n// that takes \"flat\" options (not to be deep extended)\r\n// Fixes #9887\r\nfunction ajaxExtend( target, src ) {\r\n\tvar key, deep,\r\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\r\n\r\n\tfor ( key in src ) {\r\n\t\tif ( src[ key ] !== undefined ) {\r\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\r\n\t\t}\r\n\t}\r\n\tif ( deep ) {\r\n\t\tjQuery.extend( true, target, deep );\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\njQuery.fn.load = function( url, params, callback ) {\r\n\tif ( typeof url !== \"string\" && _load ) {\r\n\t\treturn _load.apply( this, arguments );\r\n\t}\r\n\r\n\tvar selector, type, response,\r\n\t\tself = this,\r\n\t\toff = url.indexOf(\" \");\r\n\r\n\tif ( off >= 0 ) {\r\n\t\tselector = url.slice( off );\r\n\t\turl = url.slice( 0, off );\r\n\t}\r\n\r\n\t// If it's a function\r\n\tif ( jQuery.isFunction( params ) ) {\r\n\r\n\t\t// We assume that it's the callback\r\n\t\tcallback = params;\r\n\t\tparams = undefined;\r\n\r\n\t// Otherwise, build a param string\r\n\t} else if ( params && typeof params === \"object\" ) {\r\n\t\ttype = \"POST\";\r\n\t}\r\n\r\n\t// If we have elements to modify, make the request\r\n\tif ( self.length > 0 ) {\r\n\t\tjQuery.ajax({\r\n\t\t\turl: url,\r\n\r\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\r\n\t\t\ttype: type,\r\n\t\t\tdataType: \"html\",\r\n\t\t\tdata: params\r\n\t\t}).done(function( responseText ) {\r\n\r\n\t\t\t// Save response for use in complete callback\r\n\t\t\tresponse = arguments;\r\n\r\n\t\t\tself.html( selector ?\r\n\r\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\r\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\r\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\r\n\r\n\t\t\t\t// Otherwise use the full result\r\n\t\t\t\tresponseText );\r\n\r\n\t\t}).complete( callback && function( jqXHR, status ) {\r\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\r\n\t\t});\r\n\t}\r\n\r\n\treturn this;\r\n};\r\n\r\n// Attach a bunch of functions for handling common AJAX events\r\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\r\n\tjQuery.fn[ type ] = function( fn ){\r\n\t\treturn this.on( type, fn );\r\n\t};\r\n});\r\n\r\njQuery.extend({\r\n\r\n\t// Counter for holding the number of active queries\r\n\tactive: 0,\r\n\r\n\t// Last-Modified header cache for next request\r\n\tlastModified: {},\r\n\tetag: {},\r\n\r\n\tajaxSettings: {\r\n\t\turl: ajaxLocation,\r\n\t\ttype: \"GET\",\r\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\r\n\t\tglobal: true,\r\n\t\tprocessData: true,\r\n\t\tasync: true,\r\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n\t\t/*\r\n\t\ttimeout: 0,\r\n\t\tdata: null,\r\n\t\tdataType: null,\r\n\t\tusername: null,\r\n\t\tpassword: null,\r\n\t\tcache: null,\r\n\t\tthrows: false,\r\n\t\ttraditional: false,\r\n\t\theaders: {},\r\n\t\t*/\r\n\r\n\t\taccepts: {\r\n\t\t\t\"*\": allTypes,\r\n\t\t\ttext: \"text/plain\",\r\n\t\t\thtml: \"text/html\",\r\n\t\t\txml: \"application/xml, text/xml\",\r\n\t\t\tjson: \"application/json, text/javascript\"\r\n\t\t},\r\n\r\n\t\tcontents: {\r\n\t\t\txml: /xml/,\r\n\t\t\thtml: /html/,\r\n\t\t\tjson: /json/\r\n\t\t},\r\n\r\n\t\tresponseFields: {\r\n\t\t\txml: \"responseXML\",\r\n\t\t\ttext: \"responseText\",\r\n\t\t\tjson: \"responseJSON\"\r\n\t\t},\r\n\r\n\t\t// Data converters\r\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\r\n\t\tconverters: {\r\n\r\n\t\t\t// Convert anything to text\r\n\t\t\t\"* text\": String,\r\n\r\n\t\t\t// Text to html (true = no transformation)\r\n\t\t\t\"text html\": true,\r\n\r\n\t\t\t// Evaluate text as a json expression\r\n\t\t\t\"text json\": jQuery.parseJSON,\r\n\r\n\t\t\t// Parse text as xml\r\n\t\t\t\"text xml\": jQuery.parseXML\r\n\t\t},\r\n\r\n\t\t// For options that shouldn't be deep extended:\r\n\t\t// you can add your own custom options here if\r\n\t\t// and when you create one that shouldn't be\r\n\t\t// deep extended (see ajaxExtend)\r\n\t\tflatOptions: {\r\n\t\t\turl: true,\r\n\t\t\tcontext: true\r\n\t\t}\r\n\t},\r\n\r\n\t// Creates a full fledged settings object into target\r\n\t// with both ajaxSettings and settings fields.\r\n\t// If target is omitted, writes into ajaxSettings.\r\n\tajaxSetup: function( target, settings ) {\r\n\t\treturn settings ?\r\n\r\n\t\t\t// Building a settings object\r\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\r\n\r\n\t\t\t// Extending ajaxSettings\r\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\r\n\t},\r\n\r\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\r\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\r\n\r\n\t// Main method\r\n\tajax: function( url, options ) {\r\n\r\n\t\t// If url is an object, simulate pre-1.5 signature\r\n\t\tif ( typeof url === \"object\" ) {\r\n\t\t\toptions = url;\r\n\t\t\turl = undefined;\r\n\t\t}\r\n\r\n\t\t// Force options to be an object\r\n\t\toptions = options || {};\r\n\r\n\t\tvar transport,\r\n\t\t\t// URL without anti-cache param\r\n\t\t\tcacheURL,\r\n\t\t\t// Response headers\r\n\t\t\tresponseHeadersString,\r\n\t\t\tresponseHeaders,\r\n\t\t\t// timeout handle\r\n\t\t\ttimeoutTimer,\r\n\t\t\t// Cross-domain detection vars\r\n\t\t\tparts,\r\n\t\t\t// To know if global events are to be dispatched\r\n\t\t\tfireGlobals,\r\n\t\t\t// Loop variable\r\n\t\t\ti,\r\n\t\t\t// Create the final options object\r\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\r\n\t\t\t// Callbacks context\r\n\t\t\tcallbackContext = s.context || s,\r\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\r\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\r\n\t\t\t\tjQuery( callbackContext ) :\r\n\t\t\t\tjQuery.event,\r\n\t\t\t// Deferreds\r\n\t\t\tdeferred = jQuery.Deferred(),\r\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\r\n\t\t\t// Status-dependent callbacks\r\n\t\t\tstatusCode = s.statusCode || {},\r\n\t\t\t// Headers (they are sent all at once)\r\n\t\t\trequestHeaders = {},\r\n\t\t\trequestHeadersNames = {},\r\n\t\t\t// The jqXHR state\r\n\t\t\tstate = 0,\r\n\t\t\t// Default abort message\r\n\t\t\tstrAbort = \"canceled\",\r\n\t\t\t// Fake xhr\r\n\t\t\tjqXHR = {\r\n\t\t\t\treadyState: 0,\r\n\r\n\t\t\t\t// Builds headers hashtable if needed\r\n\t\t\t\tgetResponseHeader: function( key ) {\r\n\t\t\t\t\tvar match;\r\n\t\t\t\t\tif ( state === 2 ) {\r\n\t\t\t\t\t\tif ( !responseHeaders ) {\r\n\t\t\t\t\t\t\tresponseHeaders = {};\r\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\r\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn match == null ? null : match;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Raw string\r\n\t\t\t\tgetAllResponseHeaders: function() {\r\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Caches the header\r\n\t\t\t\tsetRequestHeader: function( name, value ) {\r\n\t\t\t\t\tvar lname = name.toLowerCase();\r\n\t\t\t\t\tif ( !state ) {\r\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\r\n\t\t\t\t\t\trequestHeaders[ name ] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Overrides response content-type header\r\n\t\t\t\toverrideMimeType: function( type ) {\r\n\t\t\t\t\tif ( !state ) {\r\n\t\t\t\t\t\ts.mimeType = type;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Status-dependent callbacks\r\n\t\t\t\tstatusCode: function( map ) {\r\n\t\t\t\t\tvar code;\r\n\t\t\t\t\tif ( map ) {\r\n\t\t\t\t\t\tif ( state < 2 ) {\r\n\t\t\t\t\t\t\tfor ( code in map ) {\r\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\r\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\r\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Cancel the request\r\n\t\t\t\tabort: function( statusText ) {\r\n\t\t\t\t\tvar finalText = statusText || strAbort;\r\n\t\t\t\t\tif ( transport ) {\r\n\t\t\t\t\t\ttransport.abort( finalText );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdone( 0, finalText );\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t// Attach deferreds\r\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\r\n\t\tjqXHR.success = jqXHR.done;\r\n\t\tjqXHR.error = jqXHR.fail;\r\n\r\n\t\t// Remove hash character (#7531: and string promotion)\r\n\t\t// Add protocol if not provided (prefilters might expect it)\r\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\r\n\t\t// We also use the url parameter if available\r\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\r\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\r\n\r\n\t\t// Alias method option to type as per ticket #12004\r\n\t\ts.type = options.method || options.type || s.method || s.type;\r\n\r\n\t\t// Extract dataTypes list\r\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\r\n\r\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\r\n\t\tif ( s.crossDomain == null ) {\r\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\r\n\t\t\ts.crossDomain = !!( parts &&\r\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\r\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\r\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Convert data if not already a string\r\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\r\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\r\n\t\t}\r\n\r\n\t\t// Apply prefilters\r\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\r\n\r\n\t\t// If request was aborted inside a prefilter, stop there\r\n\t\tif ( state === 2 ) {\r\n\t\t\treturn jqXHR;\r\n\t\t}\r\n\r\n\t\t// We can fire global events as of now if asked to\r\n\t\tfireGlobals = s.global;\r\n\r\n\t\t// Watch for a new set of requests\r\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\r\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\r\n\t\t}\r\n\r\n\t\t// Uppercase the type\r\n\t\ts.type = s.type.toUpperCase();\r\n\r\n\t\t// Determine if request has content\r\n\t\ts.hasContent = !rnoContent.test( s.type );\r\n\r\n\t\t// Save the URL in case we're toying with the If-Modified-Since\r\n\t\t// and/or If-None-Match header later on\r\n\t\tcacheURL = s.url;\r\n\r\n\t\t// More options handling for requests with no content\r\n\t\tif ( !s.hasContent ) {\r\n\r\n\t\t\t// If data is available, append data to url\r\n\t\t\tif ( s.data ) {\r\n\t\t\t\tcacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\r\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\r\n\t\t\t\tdelete s.data;\r\n\t\t\t}\r\n\r\n\t\t\t// Add anti-cache in url if needed\r\n\t\t\tif ( s.cache === false ) {\r\n\t\t\t\ts.url = rts.test( cacheURL ) ?\r\n\r\n\t\t\t\t\t// If there is already a '_' parameter, set its value\r\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\r\n\r\n\t\t\t\t\t// Otherwise add one to the end\r\n\t\t\t\t\tcacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n\t\tif ( s.ifModified ) {\r\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\r\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\r\n\t\t\t}\r\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\r\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set the correct header, if data is being sent\r\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\r\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\r\n\t\t}\r\n\r\n\t\t// Set the Accepts header for the server, depending on the dataType\r\n\t\tjqXHR.setRequestHeader(\r\n\t\t\t\"Accept\",\r\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\r\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\r\n\t\t\t\ts.accepts[ \"*\" ]\r\n\t\t);\r\n\r\n\t\t// Check for headers option\r\n\t\tfor ( i in s.headers ) {\r\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\r\n\t\t}\r\n\r\n\t\t// Allow custom headers/mimetypes and early abort\r\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\r\n\t\t\t// Abort if not done already and return\r\n\t\t\treturn jqXHR.abort();\r\n\t\t}\r\n\r\n\t\t// aborting is no longer a cancellation\r\n\t\tstrAbort = \"abort\";\r\n\r\n\t\t// Install callbacks on deferreds\r\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\r\n\t\t\tjqXHR[ i ]( s[ i ] );\r\n\t\t}\r\n\r\n\t\t// Get transport\r\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\r\n\r\n\t\t// If no transport, we auto-abort\r\n\t\tif ( !transport ) {\r\n\t\t\tdone( -1, \"No Transport\" );\r\n\t\t} else {\r\n\t\t\tjqXHR.readyState = 1;\r\n\r\n\t\t\t// Send global event\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\r\n\t\t\t}\r\n\t\t\t// Timeout\r\n\t\t\tif ( s.async && s.timeout > 0 ) {\r\n\t\t\t\ttimeoutTimer = setTimeout(function() {\r\n\t\t\t\t\tjqXHR.abort(\"timeout\");\r\n\t\t\t\t}, s.timeout );\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\t\t\t\tstate = 1;\r\n\t\t\t\ttransport.send( requestHeaders, done );\r\n\t\t\t} catch ( e ) {\r\n\t\t\t\t// Propagate exception as error if not done\r\n\t\t\t\tif ( state < 2 ) {\r\n\t\t\t\t\tdone( -1, e );\r\n\t\t\t\t// Simply rethrow otherwise\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Callback for when everything is done\r\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\r\n\t\t\tvar isSuccess, success, error, response, modified,\r\n\t\t\t\tstatusText = nativeStatusText;\r\n\r\n\t\t\t// Called once\r\n\t\t\tif ( state === 2 ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// State is \"done\" now\r\n\t\t\tstate = 2;\r\n\r\n\t\t\t// Clear timeout if it exists\r\n\t\t\tif ( timeoutTimer ) {\r\n\t\t\t\tclearTimeout( timeoutTimer );\r\n\t\t\t}\r\n\r\n\t\t\t// Dereference transport for early garbage collection\r\n\t\t\t// (no matter how long the jqXHR object will be used)\r\n\t\t\ttransport = undefined;\r\n\r\n\t\t\t// Cache response headers\r\n\t\t\tresponseHeadersString = headers || \"\";\r\n\r\n\t\t\t// Set readyState\r\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\r\n\r\n\t\t\t// Determine if successful\r\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\r\n\r\n\t\t\t// Get response data\r\n\t\t\tif ( responses ) {\r\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\r\n\t\t\t}\r\n\r\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\r\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\r\n\r\n\t\t\t// If successful, handle type chaining\r\n\t\t\tif ( isSuccess ) {\r\n\r\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n\t\t\t\tif ( s.ifModified ) {\r\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\r\n\t\t\t\t\tif ( modified ) {\r\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\r\n\t\t\t\t\tif ( modified ) {\r\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if no content\r\n\t\t\t\tif ( status === 204 ) {\r\n\t\t\t\t\tstatusText = \"nocontent\";\r\n\r\n\t\t\t\t// if not modified\r\n\t\t\t\t} else if ( status === 304 ) {\r\n\t\t\t\t\tstatusText = \"notmodified\";\r\n\r\n\t\t\t\t// If we have data, let's convert it\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstatusText = response.state;\r\n\t\t\t\t\tsuccess = response.data;\r\n\t\t\t\t\terror = response.error;\r\n\t\t\t\t\tisSuccess = !error;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// We extract error from statusText\r\n\t\t\t\t// then normalize statusText and status for non-aborts\r\n\t\t\t\terror = statusText;\r\n\t\t\t\tif ( status || !statusText ) {\r\n\t\t\t\t\tstatusText = \"error\";\r\n\t\t\t\t\tif ( status < 0 ) {\r\n\t\t\t\t\t\tstatus = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Set data for the fake xhr object\r\n\t\t\tjqXHR.status = status;\r\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\r\n\r\n\t\t\t// Success/Error\r\n\t\t\tif ( isSuccess ) {\r\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\r\n\t\t\t} else {\r\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\r\n\t\t\t}\r\n\r\n\t\t\t// Status-dependent callbacks\r\n\t\t\tjqXHR.statusCode( statusCode );\r\n\t\t\tstatusCode = undefined;\r\n\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\r\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\r\n\t\t\t}\r\n\r\n\t\t\t// Complete\r\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\r\n\r\n\t\t\tif ( fireGlobals ) {\r\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\r\n\t\t\t\t// Handle the global AJAX counter\r\n\t\t\t\tif ( !( --jQuery.active ) ) {\r\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn jqXHR;\r\n\t},\r\n\r\n\tgetJSON: function( url, data, callback ) {\r\n\t\treturn jQuery.get( url, data, callback, \"json\" );\r\n\t},\r\n\r\n\tgetScript: function( url, callback ) {\r\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\r\n\t}\r\n});\r\n\r\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\r\n\tjQuery[ method ] = function( url, data, callback, type ) {\r\n\t\t// shift arguments if data argument was omitted\r\n\t\tif ( jQuery.isFunction( data ) ) {\r\n\t\t\ttype = type || callback;\r\n\t\t\tcallback = data;\r\n\t\t\tdata = undefined;\r\n\t\t}\r\n\r\n\t\treturn jQuery.ajax({\r\n\t\t\turl: url,\r\n\t\t\ttype: method,\r\n\t\t\tdataType: type,\r\n\t\t\tdata: data,\r\n\t\t\tsuccess: callback\r\n\t\t});\r\n\t};\r\n});\r\n\r\n/* Handles responses to an ajax request:\r\n * - finds the right dataType (mediates between content-type and expected dataType)\r\n * - returns the corresponding response\r\n */\r\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\r\n\r\n\tvar ct, type, finalDataType, firstDataType,\r\n\t\tcontents = s.contents,\r\n\t\tdataTypes = s.dataTypes;\r\n\r\n\t// Remove auto dataType and get content-type in the process\r\n\twhile( dataTypes[ 0 ] === \"*\" ) {\r\n\t\tdataTypes.shift();\r\n\t\tif ( ct === undefined ) {\r\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Check if we're dealing with a known content-type\r\n\tif ( ct ) {\r\n\t\tfor ( type in contents ) {\r\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\r\n\t\t\t\tdataTypes.unshift( type );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Check to see if we have a response for the expected dataType\r\n\tif ( dataTypes[ 0 ] in responses ) {\r\n\t\tfinalDataType = dataTypes[ 0 ];\r\n\t} else {\r\n\t\t// Try convertible dataTypes\r\n\t\tfor ( type in responses ) {\r\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\r\n\t\t\t\tfinalDataType = type;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif ( !firstDataType ) {\r\n\t\t\t\tfirstDataType = type;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Or just use first one\r\n\t\tfinalDataType = finalDataType || firstDataType;\r\n\t}\r\n\r\n\t// If we found a dataType\r\n\t// We add the dataType to the list if needed\r\n\t// and return the corresponding response\r\n\tif ( finalDataType ) {\r\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\r\n\t\t\tdataTypes.unshift( finalDataType );\r\n\t\t}\r\n\t\treturn responses[ finalDataType ];\r\n\t}\r\n}\r\n\r\n/* Chain conversions given the request and the original response\r\n * Also sets the responseXXX fields on the jqXHR instance\r\n */\r\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\r\n\tvar conv2, current, conv, tmp, prev,\r\n\t\tconverters = {},\r\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\r\n\t\tdataTypes = s.dataTypes.slice();\r\n\r\n\t// Create converters map with lowercased keys\r\n\tif ( dataTypes[ 1 ] ) {\r\n\t\tfor ( conv in s.converters ) {\r\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\r\n\t\t}\r\n\t}\r\n\r\n\tcurrent = dataTypes.shift();\r\n\r\n\t// Convert to each sequential dataType\r\n\twhile ( current ) {\r\n\r\n\t\tif ( s.responseFields[ current ] ) {\r\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\r\n\t\t}\r\n\r\n\t\t// Apply the dataFilter if provided\r\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\r\n\t\t\tresponse = s.dataFilter( response, s.dataType );\r\n\t\t}\r\n\r\n\t\tprev = current;\r\n\t\tcurrent = dataTypes.shift();\r\n\r\n\t\tif ( current ) {\r\n\r\n\t\t// There's only work to do if current dataType is non-auto\r\n\t\t\tif ( current === \"*\" ) {\r\n\r\n\t\t\t\tcurrent = prev;\r\n\r\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\r\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\r\n\r\n\t\t\t\t// Seek a direct converter\r\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\r\n\r\n\t\t\t\t// If none found, seek a pair\r\n\t\t\t\tif ( !conv ) {\r\n\t\t\t\t\tfor ( conv2 in converters ) {\r\n\r\n\t\t\t\t\t\t// If conv2 outputs current\r\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\r\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\r\n\r\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\r\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\r\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\r\n\t\t\t\t\t\t\tif ( conv ) {\r\n\t\t\t\t\t\t\t\t// Condense equivalence converters\r\n\t\t\t\t\t\t\t\tif ( conv === true ) {\r\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\r\n\r\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\r\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\r\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\r\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Apply converter (if not an equivalence)\r\n\t\t\t\tif ( conv !== true ) {\r\n\r\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\r\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\r\n\t\t\t\t\t\tresponse = conv( response );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tresponse = conv( response );\r\n\t\t\t\t\t\t} catch ( e ) {\r\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { state: \"success\", data: response };\r\n}\r\n// Install script dataType\r\njQuery.ajaxSetup({\r\n\taccepts: {\r\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\r\n\t},\r\n\tcontents: {\r\n\t\tscript: /(?:java|ecma)script/\r\n\t},\r\n\tconverters: {\r\n\t\t\"text script\": function( text ) {\r\n\t\t\tjQuery.globalEval( text );\r\n\t\t\treturn text;\r\n\t\t}\r\n\t}\r\n});\r\n\r\n// Handle cache's special case and crossDomain\r\njQuery.ajaxPrefilter( \"script\", function( s ) {\r\n\tif ( s.cache === undefined ) {\r\n\t\ts.cache = false;\r\n\t}\r\n\tif ( s.crossDomain ) {\r\n\t\ts.type = \"GET\";\r\n\t}\r\n});\r\n\r\n// Bind script tag hack transport\r\njQuery.ajaxTransport( \"script\", function( s ) {\r\n\t// This transport only deals with cross domain requests\r\n\tif ( s.crossDomain ) {\r\n\t\tvar script, callback;\r\n\t\treturn {\r\n\t\t\tsend: function( _, complete ) {\r\n\t\t\t\tscript = jQuery(\"<script>\").prop({\r\n\t\t\t\t\tasync: true,\r\n\t\t\t\t\tcharset: s.scriptCharset,\r\n\t\t\t\t\tsrc: s.url\r\n\t\t\t\t}).on(\r\n\t\t\t\t\t\"load error\",\r\n\t\t\t\t\tcallback = function( evt ) {\r\n\t\t\t\t\t\tscript.remove();\r\n\t\t\t\t\t\tcallback = null;\r\n\t\t\t\t\t\tif ( evt ) {\r\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\r\n\t\t\t},\r\n\t\t\tabort: function() {\r\n\t\t\t\tif ( callback ) {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n});\r\nvar oldCallbacks = [],\r\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\r\n\r\n// Default jsonp settings\r\njQuery.ajaxSetup({\r\n\tjsonp: \"callback\",\r\n\tjsonpCallback: function() {\r\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\r\n\t\tthis[ callback ] = true;\r\n\t\treturn callback;\r\n\t}\r\n});\r\n\r\n// Detect, normalize options and install callbacks for jsonp requests\r\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\r\n\r\n\tvar callbackName, overwritten, responseContainer,\r\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\r\n\t\t\t\"url\" :\r\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\r\n\t\t);\r\n\r\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\r\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\r\n\r\n\t\t// Get callback name, remembering preexisting value associated with it\r\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\r\n\t\t\ts.jsonpCallback() :\r\n\t\t\ts.jsonpCallback;\r\n\r\n\t\t// Insert callback into url or form data\r\n\t\tif ( jsonProp ) {\r\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\r\n\t\t} else if ( s.jsonp !== false ) {\r\n\t\t\ts.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\r\n\t\t}\r\n\r\n\t\t// Use data converter to retrieve json after script execution\r\n\t\ts.converters[\"script json\"] = function() {\r\n\t\t\tif ( !responseContainer ) {\r\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\r\n\t\t\t}\r\n\t\t\treturn responseContainer[ 0 ];\r\n\t\t};\r\n\r\n\t\t// force json dataType\r\n\t\ts.dataTypes[ 0 ] = \"json\";\r\n\r\n\t\t// Install callback\r\n\t\toverwritten = window[ callbackName ];\r\n\t\twindow[ callbackName ] = function() {\r\n\t\t\tresponseContainer = arguments;\r\n\t\t};\r\n\r\n\t\t// Clean-up function (fires after converters)\r\n\t\tjqXHR.always(function() {\r\n\t\t\t// Restore preexisting value\r\n\t\t\twindow[ callbackName ] = overwritten;\r\n\r\n\t\t\t// Save back as free\r\n\t\t\tif ( s[ callbackName ] ) {\r\n\t\t\t\t// make sure that re-using the options doesn't screw things around\r\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\r\n\r\n\t\t\t\t// save the callback name for future use\r\n\t\t\t\toldCallbacks.push( callbackName );\r\n\t\t\t}\r\n\r\n\t\t\t// Call if it was a function and we have a response\r\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\r\n\t\t\t\toverwritten( responseContainer[ 0 ] );\r\n\t\t\t}\r\n\r\n\t\t\tresponseContainer = overwritten = undefined;\r\n\t\t});\r\n\r\n\t\t// Delegate to script\r\n\t\treturn \"script\";\r\n\t}\r\n});\r\njQuery.ajaxSettings.xhr = function() {\r\n\ttry {\r\n\t\treturn new XMLHttpRequest();\r\n\t} catch( e ) {}\r\n};\r\n\r\nvar xhrSupported = jQuery.ajaxSettings.xhr(),\r\n\txhrSuccessStatus = {\r\n\t\t// file protocol always yields status code 0, assume 200\r\n\t\t0: 200,\r\n\t\t// Support: IE9\r\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\r\n\t\t1223: 204\r\n\t},\r\n\t// Support: IE9\r\n\t// We need to keep track of outbound xhr and abort them manually\r\n\t// because IE is not smart enough to do it all by itself\r\n\txhrId = 0,\r\n\txhrCallbacks = {};\r\n\r\nif ( window.ActiveXObject ) {\r\n\tjQuery( window ).on( \"unload\", function() {\r\n\t\tfor( var key in xhrCallbacks ) {\r\n\t\t\txhrCallbacks[ key ]();\r\n\t\t}\r\n\t\txhrCallbacks = undefined;\r\n\t});\r\n}\r\n\r\njQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\r\njQuery.support.ajax = xhrSupported = !!xhrSupported;\r\n\r\njQuery.ajaxTransport(function( options ) {\r\n\tvar callback;\r\n\t// Cross domain only allowed if supported through XMLHttpRequest\r\n\tif ( jQuery.support.cors || xhrSupported && !options.crossDomain ) {\r\n\t\treturn {\r\n\t\t\tsend: function( headers, complete ) {\r\n\t\t\t\tvar i, id,\r\n\t\t\t\t\txhr = options.xhr();\r\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\r\n\t\t\t\t// Apply custom fields if provided\r\n\t\t\t\tif ( options.xhrFields ) {\r\n\t\t\t\t\tfor ( i in options.xhrFields ) {\r\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Override mime type if needed\r\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\r\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\r\n\t\t\t\t}\r\n\t\t\t\t// X-Requested-With header\r\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\r\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\r\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\r\n\t\t\t\t// For same-domain requests, won't change header if already provided.\r\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\r\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\r\n\t\t\t\t}\r\n\t\t\t\t// Set headers\r\n\t\t\t\tfor ( i in headers ) {\r\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\r\n\t\t\t\t}\r\n\t\t\t\t// Callback\r\n\t\t\t\tcallback = function( type ) {\r\n\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\tif ( callback ) {\r\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\r\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\r\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\r\n\t\t\t\t\t\t\t\txhr.abort();\r\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\r\n\t\t\t\t\t\t\t\tcomplete(\r\n\t\t\t\t\t\t\t\t\t// file protocol always yields status 0, assume 404\r\n\t\t\t\t\t\t\t\t\txhr.status || 404,\r\n\t\t\t\t\t\t\t\t\txhr.statusText\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcomplete(\r\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\r\n\t\t\t\t\t\t\t\t\txhr.statusText,\r\n\t\t\t\t\t\t\t\t\t// Support: IE9\r\n\t\t\t\t\t\t\t\t\t// #11426: When requesting binary data, IE9 will throw an exception\r\n\t\t\t\t\t\t\t\t\t// on any attempt to access responseText\r\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\r\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\r\n\t\t\t\t\t\t\t\t\t} : undefined,\r\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\t\t\t\t// Listen to events\r\n\t\t\t\txhr.onload = callback();\r\n\t\t\t\txhr.onerror = callback(\"error\");\r\n\t\t\t\t// Create the abort callback\r\n\t\t\t\tcallback = xhrCallbacks[( id = xhrId++ )] = callback(\"abort\");\r\n\t\t\t\t// Do send the request\r\n\t\t\t\t// This may raise an exception which is actually\r\n\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\r\n\t\t\t\txhr.send( options.hasContent && options.data || null );\r\n\t\t\t},\r\n\t\t\tabort: function() {\r\n\t\t\t\tif ( callback ) {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n});\r\nvar fxNow, timerId,\r\n\trfxtypes = /^(?:toggle|show|hide)$/,\r\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\r\n\trrun = /queueHooks$/,\r\n\tanimationPrefilters = [ defaultPrefilter ],\r\n\ttweeners = {\r\n\t\t\"*\": [function( prop, value ) {\r\n\t\t\tvar end, unit,\r\n\t\t\t\ttween = this.createTween( prop, value ),\r\n\t\t\t\tparts = rfxnum.exec( value ),\r\n\t\t\t\ttarget = tween.cur(),\r\n\t\t\t\tstart = +target || 0,\r\n\t\t\t\tscale = 1,\r\n\t\t\t\tmaxIterations = 20;\r\n\r\n\t\t\tif ( parts ) {\r\n\t\t\t\tend = +parts[2];\r\n\t\t\t\tunit = parts[3] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\r\n\r\n\t\t\t\t// We need to compute starting value\r\n\t\t\t\tif ( unit !== \"px\" && start ) {\r\n\t\t\t\t\t// Iteratively approximate from a nonzero starting point\r\n\t\t\t\t\t// Prefer the current property, because this process will be trivial if it uses the same units\r\n\t\t\t\t\t// Fallback to end or a simple constant\r\n\t\t\t\t\tstart = jQuery.css( tween.elem, prop, true ) || end || 1;\r\n\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\r\n\t\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\r\n\t\t\t\t\t\tscale = scale || \".5\";\r\n\r\n\t\t\t\t\t\t// Adjust and apply\r\n\t\t\t\t\t\tstart = start / scale;\r\n\t\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\r\n\r\n\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\r\n\t\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\r\n\t\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttween.unit = unit;\r\n\t\t\t\ttween.start = start;\r\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\r\n\t\t\t\ttween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;\r\n\t\t\t}\r\n\t\t\treturn tween;\r\n\t\t}]\r\n\t};\r\n\r\n// Animations created synchronously will run synchronously\r\nfunction createFxNow() {\r\n\tsetTimeout(function() {\r\n\t\tfxNow = undefined;\r\n\t});\r\n\treturn ( fxNow = jQuery.now() );\r\n}\r\n\r\nfunction createTweens( animation, props ) {\r\n\tjQuery.each( props, function( prop, value ) {\r\n\t\tvar collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\r\n\t\t\tindex = 0,\r\n\t\t\tlength = collection.length;\r\n\t\tfor ( ; index < length; index++ ) {\r\n\t\t\tif ( collection[ index ].call( animation, prop, value ) ) {\r\n\r\n\t\t\t\t// we're done with this property\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction Animation( elem, properties, options ) {\r\n\tvar result,\r\n\t\tstopped,\r\n\t\tindex = 0,\r\n\t\tlength = animationPrefilters.length,\r\n\t\tdeferred = jQuery.Deferred().always( function() {\r\n\t\t\t// don't match elem in the :animated selector\r\n\t\t\tdelete tick.elem;\r\n\t\t}),\r\n\t\ttick = function() {\r\n\t\t\tif ( stopped ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tvar currentTime = fxNow || createFxNow(),\r\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\r\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\r\n\t\t\t\ttemp = remaining / animation.duration || 0,\r\n\t\t\t\tpercent = 1 - temp,\r\n\t\t\t\tindex = 0,\r\n\t\t\t\tlength = animation.tweens.length;\r\n\r\n\t\t\tfor ( ; index < length ; index++ ) {\r\n\t\t\t\tanimation.tweens[ index ].run( percent );\r\n\t\t\t}\r\n\r\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\r\n\r\n\t\t\tif ( percent < 1 && length ) {\r\n\t\t\t\treturn remaining;\r\n\t\t\t} else {\r\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t},\r\n\t\tanimation = deferred.promise({\r\n\t\t\telem: elem,\r\n\t\t\tprops: jQuery.extend( {}, properties ),\r\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\r\n\t\t\toriginalProperties: properties,\r\n\t\t\toriginalOptions: options,\r\n\t\t\tstartTime: fxNow || createFxNow(),\r\n\t\t\tduration: options.duration,\r\n\t\t\ttweens: [],\r\n\t\t\tcreateTween: function( prop, end ) {\r\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\r\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\r\n\t\t\t\tanimation.tweens.push( tween );\r\n\t\t\t\treturn tween;\r\n\t\t\t},\r\n\t\t\tstop: function( gotoEnd ) {\r\n\t\t\t\tvar index = 0,\r\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\r\n\t\t\t\t\t// otherwise we skip this part\r\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\r\n\t\t\t\tif ( stopped ) {\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t\tstopped = true;\r\n\t\t\t\tfor ( ; index < length ; index++ ) {\r\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// resolve when we played the last frame\r\n\t\t\t\t// otherwise, reject\r\n\t\t\t\tif ( gotoEnd ) {\r\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t}),\r\n\t\tprops = animation.props;\r\n\r\n\tpropFilter( props, animation.opts.specialEasing );\r\n\r\n\tfor ( ; index < length ; index++ ) {\r\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\r\n\t\tif ( result ) {\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\tcreateTweens( animation, props );\r\n\r\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\r\n\t\tanimation.opts.start.call( elem, animation );\r\n\t}\r\n\r\n\tjQuery.fx.timer(\r\n\t\tjQuery.extend( tick, {\r\n\t\t\telem: elem,\r\n\t\t\tanim: animation,\r\n\t\t\tqueue: animation.opts.queue\r\n\t\t})\r\n\t);\r\n\r\n\t// attach callbacks from options\r\n\treturn animation.progress( animation.opts.progress )\r\n\t\t.done( animation.opts.done, animation.opts.complete )\r\n\t\t.fail( animation.opts.fail )\r\n\t\t.always( animation.opts.always );\r\n}\r\n\r\nfunction propFilter( props, specialEasing ) {\r\n\tvar index, name, easing, value, hooks;\r\n\r\n\t// camelCase, specialEasing and expand cssHook pass\r\n\tfor ( index in props ) {\r\n\t\tname = jQuery.camelCase( index );\r\n\t\teasing = specialEasing[ name ];\r\n\t\tvalue = props[ index ];\r\n\t\tif ( jQuery.isArray( value ) ) {\r\n\t\t\teasing = value[ 1 ];\r\n\t\t\tvalue = props[ index ] = value[ 0 ];\r\n\t\t}\r\n\r\n\t\tif ( index !== name ) {\r\n\t\t\tprops[ name ] = value;\r\n\t\t\tdelete props[ index ];\r\n\t\t}\r\n\r\n\t\thooks = jQuery.cssHooks[ name ];\r\n\t\tif ( hooks && \"expand\" in hooks ) {\r\n\t\t\tvalue = hooks.expand( value );\r\n\t\t\tdelete props[ name ];\r\n\r\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\r\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\r\n\t\t\tfor ( index in value ) {\r\n\t\t\t\tif ( !( index in props ) ) {\r\n\t\t\t\t\tprops[ index ] = value[ index ];\r\n\t\t\t\t\tspecialEasing[ index ] = easing;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tspecialEasing[ name ] = easing;\r\n\t\t}\r\n\t}\r\n}\r\n\r\njQuery.Animation = jQuery.extend( Animation, {\r\n\r\n\ttweener: function( props, callback ) {\r\n\t\tif ( jQuery.isFunction( props ) ) {\r\n\t\t\tcallback = props;\r\n\t\t\tprops = [ \"*\" ];\r\n\t\t} else {\r\n\t\t\tprops = props.split(\" \");\r\n\t\t}\r\n\r\n\t\tvar prop,\r\n\t\t\tindex = 0,\r\n\t\t\tlength = props.length;\r\n\r\n\t\tfor ( ; index < length ; index++ ) {\r\n\t\t\tprop = props[ index ];\r\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\r\n\t\t\ttweeners[ prop ].unshift( callback );\r\n\t\t}\r\n\t},\r\n\r\n\tprefilter: function( callback, prepend ) {\r\n\t\tif ( prepend ) {\r\n\t\t\tanimationPrefilters.unshift( callback );\r\n\t\t} else {\r\n\t\t\tanimationPrefilters.push( callback );\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction defaultPrefilter( elem, props, opts ) {\r\n\t/* jshint validthis: true */\r\n\tvar index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,\r\n\t\tanim = this,\r\n\t\tstyle = elem.style,\r\n\t\torig = {},\r\n\t\thandled = [],\r\n\t\thidden = elem.nodeType && isHidden( elem );\r\n\r\n\t// handle queue: false promises\r\n\tif ( !opts.queue ) {\r\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\r\n\t\tif ( hooks.unqueued == null ) {\r\n\t\t\thooks.unqueued = 0;\r\n\t\t\toldfire = hooks.empty.fire;\r\n\t\t\thooks.empty.fire = function() {\r\n\t\t\t\tif ( !hooks.unqueued ) {\r\n\t\t\t\t\toldfire();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\thooks.unqueued++;\r\n\r\n\t\tanim.always(function() {\r\n\t\t\t// doing this makes sure that the complete handler will be called\r\n\t\t\t// before this completes\r\n\t\t\tanim.always(function() {\r\n\t\t\t\thooks.unqueued--;\r\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\r\n\t\t\t\t\thooks.empty.fire();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t// height/width overflow pass\r\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\r\n\t\t// Make sure that nothing sneaks out\r\n\t\t// Record all 3 overflow attributes because IE9-10 do not\r\n\t\t// change the overflow attribute when overflowX and\r\n\t\t// overflowY are set to the same value\r\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\r\n\r\n\t\t// Set display property to inline-block for height/width\r\n\t\t// animations on inline elements that are having width/height animated\r\n\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\r\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\r\n\r\n\t\t\tstyle.display = \"inline-block\";\r\n\t\t}\r\n\t}\r\n\r\n\tif ( opts.overflow ) {\r\n\t\tstyle.overflow = \"hidden\";\r\n\t\tanim.always(function() {\r\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\r\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\r\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\r\n\t\t});\r\n\t}\r\n\r\n\r\n\t// show/hide pass\r\n\tdataShow = data_priv.get( elem, \"fxshow\" );\r\n\tfor ( index in props ) {\r\n\t\tvalue = props[ index ];\r\n\t\tif ( rfxtypes.exec( value ) ) {\r\n\t\t\tdelete props[ index ];\r\n\t\t\ttoggle = toggle || value === \"toggle\";\r\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\r\n\r\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\r\n\t\t\t\tif( value === \"show\" && dataShow !== undefined && dataShow[ index ] !== undefined ) {\r\n\t\t\t\t\thidden = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\thandled.push( index );\r\n\t\t}\r\n\t}\r\n\r\n\tlength = handled.length;\r\n\tif ( length ) {\r\n\t\tdataShow = data_priv.get( elem, \"fxshow\" ) || data_priv.access( elem, \"fxshow\", {} );\r\n\t\tif ( \"hidden\" in dataShow ) {\r\n\t\t\thidden = dataShow.hidden;\r\n\t\t}\r\n\r\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\r\n\t\tif ( toggle ) {\r\n\t\t\tdataShow.hidden = !hidden;\r\n\t\t}\r\n\t\tif ( hidden ) {\r\n\t\t\tjQuery( elem ).show();\r\n\t\t} else {\r\n\t\t\tanim.done(function() {\r\n\t\t\t\tjQuery( elem ).hide();\r\n\t\t\t});\r\n\t\t}\r\n\t\tanim.done(function() {\r\n\t\t\tvar prop;\r\n\r\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\r\n\t\t\tfor ( prop in orig ) {\r\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\r\n\t\t\t}\r\n\t\t});\r\n\t\tfor ( index = 0 ; index < length ; index++ ) {\r\n\t\t\tprop = handled[ index ];\r\n\t\t\ttween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );\r\n\t\t\torig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );\r\n\r\n\t\t\tif ( !( prop in dataShow ) ) {\r\n\t\t\t\tdataShow[ prop ] = tween.start;\r\n\t\t\t\tif ( hidden ) {\r\n\t\t\t\t\ttween.end = tween.start;\r\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction Tween( elem, options, prop, end, easing ) {\r\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\r\n}\r\njQuery.Tween = Tween;\r\n\r\nTween.prototype = {\r\n\tconstructor: Tween,\r\n\tinit: function( elem, options, prop, end, easing, unit ) {\r\n\t\tthis.elem = elem;\r\n\t\tthis.prop = prop;\r\n\t\tthis.easing = easing || \"swing\";\r\n\t\tthis.options = options;\r\n\t\tthis.start = this.now = this.cur();\r\n\t\tthis.end = end;\r\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\r\n\t},\r\n\tcur: function() {\r\n\t\tvar hooks = Tween.propHooks[ this.prop ];\r\n\r\n\t\treturn hooks && hooks.get ?\r\n\t\t\thooks.get( this ) :\r\n\t\t\tTween.propHooks._default.get( this );\r\n\t},\r\n\trun: function( percent ) {\r\n\t\tvar eased,\r\n\t\t\thooks = Tween.propHooks[ this.prop ];\r\n\r\n\t\tif ( this.options.duration ) {\r\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\r\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tthis.pos = eased = percent;\r\n\t\t}\r\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\r\n\r\n\t\tif ( this.options.step ) {\r\n\t\t\tthis.options.step.call( this.elem, this.now, this );\r\n\t\t}\r\n\r\n\t\tif ( hooks && hooks.set ) {\r\n\t\t\thooks.set( this );\r\n\t\t} else {\r\n\t\t\tTween.propHooks._default.set( this );\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n};\r\n\r\nTween.prototype.init.prototype = Tween.prototype;\r\n\r\nTween.propHooks = {\r\n\t_default: {\r\n\t\tget: function( tween ) {\r\n\t\t\tvar result;\r\n\r\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\r\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\r\n\t\t\t\treturn tween.elem[ tween.prop ];\r\n\t\t\t}\r\n\r\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\r\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\r\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\r\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\r\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\r\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\r\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\r\n\t\t},\r\n\t\tset: function( tween ) {\r\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\r\n\t\t\t// available and use plain properties where available\r\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\r\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\r\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\r\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\r\n\t\t\t} else {\r\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// Support: IE9\r\n// Panic based approach to setting things on disconnected nodes\r\n\r\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\r\n\tset: function( tween ) {\r\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\r\n\t\t\ttween.elem[ tween.prop ] = tween.now;\r\n\t\t}\r\n\t}\r\n};\r\n\r\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\r\n\tvar cssFn = jQuery.fn[ name ];\r\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\r\n\t\treturn speed == null || typeof speed === \"boolean\" ?\r\n\t\t\tcssFn.apply( this, arguments ) :\r\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\r\n\t};\r\n});\r\n\r\njQuery.fn.extend({\r\n\tfadeTo: function( speed, to, easing, callback ) {\r\n\r\n\t\t// show any hidden elements after setting opacity to 0\r\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\r\n\r\n\t\t\t// animate to the value specified\r\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\r\n\t},\r\n\tanimate: function( prop, speed, easing, callback ) {\r\n\t\tvar empty = jQuery.isEmptyObject( prop ),\r\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\r\n\t\t\tdoAnimation = function() {\r\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\r\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\r\n\t\t\t\tdoAnimation.finish = function() {\r\n\t\t\t\t\tanim.stop( true );\r\n\t\t\t\t};\r\n\t\t\t\t// Empty animations, or finishing resolves immediately\r\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\r\n\t\t\t\t\tanim.stop( true );\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tdoAnimation.finish = doAnimation;\r\n\r\n\t\treturn empty || optall.queue === false ?\r\n\t\t\tthis.each( doAnimation ) :\r\n\t\t\tthis.queue( optall.queue, doAnimation );\r\n\t},\r\n\tstop: function( type, clearQueue, gotoEnd ) {\r\n\t\tvar stopQueue = function( hooks ) {\r\n\t\t\tvar stop = hooks.stop;\r\n\t\t\tdelete hooks.stop;\r\n\t\t\tstop( gotoEnd );\r\n\t\t};\r\n\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tgotoEnd = clearQueue;\r\n\t\t\tclearQueue = type;\r\n\t\t\ttype = undefined;\r\n\t\t}\r\n\t\tif ( clearQueue && type !== false ) {\r\n\t\t\tthis.queue( type || \"fx\", [] );\r\n\t\t}\r\n\r\n\t\treturn this.each(function() {\r\n\t\t\tvar dequeue = true,\r\n\t\t\t\tindex = type != null && type + \"queueHooks\",\r\n\t\t\t\ttimers = jQuery.timers,\r\n\t\t\t\tdata = data_priv.get( this );\r\n\r\n\t\t\tif ( index ) {\r\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\r\n\t\t\t\t\tstopQueue( data[ index ] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( index in data ) {\r\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\r\n\t\t\t\t\t\tstopQueue( data[ index ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor ( index = timers.length; index--; ) {\r\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\r\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\r\n\t\t\t\t\tdequeue = false;\r\n\t\t\t\t\ttimers.splice( index, 1 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// start the next in the queue if the last step wasn't forced\r\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\r\n\t\t\t// but only if they were gotoEnd\r\n\t\t\tif ( dequeue || !gotoEnd ) {\r\n\t\t\t\tjQuery.dequeue( this, type );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\tfinish: function( type ) {\r\n\t\tif ( type !== false ) {\r\n\t\t\ttype = type || \"fx\";\r\n\t\t}\r\n\t\treturn this.each(function() {\r\n\t\t\tvar index,\r\n\t\t\t\tdata = data_priv.get( this ),\r\n\t\t\t\tqueue = data[ type + \"queue\" ],\r\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\r\n\t\t\t\ttimers = jQuery.timers,\r\n\t\t\t\tlength = queue ? queue.length : 0;\r\n\r\n\t\t\t// enable finishing flag on private data\r\n\t\t\tdata.finish = true;\r\n\r\n\t\t\t// empty the queue first\r\n\t\t\tjQuery.queue( this, type, [] );\r\n\r\n\t\t\tif ( hooks && hooks.cur && hooks.cur.finish ) {\r\n\t\t\t\thooks.cur.finish.call( this );\r\n\t\t\t}\r\n\r\n\t\t\t// look for any active animations, and finish them\r\n\t\t\tfor ( index = timers.length; index--; ) {\r\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\r\n\t\t\t\t\ttimers[ index ].anim.stop( true );\r\n\t\t\t\t\ttimers.splice( index, 1 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// look for any animations in the old queue and finish them\r\n\t\t\tfor ( index = 0; index < length; index++ ) {\r\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\r\n\t\t\t\t\tqueue[ index ].finish.call( this );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// turn off finishing flag\r\n\t\t\tdelete data.finish;\r\n\t\t});\r\n\t}\r\n});\r\n\r\n// Generate parameters to create a standard animation\r\nfunction genFx( type, includeWidth ) {\r\n\tvar which,\r\n\t\tattrs = { height: type },\r\n\t\ti = 0;\r\n\r\n\t// if we include width, step value is 1 to do all cssExpand values,\r\n\t// if we don't include width, step value is 2 to skip over Left and Right\r\n\tincludeWidth = includeWidth? 1 : 0;\r\n\tfor( ; i < 4 ; i += 2 - includeWidth ) {\r\n\t\twhich = cssExpand[ i ];\r\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\r\n\t}\r\n\r\n\tif ( includeWidth ) {\r\n\t\tattrs.opacity = attrs.width = type;\r\n\t}\r\n\r\n\treturn attrs;\r\n}\r\n\r\n// Generate shortcuts for custom animations\r\njQuery.each({\r\n\tslideDown: genFx(\"show\"),\r\n\tslideUp: genFx(\"hide\"),\r\n\tslideToggle: genFx(\"toggle\"),\r\n\tfadeIn: { opacity: \"show\" },\r\n\tfadeOut: { opacity: \"hide\" },\r\n\tfadeToggle: { opacity: \"toggle\" }\r\n}, function( name, props ) {\r\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\r\n\t\treturn this.animate( props, speed, easing, callback );\r\n\t};\r\n});\r\n\r\njQuery.speed = function( speed, easing, fn ) {\r\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\r\n\t\tcomplete: fn || !fn && easing ||\r\n\t\t\tjQuery.isFunction( speed ) && speed,\r\n\t\tduration: speed,\r\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\r\n\t};\r\n\r\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\r\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\r\n\r\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\r\n\tif ( opt.queue == null || opt.queue === true ) {\r\n\t\topt.queue = \"fx\";\r\n\t}\r\n\r\n\t// Queueing\r\n\topt.old = opt.complete;\r\n\r\n\topt.complete = function() {\r\n\t\tif ( jQuery.isFunction( opt.old ) ) {\r\n\t\t\topt.old.call( this );\r\n\t\t}\r\n\r\n\t\tif ( opt.queue ) {\r\n\t\t\tjQuery.dequeue( this, opt.queue );\r\n\t\t}\r\n\t};\r\n\r\n\treturn opt;\r\n};\r\n\r\njQuery.easing = {\r\n\tlinear: function( p ) {\r\n\t\treturn p;\r\n\t},\r\n\tswing: function( p ) {\r\n\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\r\n\t}\r\n};\r\n\r\njQuery.timers = [];\r\njQuery.fx = Tween.prototype.init;\r\njQuery.fx.tick = function() {\r\n\tvar timer,\r\n\t\ttimers = jQuery.timers,\r\n\t\ti = 0;\r\n\r\n\tfxNow = jQuery.now();\r\n\r\n\tfor ( ; i < timers.length; i++ ) {\r\n\t\ttimer = timers[ i ];\r\n\t\t// Checks the timer has not already been removed\r\n\t\tif ( !timer() && timers[ i ] === timer ) {\r\n\t\t\ttimers.splice( i--, 1 );\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !timers.length ) {\r\n\t\tjQuery.fx.stop();\r\n\t}\r\n\tfxNow = undefined;\r\n};\r\n\r\njQuery.fx.timer = function( timer ) {\r\n\tif ( timer() && jQuery.timers.push( timer ) ) {\r\n\t\tjQuery.fx.start();\r\n\t}\r\n};\r\n\r\njQuery.fx.interval = 13;\r\n\r\njQuery.fx.start = function() {\r\n\tif ( !timerId ) {\r\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\r\n\t}\r\n};\r\n\r\njQuery.fx.stop = function() {\r\n\tclearInterval( timerId );\r\n\ttimerId = null;\r\n};\r\n\r\njQuery.fx.speeds = {\r\n\tslow: 600,\r\n\tfast: 200,\r\n\t// Default speed\r\n\t_default: 400\r\n};\r\n\r\n// Back Compat <1.8 extension point\r\njQuery.fx.step = {};\r\n\r\nif ( jQuery.expr && jQuery.expr.filters ) {\r\n\tjQuery.expr.filters.animated = function( elem ) {\r\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\r\n\t\t\treturn elem === fn.elem;\r\n\t\t}).length;\r\n\t};\r\n}\r\njQuery.fn.offset = function( options ) {\r\n\tif ( arguments.length ) {\r\n\t\treturn options === undefined ?\r\n\t\t\tthis :\r\n\t\t\tthis.each(function( i ) {\r\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\r\n\t\t\t});\r\n\t}\r\n\r\n\tvar docElem, win,\r\n\t\telem = this[ 0 ],\r\n\t\tbox = { top: 0, left: 0 },\r\n\t\tdoc = elem && elem.ownerDocument;\r\n\r\n\tif ( !doc ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tdocElem = doc.documentElement;\r\n\r\n\t// Make sure it's not a disconnected DOM node\r\n\tif ( !jQuery.contains( docElem, elem ) ) {\r\n\t\treturn box;\r\n\t}\r\n\r\n\t// If we don't have gBCR, just use 0,0 rather than error\r\n\t// BlackBerry 5, iOS 3 (original iPhone)\r\n\tif ( typeof elem.getBoundingClientRect !== core_strundefined ) {\r\n\t\tbox = elem.getBoundingClientRect();\r\n\t}\r\n\twin = getWindow( doc );\r\n\treturn {\r\n\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\r\n\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\r\n\t};\r\n};\r\n\r\njQuery.offset = {\r\n\r\n\tsetOffset: function( elem, options, i ) {\r\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\r\n\t\t\tposition = jQuery.css( elem, \"position\" ),\r\n\t\t\tcurElem = jQuery( elem ),\r\n\t\t\tprops = {};\r\n\r\n\t\t// Set position first, in-case top/left are set even on static elem\r\n\t\tif ( position === \"static\" ) {\r\n\t\t\telem.style.position = \"relative\";\r\n\t\t}\r\n\r\n\t\tcurOffset = curElem.offset();\r\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\r\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\r\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && ( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\r\n\r\n\t\t// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\r\n\t\tif ( calculatePosition ) {\r\n\t\t\tcurPosition = curElem.position();\r\n\t\t\tcurTop = curPosition.top;\r\n\t\t\tcurLeft = curPosition.left;\r\n\r\n\t\t} else {\r\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\r\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\r\n\t\t}\r\n\r\n\t\tif ( jQuery.isFunction( options ) ) {\r\n\t\t\toptions = options.call( elem, i, curOffset );\r\n\t\t}\r\n\r\n\t\tif ( options.top != null ) {\r\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\r\n\t\t}\r\n\t\tif ( options.left != null ) {\r\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\r\n\t\t}\r\n\r\n\t\tif ( \"using\" in options ) {\r\n\t\t\toptions.using.call( elem, props );\r\n\r\n\t\t} else {\r\n\t\t\tcurElem.css( props );\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\njQuery.fn.extend({\r\n\r\n\tposition: function() {\r\n\t\tif ( !this[ 0 ] ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar offsetParent, offset,\r\n\t\t\telem = this[ 0 ],\r\n\t\t\tparentOffset = { top: 0, left: 0 };\r\n\r\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\r\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\r\n\t\t\t// We assume that getBoundingClientRect is available when computed position is fixed\r\n\t\t\toffset = elem.getBoundingClientRect();\r\n\r\n\t\t} else {\r\n\t\t\t// Get *real* offsetParent\r\n\t\t\toffsetParent = this.offsetParent();\r\n\r\n\t\t\t// Get correct offsets\r\n\t\t\toffset = this.offset();\r\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\r\n\t\t\t\tparentOffset = offsetParent.offset();\r\n\t\t\t}\r\n\r\n\t\t\t// Add offsetParent borders\r\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\r\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\r\n\t\t}\r\n\r\n\t\t// Subtract parent offsets and element margins\r\n\t\treturn {\r\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\r\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\r\n\t\t};\r\n\t},\r\n\r\n\toffsetParent: function() {\r\n\t\treturn this.map(function() {\r\n\t\t\tvar offsetParent = this.offsetParent || docElem;\r\n\r\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\r\n\t\t\t\toffsetParent = offsetParent.offsetParent;\r\n\t\t\t}\r\n\r\n\t\t\treturn offsetParent || docElem;\r\n\t\t});\r\n\t}\r\n});\r\n\r\n\r\n// Create scrollLeft and scrollTop methods\r\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\r\n\tvar top = \"pageYOffset\" === prop;\r\n\r\n\tjQuery.fn[ method ] = function( val ) {\r\n\t\treturn jQuery.access( this, function( elem, method, val ) {\r\n\t\t\tvar win = getWindow( elem );\r\n\r\n\t\t\tif ( val === undefined ) {\r\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\r\n\t\t\t}\r\n\r\n\t\t\tif ( win ) {\r\n\t\t\t\twin.scrollTo(\r\n\t\t\t\t\t!top ? val : window.pageXOffset,\r\n\t\t\t\t\ttop ? val : window.pageYOffset\r\n\t\t\t\t);\r\n\r\n\t\t\t} else {\r\n\t\t\t\telem[ method ] = val;\r\n\t\t\t}\r\n\t\t}, method, val, arguments.length, null );\r\n\t};\r\n});\r\n\r\nfunction getWindow( elem ) {\r\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\r\n}\r\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\r\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\r\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\r\n\t\t// margin is only for outerHeight, outerWidth\r\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\r\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\r\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\r\n\r\n\t\t\treturn jQuery.access( this, function( elem, type, value ) {\r\n\t\t\t\tvar doc;\r\n\r\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\r\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\r\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\r\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\r\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get document width or height\r\n\t\t\t\tif ( elem.nodeType === 9 ) {\r\n\t\t\t\t\tdoc = elem.documentElement;\r\n\r\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\r\n\t\t\t\t\t// whichever is greatest\r\n\t\t\t\t\treturn Math.max(\r\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\r\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\r\n\t\t\t\t\t\tdoc[ \"client\" + name ]\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn value === undefined ?\r\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\r\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\r\n\r\n\t\t\t\t\t// Set width or height on the element\r\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\r\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\r\n\t\t};\r\n\t});\r\n});\r\n// Limit scope pollution from any deprecated API\r\n// (function() {\r\n\r\n// The number of elements contained in the matched element set\r\njQuery.fn.size = function() {\r\n\treturn this.length;\r\n};\r\n\r\njQuery.fn.andSelf = jQuery.fn.addBack;\r\n\r\n// })();\r\nif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\r\n\t// Expose jQuery as module.exports in loaders that implement the Node\r\n\t// module pattern (including browserify). Do not create the global, since\r\n\t// the user will be storing it themselves locally, and globals are frowned\r\n\t// upon in the Node module world.\r\n\tmodule.exports = jQuery;\r\n} else {\r\n\t// Register as a named AMD module, since jQuery can be concatenated with other\r\n\t// files that may use define, but not via a proper concatenation script that\r\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\r\n\t// way to register. Lowercase jquery is used because AMD module names are\r\n\t// derived from file names, and jQuery is normally delivered in a lowercase\r\n\t// file name. Do this after creating the global so that if an AMD module wants\r\n\t// to call noConflict to hide this version of jQuery, it will work.\r\n\tif ( typeof define === \"function\" && define.amd ) {\r\n\t\tdefine( \"jquery\", [], function () { return jQuery; } );\r\n\t}\r\n}\r\n\r\n// If there is a window object, that at least has a document property,\r\n// define jQuery and $ identifiers\r\nif ( typeof window === \"object\" && typeof window.document === \"object\" ) {\r\n\twindow.jQuery = window.$ = jQuery;\r\n}\r\n\r\n})( window );\r\n",
    "/**\r\n * @license AngularJS v1.1.5\r\n * (c) 2010-2012 Google, Inc. http://angularjs.org\r\n * License: MIT\r\n */\r\n(function(window, document, undefined) {\r\n'use strict';\r\n\r\n////////////////////////////////////\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.lowercase\r\n * @function\r\n *\r\n * @description Converts the specified string to lowercase.\r\n * @param {string} string String to be converted to lowercase.\r\n * @returns {string} Lowercased string.\r\n */\r\nvar lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.uppercase\r\n * @function\r\n *\r\n * @description Converts the specified string to uppercase.\r\n * @param {string} string String to be converted to uppercase.\r\n * @returns {string} Uppercased string.\r\n */\r\nvar uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};\r\n\r\n\r\nvar manualLowercase = function(s) {\r\n  return isString(s)\r\n      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})\r\n      : s;\r\n};\r\nvar manualUppercase = function(s) {\r\n  return isString(s)\r\n      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})\r\n      : s;\r\n};\r\n\r\n\r\n// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish\r\n// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods\r\n// with correct but slower alternatives.\r\nif ('i' !== 'I'.toLowerCase()) {\r\n  lowercase = manualLowercase;\r\n  uppercase = manualUppercase;\r\n}\r\n\r\n\r\nvar /** holds major version number for IE or NaN for real browsers */\r\n    msie              = int((/msie (\\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]),\r\n    jqLite,           // delay binding since jQuery could be loaded after us.\r\n    jQuery,           // delay binding\r\n    slice             = [].slice,\r\n    push              = [].push,\r\n    toString          = Object.prototype.toString,\r\n\r\n\r\n    _angular          = window.angular,\r\n    /** @name angular */\r\n    angular           = window.angular || (window.angular = {}),\r\n    angularModule,\r\n    nodeName_,\r\n    uid               = ['0', '0', '0'];\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.noConflict\r\n * @function\r\n *\r\n * @description\r\n * Restores the previous global value of angular and returns the current instance. Other libraries may already use the\r\n * angular namespace. Or a previous version of angular is already loaded on the page. In these cases you may want to\r\n * restore the previous namespace and keep a reference to angular.\r\n *\r\n * @return {Object} The current angular namespace\r\n */\r\nfunction noConflict() {\r\n  var a = window.angular;\r\n  window.angular = _angular;\r\n  return a;\r\n}\r\n\r\n/**\r\n * @private\r\n * @param {*} obj\r\n * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments, ...)\r\n */\r\nfunction isArrayLike(obj) {\r\n  if (!obj || (typeof obj.length !== 'number')) return false;\r\n\r\n  // We have on object which has length property. Should we treat it as array?\r\n  if (typeof obj.hasOwnProperty != 'function' &&\r\n      typeof obj.constructor != 'function') {\r\n    // This is here for IE8: it is a bogus object treat it as array;\r\n    return true;\r\n  } else  {\r\n    return obj instanceof JQLite ||                      // JQLite\r\n           (jQuery && obj instanceof jQuery) ||          // jQuery\r\n           toString.call(obj) !== '[object Object]' ||   // some browser native object\r\n           typeof obj.callee === 'function';              // arguments (on IE8 looks like regular obj)\r\n  }\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.forEach\r\n * @function\r\n *\r\n * @description\r\n * Invokes the `iterator` function once for each item in `obj` collection, which can be either an\r\n * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`\r\n * is the value of an object property or an array element and `key` is the object property key or\r\n * array element index. Specifying a `context` for the function is optional.\r\n *\r\n * Note: this function was previously known as `angular.foreach`.\r\n *\r\n   <pre>\r\n     var values = {name: 'misko', gender: 'male'};\r\n     var log = [];\r\n     angular.forEach(values, function(value, key){\r\n       this.push(key + ': ' + value);\r\n     }, log);\r\n     expect(log).toEqual(['name: misko', 'gender:male']);\r\n   </pre>\r\n *\r\n * @param {Object|Array} obj Object to iterate over.\r\n * @param {Function} iterator Iterator function.\r\n * @param {Object=} context Object to become context (`this`) for the iterator function.\r\n * @returns {Object|Array} Reference to `obj`.\r\n */\r\nfunction forEach(obj, iterator, context) {\r\n  var key;\r\n  if (obj) {\r\n    if (isFunction(obj)){\r\n      for (key in obj) {\r\n        if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {\r\n          iterator.call(context, obj[key], key);\r\n        }\r\n      }\r\n    } else if (obj.forEach && obj.forEach !== forEach) {\r\n      obj.forEach(iterator, context);\r\n    } else if (isArrayLike(obj)) {\r\n      for (key = 0; key < obj.length; key++)\r\n        iterator.call(context, obj[key], key);\r\n    } else {\r\n      for (key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n          iterator.call(context, obj[key], key);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return obj;\r\n}\r\n\r\nfunction sortedKeys(obj) {\r\n  var keys = [];\r\n  for (var key in obj) {\r\n    if (obj.hasOwnProperty(key)) {\r\n      keys.push(key);\r\n    }\r\n  }\r\n  return keys.sort();\r\n}\r\n\r\nfunction forEachSorted(obj, iterator, context) {\r\n  var keys = sortedKeys(obj);\r\n  for ( var i = 0; i < keys.length; i++) {\r\n    iterator.call(context, obj[keys[i]], keys[i]);\r\n  }\r\n  return keys;\r\n}\r\n\r\n\r\n/**\r\n * when using forEach the params are value, key, but it is often useful to have key, value.\r\n * @param {function(string, *)} iteratorFn\r\n * @returns {function(*, string)}\r\n */\r\nfunction reverseParams(iteratorFn) {\r\n  return function(value, key) { iteratorFn(key, value) };\r\n}\r\n\r\n/**\r\n * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric\r\n * characters such as '012ABC'. The reason why we are not using simply a number counter is that\r\n * the number string gets longer over time, and it can also overflow, where as the nextId\r\n * will grow much slower, it is a string, and it will never overflow.\r\n *\r\n * @returns an unique alpha-numeric string\r\n */\r\nfunction nextUid() {\r\n  var index = uid.length;\r\n  var digit;\r\n\r\n  while(index) {\r\n    index--;\r\n    digit = uid[index].charCodeAt(0);\r\n    if (digit == 57 /*'9'*/) {\r\n      uid[index] = 'A';\r\n      return uid.join('');\r\n    }\r\n    if (digit == 90  /*'Z'*/) {\r\n      uid[index] = '0';\r\n    } else {\r\n      uid[index] = String.fromCharCode(digit + 1);\r\n      return uid.join('');\r\n    }\r\n  }\r\n  uid.unshift('0');\r\n  return uid.join('');\r\n}\r\n\r\n\r\n/**\r\n * Set or clear the hashkey for an object.\r\n * @param obj object \r\n * @param h the hashkey (!truthy to delete the hashkey)\r\n */\r\nfunction setHashKey(obj, h) {\r\n  if (h) {\r\n    obj.$$hashKey = h;\r\n  }\r\n  else {\r\n    delete obj.$$hashKey;\r\n  }\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.extend\r\n * @function\r\n *\r\n * @description\r\n * Extends the destination object `dst` by copying all of the properties from the `src` object(s)\r\n * to `dst`. You can specify multiple `src` objects.\r\n *\r\n * @param {Object} dst Destination object.\r\n * @param {...Object} src Source object(s).\r\n * @returns {Object} Reference to `dst`.\r\n */\r\nfunction extend(dst) {\r\n  var h = dst.$$hashKey;\r\n  forEach(arguments, function(obj){\r\n    if (obj !== dst) {\r\n      forEach(obj, function(value, key){\r\n        dst[key] = value;\r\n      });\r\n    }\r\n  });\r\n\r\n  setHashKey(dst,h);\r\n  return dst;\r\n}\r\n\r\nfunction int(str) {\r\n  return parseInt(str, 10);\r\n}\r\n\r\n\r\nfunction inherit(parent, extra) {\r\n  return extend(new (extend(function() {}, {prototype:parent}))(), extra);\r\n}\r\n\r\nvar START_SPACE = /^\\s*/;\r\nvar END_SPACE = /\\s*$/;\r\nfunction stripWhitespace(str) {\r\n  return isString(str) ? str.replace(START_SPACE, '').replace(END_SPACE, '') : str;\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.noop\r\n * @function\r\n *\r\n * @description\r\n * A function that performs no operations. This function can be useful when writing code in the\r\n * functional style.\r\n   <pre>\r\n     function foo(callback) {\r\n       var result = calculateResult();\r\n       (callback || angular.noop)(result);\r\n     }\r\n   </pre>\r\n */\r\nfunction noop() {}\r\nnoop.$inject = [];\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.identity\r\n * @function\r\n *\r\n * @description\r\n * A function that returns its first argument. This function is useful when writing code in the\r\n * functional style.\r\n *\r\n   <pre>\r\n     function transformer(transformationFn, value) {\r\n       return (transformationFn || identity)(value);\r\n     };\r\n   </pre>\r\n */\r\nfunction identity($) {return $;}\r\nidentity.$inject = [];\r\n\r\n\r\nfunction valueFn(value) {return function() {return value;};}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isUndefined\r\n * @function\r\n *\r\n * @description\r\n * Determines if a reference is undefined.\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is undefined.\r\n */\r\nfunction isUndefined(value){return typeof value == 'undefined';}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isDefined\r\n * @function\r\n *\r\n * @description\r\n * Determines if a reference is defined.\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is defined.\r\n */\r\nfunction isDefined(value){return typeof value != 'undefined';}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isObject\r\n * @function\r\n *\r\n * @description\r\n * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\r\n * considered to be objects.\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is an `Object` but not `null`.\r\n */\r\nfunction isObject(value){return value != null && typeof value == 'object';}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isString\r\n * @function\r\n *\r\n * @description\r\n * Determines if a reference is a `String`.\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is a `String`.\r\n */\r\nfunction isString(value){return typeof value == 'string';}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isNumber\r\n * @function\r\n *\r\n * @description\r\n * Determines if a reference is a `Number`.\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is a `Number`.\r\n */\r\nfunction isNumber(value){return typeof value == 'number';}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isDate\r\n * @function\r\n *\r\n * @description\r\n * Determines if a value is a date.\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is a `Date`.\r\n */\r\nfunction isDate(value){\r\n  return toString.apply(value) == '[object Date]';\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isArray\r\n * @function\r\n *\r\n * @description\r\n * Determines if a reference is an `Array`.\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is an `Array`.\r\n */\r\nfunction isArray(value) {\r\n  return toString.apply(value) == '[object Array]';\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isFunction\r\n * @function\r\n *\r\n * @description\r\n * Determines if a reference is a `Function`.\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is a `Function`.\r\n */\r\nfunction isFunction(value){return typeof value == 'function';}\r\n\r\n\r\n/**\r\n * Checks if `obj` is a window object.\r\n *\r\n * @private\r\n * @param {*} obj Object to check\r\n * @returns {boolean} True if `obj` is a window obj.\r\n */\r\nfunction isWindow(obj) {\r\n  return obj && obj.document && obj.location && obj.alert && obj.setInterval;\r\n}\r\n\r\n\r\nfunction isScope(obj) {\r\n  return obj && obj.$evalAsync && obj.$watch;\r\n}\r\n\r\n\r\nfunction isFile(obj) {\r\n  return toString.apply(obj) === '[object File]';\r\n}\r\n\r\n\r\nfunction isBoolean(value) {\r\n  return typeof value == 'boolean';\r\n}\r\n\r\n\r\nfunction trim(value) {\r\n  return isString(value) ? value.replace(/^\\s*/, '').replace(/\\s*$/, '') : value;\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.isElement\r\n * @function\r\n *\r\n * @description\r\n * Determines if a reference is a DOM element (or wrapped jQuery element).\r\n *\r\n * @param {*} value Reference to check.\r\n * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).\r\n */\r\nfunction isElement(node) {\r\n  return node &&\r\n    (node.nodeName  // we are a direct element\r\n    || (node.bind && node.find));  // we have a bind and find method part of jQuery API\r\n}\r\n\r\n/**\r\n * @param str 'key1,key2,...'\r\n * @returns {object} in the form of {key1:true, key2:true, ...}\r\n */\r\nfunction makeMap(str){\r\n  var obj = {}, items = str.split(\",\"), i;\r\n  for ( i = 0; i < items.length; i++ )\r\n    obj[ items[i] ] = true;\r\n  return obj;\r\n}\r\n\r\n\r\nif (msie < 9) {\r\n  nodeName_ = function(element) {\r\n    element = element.nodeName ? element : element[0];\r\n    return (element.scopeName && element.scopeName != 'HTML')\r\n      ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;\r\n  };\r\n} else {\r\n  nodeName_ = function(element) {\r\n    return element.nodeName ? element.nodeName : element[0].nodeName;\r\n  };\r\n}\r\n\r\n\r\nfunction map(obj, iterator, context) {\r\n  var results = [];\r\n  forEach(obj, function(value, index, list) {\r\n    results.push(iterator.call(context, value, index, list));\r\n  });\r\n  return results;\r\n}\r\n\r\n\r\n/**\r\n * @description\r\n * Determines the number of elements in an array, the number of properties an object has, or\r\n * the length of a string.\r\n *\r\n * Note: This function is used to augment the Object type in Angular expressions. See\r\n * {@link angular.Object} for more information about Angular arrays.\r\n *\r\n * @param {Object|Array|string} obj Object, array, or string to inspect.\r\n * @param {boolean} [ownPropsOnly=false] Count only \"own\" properties in an object\r\n * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.\r\n */\r\nfunction size(obj, ownPropsOnly) {\r\n  var size = 0, key;\r\n\r\n  if (isArray(obj) || isString(obj)) {\r\n    return obj.length;\r\n  } else if (isObject(obj)){\r\n    for (key in obj)\r\n      if (!ownPropsOnly || obj.hasOwnProperty(key))\r\n        size++;\r\n  }\r\n\r\n  return size;\r\n}\r\n\r\n\r\nfunction includes(array, obj) {\r\n  return indexOf(array, obj) != -1;\r\n}\r\n\r\nfunction indexOf(array, obj) {\r\n  if (array.indexOf) return array.indexOf(obj);\r\n\r\n  for ( var i = 0; i < array.length; i++) {\r\n    if (obj === array[i]) return i;\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction arrayRemove(array, value) {\r\n  var index = indexOf(array, value);\r\n  if (index >=0)\r\n    array.splice(index, 1);\r\n  return value;\r\n}\r\n\r\nfunction isLeafNode (node) {\r\n  if (node) {\r\n    switch (node.nodeName) {\r\n    case \"OPTION\":\r\n    case \"PRE\":\r\n    case \"TITLE\":\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.copy\r\n * @function\r\n *\r\n * @description\r\n * Creates a deep copy of `source`, which should be an object or an array.\r\n *\r\n * * If no destination is supplied, a copy of the object or array is created.\r\n * * If a destination is provided, all of its elements (for array) or properties (for objects)\r\n *   are deleted and then all elements/properties from the source are copied to it.\r\n * * If  `source` is not an object or array, `source` is returned.\r\n *\r\n * Note: this function is used to augment the Object type in Angular expressions. See\r\n * {@link ng.$filter} for more information about Angular arrays.\r\n *\r\n * @param {*} source The source that will be used to make a copy.\r\n *                   Can be any type, including primitives, `null`, and `undefined`.\r\n * @param {(Object|Array)=} destination Destination into which the source is copied. If\r\n *     provided, must be of the same type as `source`.\r\n * @returns {*} The copy or updated `destination`, if `destination` was specified.\r\n */\r\nfunction copy(source, destination){\r\n  if (isWindow(source) || isScope(source)) throw Error(\"Can't copy Window or Scope\");\r\n  if (!destination) {\r\n    destination = source;\r\n    if (source) {\r\n      if (isArray(source)) {\r\n        destination = copy(source, []);\r\n      } else if (isDate(source)) {\r\n        destination = new Date(source.getTime());\r\n      } else if (isObject(source)) {\r\n        destination = copy(source, {});\r\n      }\r\n    }\r\n  } else {\r\n    if (source === destination) throw Error(\"Can't copy equivalent objects or arrays\");\r\n    if (isArray(source)) {\r\n      destination.length = 0;\r\n      for ( var i = 0; i < source.length; i++) {\r\n        destination.push(copy(source[i]));\r\n      }\r\n    } else {\r\n      var h = destination.$$hashKey;\r\n      forEach(destination, function(value, key){\r\n        delete destination[key];\r\n      });\r\n      for ( var key in source) {\r\n        destination[key] = copy(source[key]);\r\n      }\r\n      setHashKey(destination,h);\r\n    }\r\n  }\r\n  return destination;\r\n}\r\n\r\n/**\r\n * Create a shallow copy of an object\r\n */\r\nfunction shallowCopy(src, dst) {\r\n  dst = dst || {};\r\n\r\n  for(var key in src) {\r\n    if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {\r\n      dst[key] = src[key];\r\n    }\r\n  }\r\n\r\n  return dst;\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.equals\r\n * @function\r\n *\r\n * @description\r\n * Determines if two objects or two values are equivalent. Supports value types, arrays and\r\n * objects.\r\n *\r\n * Two objects or values are considered equivalent if at least one of the following is true:\r\n *\r\n * * Both objects or values pass `===` comparison.\r\n * * Both objects or values are of the same type and all of their properties pass `===` comparison.\r\n * * Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)\r\n *\r\n * During a property comparison, properties of `function` type and properties with names\r\n * that begin with `$` are ignored.\r\n *\r\n * Scope and DOMWindow objects are being compared only by identify (`===`).\r\n *\r\n * @param {*} o1 Object or value to compare.\r\n * @param {*} o2 Object or value to compare.\r\n * @returns {boolean} True if arguments are equal.\r\n */\r\nfunction equals(o1, o2) {\r\n  if (o1 === o2) return true;\r\n  if (o1 === null || o2 === null) return false;\r\n  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\r\n  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;\r\n  if (t1 == t2) {\r\n    if (t1 == 'object') {\r\n      if (isArray(o1)) {\r\n        if ((length = o1.length) == o2.length) {\r\n          for(key=0; key<length; key++) {\r\n            if (!equals(o1[key], o2[key])) return false;\r\n          }\r\n          return true;\r\n        }\r\n      } else if (isDate(o1)) {\r\n        return isDate(o2) && o1.getTime() == o2.getTime();\r\n      } else {\r\n        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2)) return false;\r\n        keySet = {};\r\n        for(key in o1) {\r\n          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;\r\n          if (!equals(o1[key], o2[key])) return false;\r\n          keySet[key] = true;\r\n        }\r\n        for(key in o2) {\r\n          if (!keySet[key] &&\r\n              key.charAt(0) !== '$' &&\r\n              o2[key] !== undefined &&\r\n              !isFunction(o2[key])) return false;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction concat(array1, array2, index) {\r\n  return array1.concat(slice.call(array2, index));\r\n}\r\n\r\nfunction sliceArgs(args, startIndex) {\r\n  return slice.call(args, startIndex || 0);\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.bind\r\n * @function\r\n *\r\n * @description\r\n * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\r\n * `fn`). You can supply optional `args` that are prebound to the function. This feature is also\r\n * known as [function currying](http://en.wikipedia.org/wiki/Currying).\r\n *\r\n * @param {Object} self Context which `fn` should be evaluated in.\r\n * @param {function()} fn Function to be bound.\r\n * @param {...*} args Optional arguments to be prebound to the `fn` function call.\r\n * @returns {function()} Function that wraps the `fn` with all the specified bindings.\r\n */\r\nfunction bind(self, fn) {\r\n  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];\r\n  if (isFunction(fn) && !(fn instanceof RegExp)) {\r\n    return curryArgs.length\r\n      ? function() {\r\n          return arguments.length\r\n            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))\r\n            : fn.apply(self, curryArgs);\r\n        }\r\n      : function() {\r\n          return arguments.length\r\n            ? fn.apply(self, arguments)\r\n            : fn.call(self);\r\n        };\r\n  } else {\r\n    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)\r\n    return fn;\r\n  }\r\n}\r\n\r\n\r\nfunction toJsonReplacer(key, value) {\r\n  var val = value;\r\n\r\n  if (/^\\$+/.test(key)) {\r\n    val = undefined;\r\n  } else if (isWindow(value)) {\r\n    val = '$WINDOW';\r\n  } else if (value &&  document === value) {\r\n    val = '$DOCUMENT';\r\n  } else if (isScope(value)) {\r\n    val = '$SCOPE';\r\n  }\r\n\r\n  return val;\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.toJson\r\n * @function\r\n *\r\n * @description\r\n * Serializes input into a JSON-formatted string.\r\n *\r\n * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.\r\n * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.\r\n * @returns {string} Jsonified string representing `obj`.\r\n */\r\nfunction toJson(obj, pretty) {\r\n  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.fromJson\r\n * @function\r\n *\r\n * @description\r\n * Deserializes a JSON string.\r\n *\r\n * @param {string} json JSON string to deserialize.\r\n * @returns {Object|Array|Date|string|number} Deserialized thingy.\r\n */\r\nfunction fromJson(json) {\r\n  return isString(json)\r\n      ? JSON.parse(json)\r\n      : json;\r\n}\r\n\r\n\r\nfunction toBoolean(value) {\r\n  if (value && value.length !== 0) {\r\n    var v = lowercase(\"\" + value);\r\n    value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');\r\n  } else {\r\n    value = false;\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @returns {string} Returns the string representation of the element.\r\n */\r\nfunction startingTag(element) {\r\n  element = jqLite(element).clone();\r\n  try {\r\n    // turns out IE does not let you set .html() on elements which\r\n    // are not allowed to have children. So we just ignore it.\r\n    element.html('');\r\n  } catch(e) {}\r\n  // As Per DOM Standards\r\n  var TEXT_NODE = 3;\r\n  var elemHtml = jqLite('<div>').append(element).html();\r\n  try {\r\n    return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :\r\n        elemHtml.\r\n          match(/^(<[^>]+>)/)[1].\r\n          replace(/^<([\\w\\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });\r\n  } catch(e) {\r\n    return lowercase(elemHtml);\r\n  }\r\n\r\n}\r\n\r\n\r\n/////////////////////////////////////////////////\r\n\r\n/**\r\n * Parses an escaped url query string into key-value pairs.\r\n * @returns Object.<(string|boolean)>\r\n */\r\nfunction parseKeyValue(/**string*/keyValue) {\r\n  var obj = {}, key_value, key;\r\n  forEach((keyValue || \"\").split('&'), function(keyValue){\r\n    if (keyValue) {\r\n      key_value = keyValue.split('=');\r\n      key = decodeURIComponent(key_value[0]);\r\n      obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;\r\n    }\r\n  });\r\n  return obj;\r\n}\r\n\r\nfunction toKeyValue(obj) {\r\n  var parts = [];\r\n  forEach(obj, function(value, key) {\r\n    parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));\r\n  });\r\n  return parts.length ? parts.join('&') : '';\r\n}\r\n\r\n\r\n/**\r\n * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\r\n * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\r\n * segments:\r\n *    segment       = *pchar\r\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\r\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\r\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\r\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\r\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\r\n */\r\nfunction encodeUriSegment(val) {\r\n  return encodeUriQuery(val, true).\r\n             replace(/%26/gi, '&').\r\n             replace(/%3D/gi, '=').\r\n             replace(/%2B/gi, '+');\r\n}\r\n\r\n\r\n/**\r\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\r\n * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\r\n * encoded per http://tools.ietf.org/html/rfc3986:\r\n *    query       = *( pchar / \"/\" / \"?\" )\r\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\r\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\r\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\r\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\r\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\r\n */\r\nfunction encodeUriQuery(val, pctEncodeSpaces) {\r\n  return encodeURIComponent(val).\r\n             replace(/%40/gi, '@').\r\n             replace(/%3A/gi, ':').\r\n             replace(/%24/g, '$').\r\n             replace(/%2C/gi, ',').\r\n             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngApp\r\n *\r\n * @element ANY\r\n * @param {angular.Module} ngApp an optional application\r\n *   {@link angular.module module} name to load.\r\n *\r\n * @description\r\n *\r\n * Use this directive to auto-bootstrap an application. Only\r\n * one directive can be used per HTML document. The directive\r\n * designates the root of the application and is typically placed\r\n * at the root of the page.\r\n *\r\n * In the example below if the `ngApp` directive would not be placed\r\n * on the `html` element then the document would not be compiled\r\n * and the `{{ 1+2 }}` would not be resolved to `3`.\r\n *\r\n * `ngApp` is the easiest way to bootstrap an application.\r\n *\r\n <doc:example>\r\n   <doc:source>\r\n    I can add: 1 + 2 =  {{ 1+2 }}\r\n   </doc:source>\r\n </doc:example>\r\n *\r\n */\r\nfunction angularInit(element, bootstrap) {\r\n  var elements = [element],\r\n      appElement,\r\n      module,\r\n      names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\r\n      NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/;\r\n\r\n  function append(element) {\r\n    element && elements.push(element);\r\n  }\r\n\r\n  forEach(names, function(name) {\r\n    names[name] = true;\r\n    append(document.getElementById(name));\r\n    name = name.replace(':', '\\\\:');\r\n    if (element.querySelectorAll) {\r\n      forEach(element.querySelectorAll('.' + name), append);\r\n      forEach(element.querySelectorAll('.' + name + '\\\\:'), append);\r\n      forEach(element.querySelectorAll('[' + name + ']'), append);\r\n    }\r\n  });\r\n\r\n  forEach(elements, function(element) {\r\n    if (!appElement) {\r\n      var className = ' ' + element.className + ' ';\r\n      var match = NG_APP_CLASS_REGEXP.exec(className);\r\n      if (match) {\r\n        appElement = element;\r\n        module = (match[2] || '').replace(/\\s+/g, ',');\r\n      } else {\r\n        forEach(element.attributes, function(attr) {\r\n          if (!appElement && names[attr.name]) {\r\n            appElement = element;\r\n            module = attr.value;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n  if (appElement) {\r\n    bootstrap(appElement, module ? [module] : []);\r\n  }\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.bootstrap\r\n * @description\r\n * Use this function to manually start up angular application.\r\n *\r\n * See: {@link guide/bootstrap Bootstrap}\r\n *\r\n * @param {Element} element DOM element which is the root of angular application.\r\n * @param {Array<String|Function>=} modules an array of module declarations. See: {@link angular.module modules}\r\n * @returns {AUTO.$injector} Returns the newly created injector for this app.\r\n */\r\nfunction bootstrap(element, modules) {\r\n  var resumeBootstrapInternal = function() {\r\n    element = jqLite(element);\r\n    modules = modules || [];\r\n    modules.unshift(['$provide', function($provide) {\r\n      $provide.value('$rootElement', element);\r\n    }]);\r\n    modules.unshift('ng');\r\n    var injector = createInjector(modules);\r\n    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animator',\r\n       function(scope, element, compile, injector, animator) {\r\n        scope.$apply(function() {\r\n          element.data('$injector', injector);\r\n          compile(element)(scope);\r\n        });\r\n        animator.enabled(true);\r\n      }]\r\n    );\r\n    return injector;\r\n  };\r\n\r\n  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;\r\n\r\n  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {\r\n    return resumeBootstrapInternal();\r\n  }\r\n\r\n  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');\r\n  angular.resumeBootstrap = function(extraModules) {\r\n    forEach(extraModules, function(module) {\r\n      modules.push(module);\r\n    });\r\n    resumeBootstrapInternal();\r\n  };\r\n}\r\n\r\nvar SNAKE_CASE_REGEXP = /[A-Z]/g;\r\nfunction snake_case(name, separator){\r\n  separator = separator || '_';\r\n  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\r\n    return (pos ? separator : '') + letter.toLowerCase();\r\n  });\r\n}\r\n\r\nfunction bindJQuery() {\r\n  // bind to jQuery if present;\r\n  jQuery = window.jQuery;\r\n  // reset to jQuery or default to us.\r\n  if (jQuery) {\r\n    jqLite = jQuery;\r\n    extend(jQuery.fn, {\r\n      scope: JQLitePrototype.scope,\r\n      controller: JQLitePrototype.controller,\r\n      injector: JQLitePrototype.injector,\r\n      inheritedData: JQLitePrototype.inheritedData\r\n    });\r\n    JQLitePatchJQueryRemove('remove', true);\r\n    JQLitePatchJQueryRemove('empty');\r\n    JQLitePatchJQueryRemove('html');\r\n  } else {\r\n    jqLite = JQLite;\r\n  }\r\n  angular.element = jqLite;\r\n}\r\n\r\n/**\r\n * throw error if the argument is falsy.\r\n */\r\nfunction assertArg(arg, name, reason) {\r\n  if (!arg) {\r\n    throw new Error(\"Argument '\" + (name || '?') + \"' is \" + (reason || \"required\"));\r\n  }\r\n  return arg;\r\n}\r\n\r\nfunction assertArgFn(arg, name, acceptArrayAnnotation) {\r\n  if (acceptArrayAnnotation && isArray(arg)) {\r\n      arg = arg[arg.length - 1];\r\n  }\r\n\r\n  assertArg(isFunction(arg), name, 'not a function, got ' +\r\n      (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));\r\n  return arg;\r\n}\r\n\r\n/**\r\n * @ngdoc interface\r\n * @name angular.Module\r\n * @description\r\n *\r\n * Interface for configuring angular {@link angular.module modules}.\r\n */\r\n\r\nfunction setupModuleLoader(window) {\r\n\r\n  function ensure(obj, name, factory) {\r\n    return obj[name] || (obj[name] = factory());\r\n  }\r\n\r\n  return ensure(ensure(window, 'angular', Object), 'module', function() {\r\n    /** @type {Object.<string, angular.Module>} */\r\n    var modules = {};\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name angular.module\r\n     * @description\r\n     *\r\n     * The `angular.module` is a global place for creating and registering Angular modules. All\r\n     * modules (angular core or 3rd party) that should be available to an application must be\r\n     * registered using this mechanism.\r\n     *\r\n     *\r\n     * # Module\r\n     *\r\n     * A module is a collocation of services, directives, filters, and configuration information. Module\r\n     * is used to configure the {@link AUTO.$injector $injector}.\r\n     *\r\n     * <pre>\r\n     * // Create a new module\r\n     * var myModule = angular.module('myModule', []);\r\n     *\r\n     * // register a new service\r\n     * myModule.value('appName', 'MyCoolApp');\r\n     *\r\n     * // configure existing services inside initialization blocks.\r\n     * myModule.config(function($locationProvider) {\r\n     *   // Configure existing providers\r\n     *   $locationProvider.hashPrefix('!');\r\n     * });\r\n     * </pre>\r\n     *\r\n     * Then you can create an injector and load your modules like this:\r\n     *\r\n     * <pre>\r\n     * var injector = angular.injector(['ng', 'MyModule'])\r\n     * </pre>\r\n     *\r\n     * However it's more likely that you'll just use\r\n     * {@link ng.directive:ngApp ngApp} or\r\n     * {@link angular.bootstrap} to simplify this process for you.\r\n     *\r\n     * @param {!string} name The name of the module to create or retrieve.\r\n     * @param {Array.<string>=} requires If specified then new module is being created. If unspecified then the\r\n     *        the module is being retrieved for further configuration.\r\n     * @param {Function} configFn Optional configuration function for the module. Same as\r\n     *        {@link angular.Module#config Module#config()}.\r\n     * @returns {module} new module with the {@link angular.Module} api.\r\n     */\r\n    return function module(name, requires, configFn) {\r\n      if (requires && modules.hasOwnProperty(name)) {\r\n        modules[name] = null;\r\n      }\r\n      return ensure(modules, name, function() {\r\n        if (!requires) {\r\n          throw Error('No module: ' + name);\r\n        }\r\n\r\n        /** @type {!Array.<Array.<*>>} */\r\n        var invokeQueue = [];\r\n\r\n        /** @type {!Array.<Function>} */\r\n        var runBlocks = [];\r\n\r\n        var config = invokeLater('$injector', 'invoke');\r\n\r\n        /** @type {angular.Module} */\r\n        var moduleInstance = {\r\n          // Private state\r\n          _invokeQueue: invokeQueue,\r\n          _runBlocks: runBlocks,\r\n\r\n          /**\r\n           * @ngdoc property\r\n           * @name angular.Module#requires\r\n           * @propertyOf angular.Module\r\n           * @returns {Array.<string>} List of module names which must be loaded before this module.\r\n           * @description\r\n           * Holds the list of modules which the injector will load before the current module is loaded.\r\n           */\r\n          requires: requires,\r\n\r\n          /**\r\n           * @ngdoc property\r\n           * @name angular.Module#name\r\n           * @propertyOf angular.Module\r\n           * @returns {string} Name of the module.\r\n           * @description\r\n           */\r\n          name: name,\r\n\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#provider\r\n           * @methodOf angular.Module\r\n           * @param {string} name service name\r\n           * @param {Function} providerType Construction function for creating new instance of the service.\r\n           * @description\r\n           * See {@link AUTO.$provide#provider $provide.provider()}.\r\n           */\r\n          provider: invokeLater('$provide', 'provider'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#factory\r\n           * @methodOf angular.Module\r\n           * @param {string} name service name\r\n           * @param {Function} providerFunction Function for creating new instance of the service.\r\n           * @description\r\n           * See {@link AUTO.$provide#factory $provide.factory()}.\r\n           */\r\n          factory: invokeLater('$provide', 'factory'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#service\r\n           * @methodOf angular.Module\r\n           * @param {string} name service name\r\n           * @param {Function} constructor A constructor function that will be instantiated.\r\n           * @description\r\n           * See {@link AUTO.$provide#service $provide.service()}.\r\n           */\r\n          service: invokeLater('$provide', 'service'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#value\r\n           * @methodOf angular.Module\r\n           * @param {string} name service name\r\n           * @param {*} object Service instance object.\r\n           * @description\r\n           * See {@link AUTO.$provide#value $provide.value()}.\r\n           */\r\n          value: invokeLater('$provide', 'value'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#constant\r\n           * @methodOf angular.Module\r\n           * @param {string} name constant name\r\n           * @param {*} object Constant value.\r\n           * @description\r\n           * Because the constant are fixed, they get applied before other provide methods.\r\n           * See {@link AUTO.$provide#constant $provide.constant()}.\r\n           */\r\n          constant: invokeLater('$provide', 'constant', 'unshift'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#animation\r\n           * @methodOf angular.Module\r\n           * @param {string} name animation name\r\n           * @param {Function} animationFactory Factory function for creating new instance of an animation.\r\n           * @description\r\n           *\r\n           * Defines an animation hook that can be later used with {@link ng.directive:ngAnimate ngAnimate}\r\n           * alongside {@link ng.directive:ngAnimate#Description common ng directives} as well as custom directives.\r\n           * <pre>\r\n           * module.animation('animation-name', function($inject1, $inject2) {\r\n           *   return {\r\n           *     //this gets called in preparation to setup an animation\r\n           *     setup : function(element) { ... },\r\n           *\r\n           *     //this gets called once the animation is run\r\n           *     start : function(element, done, memo) { ... }\r\n           *   }\r\n           * })\r\n           * </pre>\r\n           *\r\n           * See {@link ng.$animationProvider#register $animationProvider.register()} and\r\n           * {@link ng.directive:ngAnimate ngAnimate} for more information.\r\n           */\r\n          animation: invokeLater('$animationProvider', 'register'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#filter\r\n           * @methodOf angular.Module\r\n           * @param {string} name Filter name.\r\n           * @param {Function} filterFactory Factory function for creating new instance of filter.\r\n           * @description\r\n           * See {@link ng.$filterProvider#register $filterProvider.register()}.\r\n           */\r\n          filter: invokeLater('$filterProvider', 'register'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#controller\r\n           * @methodOf angular.Module\r\n           * @param {string} name Controller name.\r\n           * @param {Function} constructor Controller constructor function.\r\n           * @description\r\n           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.\r\n           */\r\n          controller: invokeLater('$controllerProvider', 'register'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#directive\r\n           * @methodOf angular.Module\r\n           * @param {string} name directive name\r\n           * @param {Function} directiveFactory Factory function for creating new instance of\r\n           * directives.\r\n           * @description\r\n           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.\r\n           */\r\n          directive: invokeLater('$compileProvider', 'directive'),\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#config\r\n           * @methodOf angular.Module\r\n           * @param {Function} configFn Execute this function on module load. Useful for service\r\n           *    configuration.\r\n           * @description\r\n           * Use this method to register work which needs to be performed on module loading.\r\n           */\r\n          config: config,\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name angular.Module#run\r\n           * @methodOf angular.Module\r\n           * @param {Function} initializationFn Execute this function after injector creation.\r\n           *    Useful for application initialization.\r\n           * @description\r\n           * Use this method to register work which should be performed when the injector is done\r\n           * loading all modules.\r\n           */\r\n          run: function(block) {\r\n            runBlocks.push(block);\r\n            return this;\r\n          }\r\n        };\r\n\r\n        if (configFn) {\r\n          config(configFn);\r\n        }\r\n\r\n        return  moduleInstance;\r\n\r\n        /**\r\n         * @param {string} provider\r\n         * @param {string} method\r\n         * @param {String=} insertMethod\r\n         * @returns {angular.Module}\r\n         */\r\n        function invokeLater(provider, method, insertMethod) {\r\n          return function() {\r\n            invokeQueue[insertMethod || 'push']([provider, method, arguments]);\r\n            return moduleInstance;\r\n          }\r\n        }\r\n      });\r\n    };\r\n  });\r\n\r\n}\r\n\r\n/**\r\n * @ngdoc property\r\n * @name angular.version\r\n * @description\r\n * An object that contains information about the current AngularJS version. This object has the\r\n * following properties:\r\n *\r\n * - `full`  `{string}`  Full version string, such as \"0.9.18\".\r\n * - `major`  `{number}`  Major version number, such as \"0\".\r\n * - `minor`  `{number}`  Minor version number, such as \"9\".\r\n * - `dot`  `{number}`  Dot version number, such as \"18\".\r\n * - `codeName`  `{string}`  Code name of the release, such as \"jiggling-armfat\".\r\n */\r\nvar version = {\r\n  full: '1.1.5',    // all of these placeholder strings will be replaced by grunt's\r\n  major: 1,    // package task\r\n  minor: 1,\r\n  dot: 5,\r\n  codeName: 'triangle-squarification'\r\n};\r\n\r\n\r\nfunction publishExternalAPI(angular){\r\n  extend(angular, {\r\n    'bootstrap': bootstrap,\r\n    'copy': copy,\r\n    'extend': extend,\r\n    'equals': equals,\r\n    'element': jqLite,\r\n    'forEach': forEach,\r\n    'injector': createInjector,\r\n    'noop':noop,\r\n    'bind':bind,\r\n    'toJson': toJson,\r\n    'fromJson': fromJson,\r\n    'identity':identity,\r\n    'isUndefined': isUndefined,\r\n    'isDefined': isDefined,\r\n    'isString': isString,\r\n    'isFunction': isFunction,\r\n    'isObject': isObject,\r\n    'isNumber': isNumber,\r\n    'isElement': isElement,\r\n    'isArray': isArray,\r\n    'version': version,\r\n    'isDate': isDate,\r\n    'lowercase': lowercase,\r\n    'uppercase': uppercase,\r\n    'callbacks': {counter: 0},\r\n    'noConflict': noConflict\r\n  });\r\n\r\n  angularModule = setupModuleLoader(window);\r\n  try {\r\n    angularModule('ngLocale');\r\n  } catch (e) {\r\n    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);\r\n  }\r\n\r\n  angularModule('ng', ['ngLocale'], ['$provide',\r\n    function ngModule($provide) {\r\n      $provide.provider('$compile', $CompileProvider).\r\n        directive({\r\n            a: htmlAnchorDirective,\r\n            input: inputDirective,\r\n            textarea: inputDirective,\r\n            form: formDirective,\r\n            script: scriptDirective,\r\n            select: selectDirective,\r\n            style: styleDirective,\r\n            option: optionDirective,\r\n            ngBind: ngBindDirective,\r\n            ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,\r\n            ngBindTemplate: ngBindTemplateDirective,\r\n            ngClass: ngClassDirective,\r\n            ngClassEven: ngClassEvenDirective,\r\n            ngClassOdd: ngClassOddDirective,\r\n            ngCsp: ngCspDirective,\r\n            ngCloak: ngCloakDirective,\r\n            ngController: ngControllerDirective,\r\n            ngForm: ngFormDirective,\r\n            ngHide: ngHideDirective,\r\n            ngIf: ngIfDirective,\r\n            ngInclude: ngIncludeDirective,\r\n            ngInit: ngInitDirective,\r\n            ngNonBindable: ngNonBindableDirective,\r\n            ngPluralize: ngPluralizeDirective,\r\n            ngRepeat: ngRepeatDirective,\r\n            ngShow: ngShowDirective,\r\n            ngSubmit: ngSubmitDirective,\r\n            ngStyle: ngStyleDirective,\r\n            ngSwitch: ngSwitchDirective,\r\n            ngSwitchWhen: ngSwitchWhenDirective,\r\n            ngSwitchDefault: ngSwitchDefaultDirective,\r\n            ngOptions: ngOptionsDirective,\r\n            ngView: ngViewDirective,\r\n            ngTransclude: ngTranscludeDirective,\r\n            ngModel: ngModelDirective,\r\n            ngList: ngListDirective,\r\n            ngChange: ngChangeDirective,\r\n            required: requiredDirective,\r\n            ngRequired: requiredDirective,\r\n            ngValue: ngValueDirective\r\n        }).\r\n        directive(ngAttributeAliasDirectives).\r\n        directive(ngEventDirectives);\r\n      $provide.provider({\r\n        $anchorScroll: $AnchorScrollProvider,\r\n        $animation: $AnimationProvider,\r\n        $animator: $AnimatorProvider,\r\n        $browser: $BrowserProvider,\r\n        $cacheFactory: $CacheFactoryProvider,\r\n        $controller: $ControllerProvider,\r\n        $document: $DocumentProvider,\r\n        $exceptionHandler: $ExceptionHandlerProvider,\r\n        $filter: $FilterProvider,\r\n        $interpolate: $InterpolateProvider,\r\n        $http: $HttpProvider,\r\n        $httpBackend: $HttpBackendProvider,\r\n        $location: $LocationProvider,\r\n        $log: $LogProvider,\r\n        $parse: $ParseProvider,\r\n        $route: $RouteProvider,\r\n        $routeParams: $RouteParamsProvider,\r\n        $rootScope: $RootScopeProvider,\r\n        $q: $QProvider,\r\n        $sniffer: $SnifferProvider,\r\n        $templateCache: $TemplateCacheProvider,\r\n        $timeout: $TimeoutProvider,\r\n        $window: $WindowProvider\r\n      });\r\n    }\r\n  ]);\r\n}\r\n\r\n//////////////////////////////////\r\n//JQLite\r\n//////////////////////////////////\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.element\r\n * @function\r\n *\r\n * @description\r\n * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.\r\n * `angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if\r\n * jQuery is available, or a function that wraps the element or string in Angular's jQuery lite\r\n * implementation (commonly referred to as jqLite).\r\n *\r\n * Real jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`\r\n * event fired.\r\n *\r\n * jqLite is a tiny, API-compatible subset of jQuery that allows\r\n * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality\r\n * within a very small footprint, so only a subset of the jQuery API - methods, arguments and\r\n * invocation styles - are supported.\r\n *\r\n * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never\r\n * raw DOM references.\r\n *\r\n * ## Angular's jQuery lite provides the following methods:\r\n *\r\n * - [addClass()](http://api.jquery.com/addClass/)\r\n * - [after()](http://api.jquery.com/after/)\r\n * - [append()](http://api.jquery.com/append/)\r\n * - [attr()](http://api.jquery.com/attr/)\r\n * - [bind()](http://api.jquery.com/bind/) - Does not support namespaces\r\n * - [children()](http://api.jquery.com/children/) - Does not support selectors\r\n * - [clone()](http://api.jquery.com/clone/)\r\n * - [contents()](http://api.jquery.com/contents/)\r\n * - [css()](http://api.jquery.com/css/)\r\n * - [data()](http://api.jquery.com/data/)\r\n * - [eq()](http://api.jquery.com/eq/)\r\n * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name\r\n * - [hasClass()](http://api.jquery.com/hasClass/)\r\n * - [html()](http://api.jquery.com/html/)\r\n * - [next()](http://api.jquery.com/next/) - Does not support selectors\r\n * - [parent()](http://api.jquery.com/parent/) - Does not support selectors\r\n * - [prepend()](http://api.jquery.com/prepend/)\r\n * - [prop()](http://api.jquery.com/prop/)\r\n * - [ready()](http://api.jquery.com/ready/)\r\n * - [remove()](http://api.jquery.com/remove/)\r\n * - [removeAttr()](http://api.jquery.com/removeAttr/)\r\n * - [removeClass()](http://api.jquery.com/removeClass/)\r\n * - [removeData()](http://api.jquery.com/removeData/)\r\n * - [replaceWith()](http://api.jquery.com/replaceWith/)\r\n * - [text()](http://api.jquery.com/text/)\r\n * - [toggleClass()](http://api.jquery.com/toggleClass/)\r\n * - [triggerHandler()](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.\r\n * - [unbind()](http://api.jquery.com/unbind/) - Does not support namespaces\r\n * - [val()](http://api.jquery.com/val/)\r\n * - [wrap()](http://api.jquery.com/wrap/)\r\n *\r\n * ## In addition to the above, Angular provides additional methods to both jQuery and jQuery lite:\r\n *\r\n * - `controller(name)` - retrieves the controller of the current element or its parent. By default\r\n *   retrieves controller associated with the `ngController` directive. If `name` is provided as\r\n *   camelCase directive name, then the controller for this directive will be retrieved (e.g.\r\n *   `'ngModel'`).\r\n * - `injector()` - retrieves the injector of the current element or its parent.\r\n * - `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current\r\n *   element or its parent.\r\n * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top\r\n *   parent element is reached.\r\n *\r\n * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.\r\n * @returns {Object} jQuery object.\r\n */\r\n\r\nvar jqCache = JQLite.cache = {},\r\n    jqName = JQLite.expando = 'ng-' + new Date().getTime(),\r\n    jqId = 1,\r\n    addEventListenerFn = (window.document.addEventListener\r\n      ? function(element, type, fn) {element.addEventListener(type, fn, false);}\r\n      : function(element, type, fn) {element.attachEvent('on' + type, fn);}),\r\n    removeEventListenerFn = (window.document.removeEventListener\r\n      ? function(element, type, fn) {element.removeEventListener(type, fn, false); }\r\n      : function(element, type, fn) {element.detachEvent('on' + type, fn); });\r\n\r\nfunction jqNextId() { return ++jqId; }\r\n\r\n\r\nvar SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\r\nvar MOZ_HACK_REGEXP = /^moz([A-Z])/;\r\n\r\n/**\r\n * Converts snake_case to camelCase.\r\n * Also there is special case for Moz prefix starting with upper case letter.\r\n * @param name Name to normalize\r\n */\r\nfunction camelCase(name) {\r\n  return name.\r\n    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {\r\n      return offset ? letter.toUpperCase() : letter;\r\n    }).\r\n    replace(MOZ_HACK_REGEXP, 'Moz$1');\r\n}\r\n\r\n/////////////////////////////////////////////\r\n// jQuery mutation patch\r\n//\r\n//  In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a\r\n// $destroy event on all DOM nodes being removed.\r\n//\r\n/////////////////////////////////////////////\r\n\r\nfunction JQLitePatchJQueryRemove(name, dispatchThis) {\r\n  var originalJqFn = jQuery.fn[name];\r\n  originalJqFn = originalJqFn.$original || originalJqFn;\r\n  removePatch.$original = originalJqFn;\r\n  jQuery.fn[name] = removePatch;\r\n\r\n  function removePatch() {\r\n    var list = [this],\r\n        fireEvent = dispatchThis,\r\n        set, setIndex, setLength,\r\n        element, childIndex, childLength, children,\r\n        fns, events;\r\n\r\n    while(list.length) {\r\n      set = list.shift();\r\n      for(setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {\r\n        element = jqLite(set[setIndex]);\r\n        if (fireEvent) {\r\n          element.triggerHandler('$destroy');\r\n        } else {\r\n          fireEvent = !fireEvent;\r\n        }\r\n        for(childIndex = 0, childLength = (children = element.children()).length;\r\n            childIndex < childLength;\r\n            childIndex++) {\r\n          list.push(jQuery(children[childIndex]));\r\n        }\r\n      }\r\n    }\r\n    return originalJqFn.apply(this, arguments);\r\n  }\r\n}\r\n\r\n/////////////////////////////////////////////\r\nfunction JQLite(element) {\r\n  if (element instanceof JQLite) {\r\n    return element;\r\n  }\r\n  if (!(this instanceof JQLite)) {\r\n    if (isString(element) && element.charAt(0) != '<') {\r\n      throw Error('selectors not implemented');\r\n    }\r\n    return new JQLite(element);\r\n  }\r\n\r\n  if (isString(element)) {\r\n    var div = document.createElement('div');\r\n    // Read about the NoScope elements here:\r\n    // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx\r\n    div.innerHTML = '<div>&#160;</div>' + element; // IE insanity to make NoScope elements work!\r\n    div.removeChild(div.firstChild); // remove the superfluous div\r\n    JQLiteAddNodes(this, div.childNodes);\r\n    this.remove(); // detach the elements from the temporary DOM div.\r\n  } else {\r\n    JQLiteAddNodes(this, element);\r\n  }\r\n}\r\n\r\nfunction JQLiteClone(element) {\r\n  return element.cloneNode(true);\r\n}\r\n\r\nfunction JQLiteDealoc(element){\r\n  JQLiteRemoveData(element);\r\n  for ( var i = 0, children = element.childNodes || []; i < children.length; i++) {\r\n    JQLiteDealoc(children[i]);\r\n  }\r\n}\r\n\r\nfunction JQLiteUnbind(element, type, fn) {\r\n  var events = JQLiteExpandoStore(element, 'events'),\r\n      handle = JQLiteExpandoStore(element, 'handle');\r\n\r\n  if (!handle) return; //no listeners registered\r\n\r\n  if (isUndefined(type)) {\r\n    forEach(events, function(eventHandler, type) {\r\n      removeEventListenerFn(element, type, eventHandler);\r\n      delete events[type];\r\n    });\r\n  } else {\r\n    if (isUndefined(fn)) {\r\n      removeEventListenerFn(element, type, events[type]);\r\n      delete events[type];\r\n    } else {\r\n      arrayRemove(events[type], fn);\r\n    }\r\n  }\r\n}\r\n\r\nfunction JQLiteRemoveData(element) {\r\n  var expandoId = element[jqName],\r\n      expandoStore = jqCache[expandoId];\r\n\r\n  if (expandoStore) {\r\n    if (expandoStore.handle) {\r\n      expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');\r\n      JQLiteUnbind(element);\r\n    }\r\n    delete jqCache[expandoId];\r\n    element[jqName] = undefined; // ie does not allow deletion of attributes on elements.\r\n  }\r\n}\r\n\r\nfunction JQLiteExpandoStore(element, key, value) {\r\n  var expandoId = element[jqName],\r\n      expandoStore = jqCache[expandoId || -1];\r\n\r\n  if (isDefined(value)) {\r\n    if (!expandoStore) {\r\n      element[jqName] = expandoId = jqNextId();\r\n      expandoStore = jqCache[expandoId] = {};\r\n    }\r\n    expandoStore[key] = value;\r\n  } else {\r\n    return expandoStore && expandoStore[key];\r\n  }\r\n}\r\n\r\nfunction JQLiteData(element, key, value) {\r\n  var data = JQLiteExpandoStore(element, 'data'),\r\n      isSetter = isDefined(value),\r\n      keyDefined = !isSetter && isDefined(key),\r\n      isSimpleGetter = keyDefined && !isObject(key);\r\n\r\n  if (!data && !isSimpleGetter) {\r\n    JQLiteExpandoStore(element, 'data', data = {});\r\n  }\r\n\r\n  if (isSetter) {\r\n    data[key] = value;\r\n  } else {\r\n    if (keyDefined) {\r\n      if (isSimpleGetter) {\r\n        // don't create data in this case.\r\n        return data && data[key];\r\n      } else {\r\n        extend(data, key);\r\n      }\r\n    } else {\r\n      return data;\r\n    }\r\n  }\r\n}\r\n\r\nfunction JQLiteHasClass(element, selector) {\r\n  return ((\" \" + element.className + \" \").replace(/[\\n\\t]/g, \" \").\r\n      indexOf( \" \" + selector + \" \" ) > -1);\r\n}\r\n\r\nfunction JQLiteRemoveClass(element, cssClasses) {\r\n  if (cssClasses) {\r\n    forEach(cssClasses.split(' '), function(cssClass) {\r\n      element.className = trim(\r\n          (\" \" + element.className + \" \")\r\n          .replace(/[\\n\\t]/g, \" \")\r\n          .replace(\" \" + trim(cssClass) + \" \", \" \")\r\n      );\r\n    });\r\n  }\r\n}\r\n\r\nfunction JQLiteAddClass(element, cssClasses) {\r\n  if (cssClasses) {\r\n    forEach(cssClasses.split(' '), function(cssClass) {\r\n      if (!JQLiteHasClass(element, cssClass)) {\r\n        element.className = trim(element.className + ' ' + trim(cssClass));\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction JQLiteAddNodes(root, elements) {\r\n  if (elements) {\r\n    elements = (!elements.nodeName && isDefined(elements.length) && !isWindow(elements))\r\n      ? elements\r\n      : [ elements ];\r\n    for(var i=0; i < elements.length; i++) {\r\n      root.push(elements[i]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction JQLiteController(element, name) {\r\n  return JQLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');\r\n}\r\n\r\nfunction JQLiteInheritedData(element, name, value) {\r\n  element = jqLite(element);\r\n\r\n  // if element is the document object work with the html element instead\r\n  // this makes $(document).scope() possible\r\n  if(element[0].nodeType == 9) {\r\n    element = element.find('html');\r\n  }\r\n\r\n  while (element.length) {\r\n    if (value = element.data(name)) return value;\r\n    element = element.parent();\r\n  }\r\n}\r\n\r\n//////////////////////////////////////////\r\n// Functions which are declared directly.\r\n//////////////////////////////////////////\r\nvar JQLitePrototype = JQLite.prototype = {\r\n  ready: function(fn) {\r\n    var fired = false;\r\n\r\n    function trigger() {\r\n      if (fired) return;\r\n      fired = true;\r\n      fn();\r\n    }\r\n\r\n    // check if document already is loaded\r\n    if (document.readyState === 'complete'){\r\n      setTimeout(trigger);\r\n    } else {\r\n      this.bind('DOMContentLoaded', trigger); // works for modern browsers and IE9\r\n      // we can not use jqLite since we are not done loading and jQuery could be loaded later.\r\n      JQLite(window).bind('load', trigger); // fallback to window.onload for others\r\n    }\r\n  },\r\n  toString: function() {\r\n    var value = [];\r\n    forEach(this, function(e){ value.push('' + e);});\r\n    return '[' + value.join(', ') + ']';\r\n  },\r\n\r\n  eq: function(index) {\r\n      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);\r\n  },\r\n\r\n  length: 0,\r\n  push: push,\r\n  sort: [].sort,\r\n  splice: [].splice\r\n};\r\n\r\n//////////////////////////////////////////\r\n// Functions iterating getter/setters.\r\n// these functions return self on setter and\r\n// value on get.\r\n//////////////////////////////////////////\r\nvar BOOLEAN_ATTR = {};\r\nforEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {\r\n  BOOLEAN_ATTR[lowercase(value)] = value;\r\n});\r\nvar BOOLEAN_ELEMENTS = {};\r\nforEach('input,select,option,textarea,button,form,details'.split(','), function(value) {\r\n  BOOLEAN_ELEMENTS[uppercase(value)] = true;\r\n});\r\n\r\nfunction getBooleanAttrName(element, name) {\r\n  // check dom last since we will most likely fail on name\r\n  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];\r\n\r\n  // booleanAttr is here twice to minimize DOM access\r\n  return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;\r\n}\r\n\r\nforEach({\r\n  data: JQLiteData,\r\n  inheritedData: JQLiteInheritedData,\r\n\r\n  scope: function(element) {\r\n    return JQLiteInheritedData(element, '$scope');\r\n  },\r\n\r\n  controller: JQLiteController ,\r\n\r\n  injector: function(element) {\r\n    return JQLiteInheritedData(element, '$injector');\r\n  },\r\n\r\n  removeAttr: function(element,name) {\r\n    element.removeAttribute(name);\r\n  },\r\n\r\n  hasClass: JQLiteHasClass,\r\n\r\n  css: function(element, name, value) {\r\n    name = camelCase(name);\r\n\r\n    if (isDefined(value)) {\r\n      element.style[name] = value;\r\n    } else {\r\n      var val;\r\n\r\n      if (msie <= 8) {\r\n        // this is some IE specific weirdness that jQuery 1.6.4 does not sure why\r\n        val = element.currentStyle && element.currentStyle[name];\r\n        if (val === '') val = 'auto';\r\n      }\r\n\r\n      val = val || element.style[name];\r\n\r\n      if (msie <= 8) {\r\n        // jquery weirdness :-/\r\n        val = (val === '') ? undefined : val;\r\n      }\r\n\r\n      return  val;\r\n    }\r\n  },\r\n\r\n  attr: function(element, name, value){\r\n    var lowercasedName = lowercase(name);\r\n    if (BOOLEAN_ATTR[lowercasedName]) {\r\n      if (isDefined(value)) {\r\n        if (!!value) {\r\n          element[name] = true;\r\n          element.setAttribute(name, lowercasedName);\r\n        } else {\r\n          element[name] = false;\r\n          element.removeAttribute(lowercasedName);\r\n        }\r\n      } else {\r\n        return (element[name] ||\r\n                 (element.attributes.getNamedItem(name)|| noop).specified)\r\n               ? lowercasedName\r\n               : undefined;\r\n      }\r\n    } else if (isDefined(value)) {\r\n      element.setAttribute(name, value);\r\n    } else if (element.getAttribute) {\r\n      // the extra argument \"2\" is to get the right thing for a.href in IE, see jQuery code\r\n      // some elements (e.g. Document) don't have get attribute, so return undefined\r\n      var ret = element.getAttribute(name, 2);\r\n      // normalize non-existing attributes to undefined (as jQuery)\r\n      return ret === null ? undefined : ret;\r\n    }\r\n  },\r\n\r\n  prop: function(element, name, value) {\r\n    if (isDefined(value)) {\r\n      element[name] = value;\r\n    } else {\r\n      return element[name];\r\n    }\r\n  },\r\n\r\n  text: extend((msie < 9)\r\n      ? function(element, value) {\r\n        if (element.nodeType == 1 /** Element */) {\r\n          if (isUndefined(value))\r\n            return element.innerText;\r\n          element.innerText = value;\r\n        } else {\r\n          if (isUndefined(value))\r\n            return element.nodeValue;\r\n          element.nodeValue = value;\r\n        }\r\n      }\r\n      : function(element, value) {\r\n        if (isUndefined(value)) {\r\n          return element.textContent;\r\n        }\r\n        element.textContent = value;\r\n      }, {$dv:''}),\r\n\r\n  val: function(element, value) {\r\n    if (isUndefined(value)) {\r\n      return element.value;\r\n    }\r\n    element.value = value;\r\n  },\r\n\r\n  html: function(element, value) {\r\n    if (isUndefined(value)) {\r\n      return element.innerHTML;\r\n    }\r\n    for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {\r\n      JQLiteDealoc(childNodes[i]);\r\n    }\r\n    element.innerHTML = value;\r\n  }\r\n}, function(fn, name){\r\n  /**\r\n   * Properties: writes return selection, reads return first value\r\n   */\r\n  JQLite.prototype[name] = function(arg1, arg2) {\r\n    var i, key;\r\n\r\n    // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it\r\n    // in a way that survives minification.\r\n    if (((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController)) ? arg1 : arg2) === undefined) {\r\n      if (isObject(arg1)) {\r\n\r\n        // we are a write, but the object properties are the key/values\r\n        for(i=0; i < this.length; i++) {\r\n          if (fn === JQLiteData) {\r\n            // data() takes the whole object in jQuery\r\n            fn(this[i], arg1);\r\n          } else {\r\n            for (key in arg1) {\r\n              fn(this[i], key, arg1[key]);\r\n            }\r\n          }\r\n        }\r\n        // return self for chaining\r\n        return this;\r\n      } else {\r\n        // we are a read, so read the first child.\r\n        if (this.length)\r\n          return fn(this[0], arg1, arg2);\r\n      }\r\n    } else {\r\n      // we are a write, so apply to all children\r\n      for(i=0; i < this.length; i++) {\r\n        fn(this[i], arg1, arg2);\r\n      }\r\n      // return self for chaining\r\n      return this;\r\n    }\r\n    return fn.$dv;\r\n  };\r\n});\r\n\r\nfunction createEventHandler(element, events) {\r\n  var eventHandler = function (event, type) {\r\n    if (!event.preventDefault) {\r\n      event.preventDefault = function() {\r\n        event.returnValue = false; //ie\r\n      };\r\n    }\r\n\r\n    if (!event.stopPropagation) {\r\n      event.stopPropagation = function() {\r\n        event.cancelBubble = true; //ie\r\n      };\r\n    }\r\n\r\n    if (!event.target) {\r\n      event.target = event.srcElement || document;\r\n    }\r\n\r\n    if (isUndefined(event.defaultPrevented)) {\r\n      var prevent = event.preventDefault;\r\n      event.preventDefault = function() {\r\n        event.defaultPrevented = true;\r\n        prevent.call(event);\r\n      };\r\n      event.defaultPrevented = false;\r\n    }\r\n\r\n    event.isDefaultPrevented = function() {\r\n      return event.defaultPrevented || event.returnValue == false;\r\n    };\r\n\r\n    forEach(events[type || event.type], function(fn) {\r\n      fn.call(element, event);\r\n    });\r\n\r\n    // Remove monkey-patched methods (IE),\r\n    // as they would cause memory leaks in IE8.\r\n    if (msie <= 8) {\r\n      // IE7/8 does not allow to delete property on native object\r\n      event.preventDefault = null;\r\n      event.stopPropagation = null;\r\n      event.isDefaultPrevented = null;\r\n    } else {\r\n      // It shouldn't affect normal browsers (native methods are defined on prototype).\r\n      delete event.preventDefault;\r\n      delete event.stopPropagation;\r\n      delete event.isDefaultPrevented;\r\n    }\r\n  };\r\n  eventHandler.elem = element;\r\n  return eventHandler;\r\n}\r\n\r\n//////////////////////////////////////////\r\n// Functions iterating traversal.\r\n// These functions chain results into a single\r\n// selector.\r\n//////////////////////////////////////////\r\nforEach({\r\n  removeData: JQLiteRemoveData,\r\n\r\n  dealoc: JQLiteDealoc,\r\n\r\n  bind: function bindFn(element, type, fn){\r\n    var events = JQLiteExpandoStore(element, 'events'),\r\n        handle = JQLiteExpandoStore(element, 'handle');\r\n\r\n    if (!events) JQLiteExpandoStore(element, 'events', events = {});\r\n    if (!handle) JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));\r\n\r\n    forEach(type.split(' '), function(type){\r\n      var eventFns = events[type];\r\n\r\n      if (!eventFns) {\r\n        if (type == 'mouseenter' || type == 'mouseleave') {\r\n          var contains = document.body.contains || document.body.compareDocumentPosition ?\r\n          function( a, b ) {\r\n            var adown = a.nodeType === 9 ? a.documentElement : a,\r\n            bup = b && b.parentNode;\r\n            return a === bup || !!( bup && bup.nodeType === 1 && (\r\n              adown.contains ?\r\n              adown.contains( bup ) :\r\n              a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\r\n              ));\r\n            } :\r\n            function( a, b ) {\r\n              if ( b ) {\r\n                while ( (b = b.parentNode) ) {\r\n                  if ( b === a ) {\r\n                    return true;\r\n                  }\r\n                }\r\n              }\r\n              return false;\r\n            };\t\r\n\r\n          events[type] = [];\r\n\t\t\r\n\t\t  // Refer to jQuery's implementation of mouseenter & mouseleave\r\n          // Read about mouseenter and mouseleave:\r\n          // http://www.quirksmode.org/js/events_mouse.html#link8\r\n          var eventmap = { mouseleave : \"mouseout\", mouseenter : \"mouseover\"}          \r\n          bindFn(element, eventmap[type], function(event) {\r\n            var ret, target = this, related = event.relatedTarget;\r\n            // For mousenter/leave call the handler if related is outside the target.\r\n            // NB: No relatedTarget if the mouse left/entered the browser window\r\n            if ( !related || (related !== target && !contains(target, related)) ){\r\n              handle(event, type);\r\n            }\t\r\n\r\n          });\r\n\r\n        } else {\r\n          addEventListenerFn(element, type, handle);\r\n          events[type] = [];\r\n        }\r\n        eventFns = events[type]\r\n      }\r\n      eventFns.push(fn);\r\n    });\r\n  },\r\n\r\n  unbind: JQLiteUnbind,\r\n\r\n  replaceWith: function(element, replaceNode) {\r\n    var index, parent = element.parentNode;\r\n    JQLiteDealoc(element);\r\n    forEach(new JQLite(replaceNode), function(node){\r\n      if (index) {\r\n        parent.insertBefore(node, index.nextSibling);\r\n      } else {\r\n        parent.replaceChild(node, element);\r\n      }\r\n      index = node;\r\n    });\r\n  },\r\n\r\n  children: function(element) {\r\n    var children = [];\r\n    forEach(element.childNodes, function(element){\r\n      if (element.nodeType === 1)\r\n        children.push(element);\r\n    });\r\n    return children;\r\n  },\r\n\r\n  contents: function(element) {\r\n    return element.childNodes || [];\r\n  },\r\n\r\n  append: function(element, node) {\r\n    forEach(new JQLite(node), function(child){\r\n      if (element.nodeType === 1 || element.nodeType === 11) {\r\n        element.appendChild(child);\r\n      }\r\n    });\r\n  },\r\n\r\n  prepend: function(element, node) {\r\n    if (element.nodeType === 1) {\r\n      var index = element.firstChild;\r\n      forEach(new JQLite(node), function(child){\r\n        if (index) {\r\n          element.insertBefore(child, index);\r\n        } else {\r\n          element.appendChild(child);\r\n          index = child;\r\n        }\r\n      });\r\n    }\r\n  },\r\n\r\n  wrap: function(element, wrapNode) {\r\n    wrapNode = jqLite(wrapNode)[0];\r\n    var parent = element.parentNode;\r\n    if (parent) {\r\n      parent.replaceChild(wrapNode, element);\r\n    }\r\n    wrapNode.appendChild(element);\r\n  },\r\n\r\n  remove: function(element) {\r\n    JQLiteDealoc(element);\r\n    var parent = element.parentNode;\r\n    if (parent) parent.removeChild(element);\r\n  },\r\n\r\n  after: function(element, newElement) {\r\n    var index = element, parent = element.parentNode;\r\n    forEach(new JQLite(newElement), function(node){\r\n      parent.insertBefore(node, index.nextSibling);\r\n      index = node;\r\n    });\r\n  },\r\n\r\n  addClass: JQLiteAddClass,\r\n  removeClass: JQLiteRemoveClass,\r\n\r\n  toggleClass: function(element, selector, condition) {\r\n    if (isUndefined(condition)) {\r\n      condition = !JQLiteHasClass(element, selector);\r\n    }\r\n    (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);\r\n  },\r\n\r\n  parent: function(element) {\r\n    var parent = element.parentNode;\r\n    return parent && parent.nodeType !== 11 ? parent : null;\r\n  },\r\n\r\n  next: function(element) {\r\n    if (element.nextElementSibling) {\r\n      return element.nextElementSibling;\r\n    }\r\n\r\n    // IE8 doesn't have nextElementSibling\r\n    var elm = element.nextSibling;\r\n    while (elm != null && elm.nodeType !== 1) {\r\n      elm = elm.nextSibling;\r\n    }\r\n    return elm;\r\n  },\r\n\r\n  find: function(element, selector) {\r\n    return element.getElementsByTagName(selector);\r\n  },\r\n\r\n  clone: JQLiteClone,\r\n\r\n  triggerHandler: function(element, eventName) {\r\n    var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];\r\n    var event;\r\n\r\n    forEach(eventFns, function(fn) {\r\n      fn.call(element, {preventDefault: noop});\r\n    });\r\n  }\r\n}, function(fn, name){\r\n  /**\r\n   * chaining functions\r\n   */\r\n  JQLite.prototype[name] = function(arg1, arg2) {\r\n    var value;\r\n    for(var i=0; i < this.length; i++) {\r\n      if (value == undefined) {\r\n        value = fn(this[i], arg1, arg2);\r\n        if (value !== undefined) {\r\n          // any function which returns a value needs to be wrapped\r\n          value = jqLite(value);\r\n        }\r\n      } else {\r\n        JQLiteAddNodes(value, fn(this[i], arg1, arg2));\r\n      }\r\n    }\r\n    return value == undefined ? this : value;\r\n  };\r\n});\r\n\r\n/**\r\n * Computes a hash of an 'obj'.\r\n * Hash of a:\r\n *  string is string\r\n *  number is number as string\r\n *  object is either result of calling $$hashKey function on the object or uniquely generated id,\r\n *         that is also assigned to the $$hashKey property of the object.\r\n *\r\n * @param obj\r\n * @returns {string} hash string such that the same input will have the same hash string.\r\n *         The resulting string key is in 'type:hashKey' format.\r\n */\r\nfunction hashKey(obj) {\r\n  var objType = typeof obj,\r\n      key;\r\n\r\n  if (objType == 'object' && obj !== null) {\r\n    if (typeof (key = obj.$$hashKey) == 'function') {\r\n      // must invoke on object to keep the right this\r\n      key = obj.$$hashKey();\r\n    } else if (key === undefined) {\r\n      key = obj.$$hashKey = nextUid();\r\n    }\r\n  } else {\r\n    key = obj;\r\n  }\r\n\r\n  return objType + ':' + key;\r\n}\r\n\r\n/**\r\n * HashMap which can use objects as keys\r\n */\r\nfunction HashMap(array){\r\n  forEach(array, this.put, this);\r\n}\r\nHashMap.prototype = {\r\n  /**\r\n   * Store key value pair\r\n   * @param key key to store can be any type\r\n   * @param value value to store can be any type\r\n   */\r\n  put: function(key, value) {\r\n    this[hashKey(key)] = value;\r\n  },\r\n\r\n  /**\r\n   * @param key\r\n   * @returns the value for the key\r\n   */\r\n  get: function(key) {\r\n    return this[hashKey(key)];\r\n  },\r\n\r\n  /**\r\n   * Remove the key/value pair\r\n   * @param key\r\n   */\r\n  remove: function(key) {\r\n    var value = this[key = hashKey(key)];\r\n    delete this[key];\r\n    return value;\r\n  }\r\n};\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.injector\r\n * @function\r\n *\r\n * @description\r\n * Creates an injector function that can be used for retrieving services as well as for\r\n * dependency injection (see {@link guide/di dependency injection}).\r\n *\r\n\r\n * @param {Array.<string|Function>} modules A list of module functions or their aliases. See\r\n *        {@link angular.module}. The `ng` module must be explicitly added.\r\n * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.\r\n *\r\n * @example\r\n * Typical usage\r\n * <pre>\r\n *   // create an injector\r\n *   var $injector = angular.injector(['ng']);\r\n *\r\n *   // use the injector to kick off your application\r\n *   // use the type inference to auto inject arguments, or use implicit injection\r\n *   $injector.invoke(function($rootScope, $compile, $document){\r\n *     $compile($document)($rootScope);\r\n *     $rootScope.$digest();\r\n *   });\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc overview\r\n * @name AUTO\r\n * @description\r\n *\r\n * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.\r\n */\r\n\r\nvar FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\r\nvar FN_ARG_SPLIT = /,/;\r\nvar FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/;\r\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\nfunction annotate(fn) {\r\n  var $inject,\r\n      fnText,\r\n      argDecl,\r\n      last;\r\n\r\n  if (typeof fn == 'function') {\r\n    if (!($inject = fn.$inject)) {\r\n      $inject = [];\r\n      fnText = fn.toString().replace(STRIP_COMMENTS, '');\r\n      argDecl = fnText.match(FN_ARGS);\r\n      forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){\r\n        arg.replace(FN_ARG, function(all, underscore, name){\r\n          $inject.push(name);\r\n        });\r\n      });\r\n      fn.$inject = $inject;\r\n    }\r\n  } else if (isArray(fn)) {\r\n    last = fn.length - 1;\r\n    assertArgFn(fn[last], 'fn');\r\n    $inject = fn.slice(0, last);\r\n  } else {\r\n    assertArgFn(fn, 'fn', true);\r\n  }\r\n  return $inject;\r\n}\r\n\r\n///////////////////////////////////////\r\n\r\n/**\r\n * @ngdoc object\r\n * @name AUTO.$injector\r\n * @function\r\n *\r\n * @description\r\n *\r\n * `$injector` is used to retrieve object instances as defined by\r\n * {@link AUTO.$provide provider}, instantiate types, invoke methods,\r\n * and load modules.\r\n *\r\n * The following always holds true:\r\n *\r\n * <pre>\r\n *   var $injector = angular.injector();\r\n *   expect($injector.get('$injector')).toBe($injector);\r\n *   expect($injector.invoke(function($injector){\r\n *     return $injector;\r\n *   }).toBe($injector);\r\n * </pre>\r\n *\r\n * # Injection Function Annotation\r\n *\r\n * JavaScript does not have annotations, and annotations are needed for dependency injection. The\r\n * following are all valid ways of annotating function with injection arguments and are equivalent.\r\n *\r\n * <pre>\r\n *   // inferred (only works if code not minified/obfuscated)\r\n *   $injector.invoke(function(serviceA){});\r\n *\r\n *   // annotated\r\n *   function explicit(serviceA) {};\r\n *   explicit.$inject = ['serviceA'];\r\n *   $injector.invoke(explicit);\r\n *\r\n *   // inline\r\n *   $injector.invoke(['serviceA', function(serviceA){}]);\r\n * </pre>\r\n *\r\n * ## Inference\r\n *\r\n * In JavaScript calling `toString()` on a function returns the function definition. The definition can then be\r\n * parsed and the function arguments can be extracted. *NOTE:* This does not work with minification, and obfuscation\r\n * tools since these tools change the argument names.\r\n *\r\n * ## `$inject` Annotation\r\n * By adding a `$inject` property onto a function the injection parameters can be specified.\r\n *\r\n * ## Inline\r\n * As an array of injection names, where the last item in the array is the function to call.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$injector#get\r\n * @methodOf AUTO.$injector\r\n *\r\n * @description\r\n * Return an instance of the service.\r\n *\r\n * @param {string} name The name of the instance to retrieve.\r\n * @return {*} The instance.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$injector#invoke\r\n * @methodOf AUTO.$injector\r\n *\r\n * @description\r\n * Invoke the method and supply the method arguments from the `$injector`.\r\n *\r\n * @param {!function} fn The function to invoke. The function arguments come form the function annotation.\r\n * @param {Object=} self The `this` for the invoked method.\r\n * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before\r\n *   the `$injector` is consulted.\r\n * @returns {*} the value returned by the invoked `fn` function.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$injector#has\r\n * @methodOf AUTO.$injector\r\n *\r\n * @description\r\n * Allows the user to query if the particular service exist.\r\n *\r\n * @param {string} Name of the service to query.\r\n * @returns {boolean} returns true if injector has given service.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$injector#instantiate\r\n * @methodOf AUTO.$injector\r\n * @description\r\n * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies\r\n * all of the arguments to the constructor function as specified by the constructor annotation.\r\n *\r\n * @param {function} Type Annotated constructor function.\r\n * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before\r\n *   the `$injector` is consulted.\r\n * @returns {Object} new instance of `Type`.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$injector#annotate\r\n * @methodOf AUTO.$injector\r\n *\r\n * @description\r\n * Returns an array of service names which the function is requesting for injection. This API is used by the injector\r\n * to determine which services need to be injected into the function when the function is invoked. There are three\r\n * ways in which the function can be annotated with the needed dependencies.\r\n *\r\n * # Argument names\r\n *\r\n * The simplest form is to extract the dependencies from the arguments of the function. This is done by converting\r\n * the function into a string using `toString()` method and extracting the argument names.\r\n * <pre>\r\n *   // Given\r\n *   function MyController($scope, $route) {\r\n *     // ...\r\n *   }\r\n *\r\n *   // Then\r\n *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\r\n * </pre>\r\n *\r\n * This method does not work with code minfication / obfuscation. For this reason the following annotation strategies\r\n * are supported.\r\n *\r\n * # The `$inject` property\r\n *\r\n * If a function has an `$inject` property and its value is an array of strings, then the strings represent names of\r\n * services to be injected into the function.\r\n * <pre>\r\n *   // Given\r\n *   var MyController = function(obfuscatedScope, obfuscatedRoute) {\r\n *     // ...\r\n *   }\r\n *   // Define function dependencies\r\n *   MyController.$inject = ['$scope', '$route'];\r\n *\r\n *   // Then\r\n *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\r\n * </pre>\r\n *\r\n * # The array notation\r\n *\r\n * It is often desirable to inline Injected functions and that's when setting the `$inject` property is very\r\n * inconvenient. In these situations using the array notation to specify the dependencies in a way that survives\r\n * minification is a better choice:\r\n *\r\n * <pre>\r\n *   // We wish to write this (not minification / obfuscation safe)\r\n *   injector.invoke(function($compile, $rootScope) {\r\n *     // ...\r\n *   });\r\n *\r\n *   // We are forced to write break inlining\r\n *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {\r\n *     // ...\r\n *   };\r\n *   tmpFn.$inject = ['$compile', '$rootScope'];\r\n *   injector.invoke(tmpFn);\r\n *\r\n *   // To better support inline function the inline annotation is supported\r\n *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {\r\n *     // ...\r\n *   }]);\r\n *\r\n *   // Therefore\r\n *   expect(injector.annotate(\r\n *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])\r\n *    ).toEqual(['$compile', '$rootScope']);\r\n * </pre>\r\n *\r\n * @param {function|Array.<string|Function>} fn Function for which dependent service names need to be retrieved as described\r\n *   above.\r\n *\r\n * @returns {Array.<string>} The names of the services which the function requires.\r\n */\r\n\r\n\r\n\r\n\r\n/**\r\n * @ngdoc object\r\n * @name AUTO.$provide\r\n *\r\n * @description\r\n *\r\n * Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.\r\n * The providers share the same name as the instance they create with `Provider` suffixed to them.\r\n *\r\n * A provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of\r\n * a service. The Provider can have additional methods which would allow for configuration of the provider.\r\n *\r\n * <pre>\r\n *   function GreetProvider() {\r\n *     var salutation = 'Hello';\r\n *\r\n *     this.salutation = function(text) {\r\n *       salutation = text;\r\n *     };\r\n *\r\n *     this.$get = function() {\r\n *       return function (name) {\r\n *         return salutation + ' ' + name + '!';\r\n *       };\r\n *     };\r\n *   }\r\n *\r\n *   describe('Greeter', function(){\r\n *\r\n *     beforeEach(module(function($provide) {\r\n *       $provide.provider('greet', GreetProvider);\r\n *     }));\r\n *\r\n *     it('should greet', inject(function(greet) {\r\n *       expect(greet('angular')).toEqual('Hello angular!');\r\n *     }));\r\n *\r\n *     it('should allow configuration of salutation', function() {\r\n *       module(function(greetProvider) {\r\n *         greetProvider.salutation('Ahoj');\r\n *       });\r\n *       inject(function(greet) {\r\n *         expect(greet('angular')).toEqual('Ahoj angular!');\r\n *       });\r\n *     });\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$provide#provider\r\n * @methodOf AUTO.$provide\r\n * @description\r\n *\r\n * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.\r\n *\r\n * @param {string} name The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.\r\n * @param {(Object|function())} provider If the provider is:\r\n *\r\n *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using\r\n *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.\r\n *   - `Constructor`: a new instance of the provider will be created using\r\n *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.\r\n *\r\n * @returns {Object} registered provider instance\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$provide#factory\r\n * @methodOf AUTO.$provide\r\n * @description\r\n *\r\n * A short hand for configuring services if only `$get` method is required.\r\n *\r\n * @param {string} name The name of the instance.\r\n * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for\r\n * `$provide.provider(name, {$get: $getFn})`.\r\n * @returns {Object} registered provider instance\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$provide#service\r\n * @methodOf AUTO.$provide\r\n * @description\r\n *\r\n * A short hand for registering service of given class.\r\n *\r\n * @param {string} name The name of the instance.\r\n * @param {Function} constructor A class (constructor function) that will be instantiated.\r\n * @returns {Object} registered provider instance\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$provide#value\r\n * @methodOf AUTO.$provide\r\n * @description\r\n *\r\n * A short hand for configuring services if the `$get` method is a constant.\r\n *\r\n * @param {string} name The name of the instance.\r\n * @param {*} value The value.\r\n * @returns {Object} registered provider instance\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$provide#constant\r\n * @methodOf AUTO.$provide\r\n * @description\r\n *\r\n * A constant value, but unlike {@link AUTO.$provide#value value} it can be injected\r\n * into configuration function (other modules) and it is not interceptable by\r\n * {@link AUTO.$provide#decorator decorator}.\r\n *\r\n * @param {string} name The name of the constant.\r\n * @param {*} value The constant value.\r\n * @returns {Object} registered instance\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc method\r\n * @name AUTO.$provide#decorator\r\n * @methodOf AUTO.$provide\r\n * @description\r\n *\r\n * Decoration of service, allows the decorator to intercept the service instance creation. The\r\n * returned instance may be the original instance, or a new instance which delegates to the\r\n * original instance.\r\n *\r\n * @param {string} name The name of the service to decorate.\r\n * @param {function()} decorator This function will be invoked when the service needs to be\r\n *    instantiated. The function is called using the {@link AUTO.$injector#invoke\r\n *    injector.invoke} method and is therefore fully injectable. Local injection arguments:\r\n *\r\n *    * `$delegate` - The original service instance, which can be monkey patched, configured,\r\n *      decorated or delegated to.\r\n */\r\n\r\n\r\nfunction createInjector(modulesToLoad) {\r\n  var INSTANTIATING = {},\r\n      providerSuffix = 'Provider',\r\n      path = [],\r\n      loadedModules = new HashMap(),\r\n      providerCache = {\r\n        $provide: {\r\n            provider: supportObject(provider),\r\n            factory: supportObject(factory),\r\n            service: supportObject(service),\r\n            value: supportObject(value),\r\n            constant: supportObject(constant),\r\n            decorator: decorator\r\n          }\r\n      },\r\n      providerInjector = (providerCache.$injector =\r\n          createInternalInjector(providerCache, function() {\r\n            throw Error(\"Unknown provider: \" + path.join(' <- '));\r\n          })),\r\n      instanceCache = {},\r\n      instanceInjector = (instanceCache.$injector =\r\n          createInternalInjector(instanceCache, function(servicename) {\r\n            var provider = providerInjector.get(servicename + providerSuffix);\r\n            return instanceInjector.invoke(provider.$get, provider);\r\n          }));\r\n\r\n\r\n  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });\r\n\r\n  return instanceInjector;\r\n\r\n  ////////////////////////////////////\r\n  // $provider\r\n  ////////////////////////////////////\r\n\r\n  function supportObject(delegate) {\r\n    return function(key, value) {\r\n      if (isObject(key)) {\r\n        forEach(key, reverseParams(delegate));\r\n      } else {\r\n        return delegate(key, value);\r\n      }\r\n    }\r\n  }\r\n\r\n  function provider(name, provider_) {\r\n    if (isFunction(provider_) || isArray(provider_)) {\r\n      provider_ = providerInjector.instantiate(provider_);\r\n    }\r\n    if (!provider_.$get) {\r\n      throw Error('Provider ' + name + ' must define $get factory method.');\r\n    }\r\n    return providerCache[name + providerSuffix] = provider_;\r\n  }\r\n\r\n  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }\r\n\r\n  function service(name, constructor) {\r\n    return factory(name, ['$injector', function($injector) {\r\n      return $injector.instantiate(constructor);\r\n    }]);\r\n  }\r\n\r\n  function value(name, value) { return factory(name, valueFn(value)); }\r\n\r\n  function constant(name, value) {\r\n    providerCache[name] = value;\r\n    instanceCache[name] = value;\r\n  }\r\n\r\n  function decorator(serviceName, decorFn) {\r\n    var origProvider = providerInjector.get(serviceName + providerSuffix),\r\n        orig$get = origProvider.$get;\r\n\r\n    origProvider.$get = function() {\r\n      var origInstance = instanceInjector.invoke(orig$get, origProvider);\r\n      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});\r\n    };\r\n  }\r\n\r\n  ////////////////////////////////////\r\n  // Module Loading\r\n  ////////////////////////////////////\r\n  function loadModules(modulesToLoad){\r\n    var runBlocks = [];\r\n    forEach(modulesToLoad, function(module) {\r\n      if (loadedModules.get(module)) return;\r\n      loadedModules.put(module, true);\r\n      if (isString(module)) {\r\n        var moduleFn = angularModule(module);\r\n        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);\r\n\r\n        try {\r\n          for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {\r\n            var invokeArgs = invokeQueue[i],\r\n                provider = providerInjector.get(invokeArgs[0]);\r\n\r\n            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);\r\n          }\r\n        } catch (e) {\r\n          if (e.message) e.message += ' from ' + module;\r\n          throw e;\r\n        }\r\n      } else if (isFunction(module)) {\r\n        try {\r\n          runBlocks.push(providerInjector.invoke(module));\r\n        } catch (e) {\r\n          if (e.message) e.message += ' from ' + module;\r\n          throw e;\r\n        }\r\n      } else if (isArray(module)) {\r\n        try {\r\n          runBlocks.push(providerInjector.invoke(module));\r\n        } catch (e) {\r\n          if (e.message) e.message += ' from ' + String(module[module.length - 1]);\r\n          throw e;\r\n        }\r\n      } else {\r\n        assertArgFn(module, 'module');\r\n      }\r\n    });\r\n    return runBlocks;\r\n  }\r\n\r\n  ////////////////////////////////////\r\n  // internal Injector\r\n  ////////////////////////////////////\r\n\r\n  function createInternalInjector(cache, factory) {\r\n\r\n    function getService(serviceName) {\r\n      if (typeof serviceName !== 'string') {\r\n        throw Error('Service name expected');\r\n      }\r\n      if (cache.hasOwnProperty(serviceName)) {\r\n        if (cache[serviceName] === INSTANTIATING) {\r\n          throw Error('Circular dependency: ' + path.join(' <- '));\r\n        }\r\n        return cache[serviceName];\r\n      } else {\r\n        try {\r\n          path.unshift(serviceName);\r\n          cache[serviceName] = INSTANTIATING;\r\n          return cache[serviceName] = factory(serviceName);\r\n        } finally {\r\n          path.shift();\r\n        }\r\n      }\r\n    }\r\n\r\n    function invoke(fn, self, locals){\r\n      var args = [],\r\n          $inject = annotate(fn),\r\n          length, i,\r\n          key;\r\n\r\n      for(i = 0, length = $inject.length; i < length; i++) {\r\n        key = $inject[i];\r\n        args.push(\r\n          locals && locals.hasOwnProperty(key)\r\n          ? locals[key]\r\n          : getService(key)\r\n        );\r\n      }\r\n      if (!fn.$inject) {\r\n        // this means that we must be an array.\r\n        fn = fn[length];\r\n      }\r\n\r\n\r\n      // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke\r\n      switch (self ? -1 : args.length) {\r\n        case  0: return fn();\r\n        case  1: return fn(args[0]);\r\n        case  2: return fn(args[0], args[1]);\r\n        case  3: return fn(args[0], args[1], args[2]);\r\n        case  4: return fn(args[0], args[1], args[2], args[3]);\r\n        case  5: return fn(args[0], args[1], args[2], args[3], args[4]);\r\n        case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n        case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\r\n        case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\r\n        case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\r\n        case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\r\n        default: return fn.apply(self, args);\r\n      }\r\n    }\r\n\r\n    function instantiate(Type, locals) {\r\n      var Constructor = function() {},\r\n          instance, returnedValue;\r\n\r\n      // Check if Type is annotated and use just the given function at n-1 as parameter\r\n      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);\r\n      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;\r\n      instance = new Constructor();\r\n      returnedValue = invoke(Type, instance, locals);\r\n\r\n      return isObject(returnedValue) ? returnedValue : instance;\r\n    }\r\n\r\n    return {\r\n      invoke: invoke,\r\n      instantiate: instantiate,\r\n      get: getService,\r\n      annotate: annotate,\r\n      has: function(name) {\r\n        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.$anchorScroll\r\n * @requires $window\r\n * @requires $location\r\n * @requires $rootScope\r\n *\r\n * @description\r\n * When called, it checks current value of `$location.hash()` and scroll to related element,\r\n * according to rules specified in\r\n * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.\r\n *\r\n * It also watches the `$location.hash()` and scroll whenever it changes to match any anchor.\r\n * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.\r\n */\r\nfunction $AnchorScrollProvider() {\r\n\r\n  var autoScrollingEnabled = true;\r\n\r\n  this.disableAutoScrolling = function() {\r\n    autoScrollingEnabled = false;\r\n  };\r\n\r\n  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {\r\n    var document = $window.document;\r\n\r\n    // helper function to get first anchor from a NodeList\r\n    // can't use filter.filter, as it accepts only instances of Array\r\n    // and IE can't convert NodeList to an array using [].slice\r\n    // TODO(vojta): use filter if we change it to accept lists as well\r\n    function getFirstAnchor(list) {\r\n      var result = null;\r\n      forEach(list, function(element) {\r\n        if (!result && lowercase(element.nodeName) === 'a') result = element;\r\n      });\r\n      return result;\r\n    }\r\n\r\n    function scroll() {\r\n      var hash = $location.hash(), elm;\r\n\r\n      // empty hash, scroll to the top of the page\r\n      if (!hash) $window.scrollTo(0, 0);\r\n\r\n      // element with given id\r\n      else if ((elm = document.getElementById(hash))) elm.scrollIntoView();\r\n\r\n      // first anchor with given name :-D\r\n      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();\r\n\r\n      // no element and hash == 'top', scroll to the top of the page\r\n      else if (hash === 'top') $window.scrollTo(0, 0);\r\n    }\r\n\r\n    // does not scroll when user clicks on anchor link that is currently on\r\n    // (no url change, no $location.hash() change), browser native does scroll\r\n    if (autoScrollingEnabled) {\r\n      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},\r\n        function autoScrollWatchAction() {\r\n          $rootScope.$evalAsync(scroll);\r\n        });\r\n    }\r\n\r\n    return scroll;\r\n  }];\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$animationProvider\r\n * @description\r\n *\r\n * The $AnimationProvider provider allows developers to register and access custom JavaScript animations directly inside\r\n * of a module.\r\n *\r\n */\r\n$AnimationProvider.$inject = ['$provide'];\r\nfunction $AnimationProvider($provide) {\r\n  var suffix = 'Animation';\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.$animation#register\r\n   * @methodOf ng.$animationProvider\r\n   *\r\n   * @description\r\n   * Registers a new injectable animation factory function. The factory function produces the animation object which\r\n   * has these two properties:\r\n   *\r\n   *   * `setup`: `function(Element):*` A function which receives the starting state of the element. The purpose\r\n   *   of this function is to get the element ready for animation. Optionally the function returns an memento which\r\n   *   is passed to the `start` function.\r\n   *   * `start`: `function(Element, doneFunction, *)` The element to animate, the `doneFunction` to be called on\r\n   *   element animation completion, and an optional memento from the `setup` function.\r\n   *\r\n   * @param {string} name The name of the animation.\r\n   * @param {function} factory The factory function that will be executed to return the animation object.\r\n   * \r\n   */\r\n  this.register = function(name, factory) {\r\n    $provide.factory(camelCase(name) + suffix, factory);\r\n  };\r\n\r\n  this.$get = ['$injector', function($injector) {\r\n    /**\r\n     * @ngdoc function\r\n     * @name ng.$animation\r\n     * @function\r\n     *\r\n     * @description\r\n     * The $animation service is used to retrieve any defined animation functions. When executed, the $animation service\r\n     * will return a object that contains the setup and start functions that were defined for the animation.\r\n     *\r\n     * @param {String} name Name of the animation function to retrieve. Animation functions are registered and stored\r\n     *        inside of the AngularJS DI so a call to $animate('custom') is the same as injecting `customAnimation`\r\n     *        via dependency injection.\r\n     * @return {Object} the animation object which contains the `setup` and `start` functions that perform the animation.\r\n     */\r\n    return function $animation(name) {\r\n      if (name) {\r\n        var animationName = camelCase(name) + suffix;\r\n        if ($injector.has(animationName)) {\r\n          return $injector.get(animationName);\r\n        }\r\n      }\r\n    };\r\n  }];\r\n}\r\n\r\n// NOTE: this is a pseudo directive.\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngAnimate\r\n *\r\n * @description\r\n * The `ngAnimate` directive works as an attribute that is attached alongside pre-existing directives.\r\n * It effects how the directive will perform DOM manipulation. This allows for complex animations to take place\r\n * without burdening the directive which uses the animation with animation details. The built in directives\r\n * `ngRepeat`, `ngInclude`, `ngSwitch`, `ngShow`, `ngHide` and `ngView` already accept `ngAnimate` directive.\r\n * Custom directives can take advantage of animation through {@link ng.$animator $animator service}.\r\n *\r\n * Below is a more detailed breakdown of the supported callback events provided by pre-exisitng ng directives:\r\n *\r\n * | Directive                                                 | Supported Animations                               |\r\n * |========================================================== |====================================================|\r\n * | {@link ng.directive:ngRepeat#animations ngRepeat}         | enter, leave and move                              |\r\n * | {@link ng.directive:ngView#animations ngView}             | enter and leave                                    |\r\n * | {@link ng.directive:ngInclude#animations ngInclude}       | enter and leave                                    |\r\n * | {@link ng.directive:ngSwitch#animations ngSwitch}         | enter and leave                                    |\r\n * | {@link ng.directive:ngIf#animations ngIf}                 | enter and leave                                    |\r\n * | {@link ng.directive:ngShow#animations ngShow & ngHide}    | show and hide                                      |\r\n *\r\n * You can find out more information about animations upon visiting each directive page.\r\n *\r\n * Below is an example of a directive that makes use of the ngAnimate attribute:\r\n *\r\n * <pre>\r\n * <!-- you can also use data-ng-animate, ng:animate or x-ng-animate as well -->\r\n * <ANY ng-directive ng-animate=\"{event1: 'animation-name', event2: 'animation-name-2'}\"></ANY>\r\n *\r\n * <!-- you can also use a short hand -->\r\n * <ANY ng-directive ng-animate=\" 'animation' \"></ANY>\r\n * <!-- which expands to -->\r\n * <ANY ng-directive ng-animate=\"{ enter: 'animation-enter', leave: 'animation-leave', ...}\"></ANY>\r\n *\r\n * <!-- keep in mind that ng-animate can take expressions -->\r\n * <ANY ng-directive ng-animate=\" computeCurrentAnimation() \"></ANY>\r\n * </pre>\r\n *\r\n * The `event1` and `event2` attributes refer to the animation events specific to the directive that has been assigned.\r\n *\r\n * Keep in mind that if an animation is running, no child element of such animation can also be animated.\r\n *\r\n * <h2>CSS-defined Animations</h2>\r\n * By default, ngAnimate attaches two CSS classes per animation event to the DOM element to achieve the animation.\r\n * It is up to you, the developer, to ensure that the animations take place using cross-browser CSS3 transitions as\r\n * well as CSS animations.\r\n *\r\n * The following code below demonstrates how to perform animations using **CSS transitions** with ngAnimate:\r\n *\r\n * <pre>\r\n * <style type=\"text/css\">\r\n * /&#42;\r\n *  The animate-enter CSS class is the event name that you\r\n *  have provided within the ngAnimate attribute.\r\n * &#42;/\r\n * .animate-enter {\r\n *  -webkit-transition: 1s linear all; /&#42; Safari/Chrome &#42;/\r\n *  -moz-transition: 1s linear all; /&#42; Firefox &#42;/\r\n *  -o-transition: 1s linear all; /&#42; Opera &#42;/\r\n *  transition: 1s linear all; /&#42; IE10+ and Future Browsers &#42;/\r\n *\r\n *  /&#42; The animation preparation code &#42;/\r\n *  opacity: 0;\r\n * }\r\n *\r\n * /&#42;\r\n *  Keep in mind that you want to combine both CSS\r\n *  classes together to avoid any CSS-specificity\r\n *  conflicts\r\n * &#42;/\r\n * .animate-enter.animate-enter-active {\r\n *  /&#42; The animation code itself &#42;/\r\n *  opacity: 1;\r\n * }\r\n * </style>\r\n *\r\n * <div ng-directive ng-animate=\"{enter: 'animate-enter'}\"></div>\r\n * </pre>\r\n *\r\n * The following code below demonstrates how to perform animations using **CSS animations** with ngAnimate:\r\n *\r\n * <pre>\r\n * <style type=\"text/css\">\r\n * .animate-enter {\r\n *   -webkit-animation: enter_sequence 1s linear; /&#42; Safari/Chrome &#42;/\r\n *   -moz-animation: enter_sequence 1s linear; /&#42; Firefox &#42;/\r\n *   -o-animation: enter_sequence 1s linear; /&#42; Opera &#42;/\r\n *   animation: enter_sequence 1s linear; /&#42; IE10+ and Future Browsers &#42;/\r\n * }\r\n * &#64-webkit-keyframes enter_sequence {\r\n *   from { opacity:0; }\r\n *   to { opacity:1; }\r\n * }\r\n * &#64-moz-keyframes enter_sequence {\r\n *   from { opacity:0; }\r\n *   to { opacity:1; }\r\n * }\r\n * &#64-o-keyframes enter_sequence {\r\n *   from { opacity:0; }\r\n *   to { opacity:1; }\r\n * }\r\n * &#64keyframes enter_sequence {\r\n *   from { opacity:0; }\r\n *   to { opacity:1; }\r\n * }\r\n * </style>\r\n *\r\n * <div ng-directive ng-animate=\"{enter: 'animate-enter'}\"></div>\r\n * </pre>\r\n *\r\n * ngAnimate will first examine any CSS animation code and then fallback to using CSS transitions.\r\n *\r\n * Upon DOM mutation, the event class is added first, then the browser is allowed to reflow the content and then,\r\n * the active class is added to trigger the animation. The ngAnimate directive will automatically extract the duration\r\n * of the animation to determine when the animation ends. Once the animation is over then both CSS classes will be\r\n * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end\r\n * immediately resulting in a DOM element that is at it's final state. This final state is when the DOM element\r\n * has no CSS transition/animation classes surrounding it.\r\n *\r\n * <h2>JavaScript-defined Animations</h2>\r\n * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations to browsers that do not\r\n * yet support them, then you can make use of JavaScript animations defined inside of your AngularJS module.\r\n *\r\n * <pre>\r\n * var ngModule = angular.module('YourApp', []);\r\n * ngModule.animation('animate-enter', function() {\r\n *   return {\r\n *     setup : function(element) {\r\n *       //prepare the element for animation\r\n *       element.css({ 'opacity': 0 });\r\n *       var memo = \"...\"; //this value is passed to the start function\r\n *       return memo;\r\n *     },\r\n *     start : function(element, done, memo) {\r\n *       //start the animation\r\n *       element.animate({\r\n *         'opacity' : 1\r\n *       }, function() {\r\n *         //call when the animation is complete\r\n *         done()\r\n *       });\r\n *     }\r\n *   }\r\n * });\r\n * </pre>\r\n *\r\n * As you can see, the JavaScript code follows a similar template to the CSS3 animations. Once defined, the animation\r\n * can be used in the same way with the ngAnimate attribute. Keep in mind that, when using JavaScript-enabled\r\n * animations, ngAnimate will also add in the same CSS classes that CSS-enabled animations do (even if you're not using\r\n * CSS animations) to animated the element, but it will not attempt to find any CSS3 transition or animation duration/delay values.\r\n * It will instead close off the animation once the provided done function is executed. So it's important that you\r\n * make sure your animations remember to fire off the done function once the animations are complete.\r\n *\r\n * @param {expression} ngAnimate Used to configure the DOM manipulation animations.\r\n *\r\n */\r\n\r\nvar $AnimatorProvider = function() {\r\n  var NG_ANIMATE_CONTROLLER = '$ngAnimateController';\r\n  var rootAnimateController = {running:true};\r\n\r\n  this.$get = ['$animation', '$window', '$sniffer', '$rootElement', '$rootScope',\r\n      function($animation, $window, $sniffer, $rootElement, $rootScope) {\r\n    $rootElement.data(NG_ANIMATE_CONTROLLER, rootAnimateController);\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ng.$animator\r\n     * @function\r\n     *\r\n     * @description\r\n     * The $animator.create service provides the DOM manipulation API which is decorated with animations.\r\n     *\r\n     * @param {Scope} scope the scope for the ng-animate.\r\n     * @param {Attributes} attr the attributes object which contains the ngAnimate key / value pair. (The attributes are\r\n     *        passed into the linking function of the directive using the `$animator`.)\r\n     * @return {object} the animator object which contains the enter, leave, move, show, hide and animate methods.\r\n     */\r\n     var AnimatorService = function(scope, attrs) {\r\n        var animator = {};\r\n  \r\n        /**\r\n         * @ngdoc function\r\n         * @name ng.animator#enter\r\n         * @methodOf ng.$animator\r\n         * @function\r\n         *\r\n         * @description\r\n         * Injects the element object into the DOM (inside of the parent element) and then runs the enter animation.\r\n         *\r\n         * @param {jQuery/jqLite element} element the element that will be the focus of the enter animation\r\n         * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the enter animation\r\n         * @param {jQuery/jqLite element} after the sibling element (which is the previous element) of the element that will be the focus of the enter animation\r\n        */\r\n        animator.enter = animateActionFactory('enter', insert, noop);\r\n  \r\n        /**\r\n         * @ngdoc function\r\n         * @name ng.animator#leave\r\n         * @methodOf ng.$animator\r\n         * @function\r\n         *\r\n         * @description\r\n         * Runs the leave animation operation and, upon completion, removes the element from the DOM.\r\n         *\r\n         * @param {jQuery/jqLite element} element the element that will be the focus of the leave animation\r\n         * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the leave animation\r\n        */\r\n        animator.leave = animateActionFactory('leave', noop, remove);\r\n  \r\n        /**\r\n         * @ngdoc function\r\n         * @name ng.animator#move\r\n         * @methodOf ng.$animator\r\n         * @function\r\n         *\r\n         * @description\r\n         * Fires the move DOM operation. Just before the animation starts, the animator will either append it into the parent container or\r\n         * add the element directly after the after element if present. Then the move animation will be run.\r\n         *\r\n         * @param {jQuery/jqLite element} element the element that will be the focus of the move animation\r\n         * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the move animation\r\n         * @param {jQuery/jqLite element} after the sibling element (which is the previous element) of the element that will be the focus of the move animation\r\n        */\r\n        animator.move = animateActionFactory('move', move, noop);\r\n  \r\n        /**\r\n         * @ngdoc function\r\n         * @name ng.animator#show\r\n         * @methodOf ng.$animator\r\n         * @function\r\n         *\r\n         * @description\r\n         * Reveals the element by setting the CSS property `display` to `block` and then starts the show animation directly after.\r\n         *\r\n         * @param {jQuery/jqLite element} element the element that will be rendered visible or hidden\r\n        */\r\n        animator.show = animateActionFactory('show', show, noop);\r\n  \r\n        /**\r\n         * @ngdoc function\r\n         * @name ng.animator#hide\r\n         * @methodOf ng.$animator\r\n         *\r\n         * @description\r\n         * Starts the hide animation first and sets the CSS `display` property to `none` upon completion.\r\n         *\r\n         * @param {jQuery/jqLite element} element the element that will be rendered visible or hidden\r\n        */\r\n        animator.hide = animateActionFactory('hide', noop, hide);\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ng.animator#animate\r\n         * @methodOf ng.$animator\r\n         *\r\n         * @description\r\n         * Triggers a custom animation event to be executed on the given element\r\n         *\r\n         * @param {jQuery/jqLite element} element that will be animated\r\n        */\r\n        animator.animate = function(event, element) {\r\n          animateActionFactory(event, noop, noop)(element);\r\n        }\r\n        return animator;\r\n  \r\n        function animateActionFactory(type, beforeFn, afterFn) {\r\n          return function(element, parent, after) {\r\n            var ngAnimateValue = scope.$eval(attrs.ngAnimate);\r\n            var className = ngAnimateValue\r\n                ? isObject(ngAnimateValue) ? ngAnimateValue[type] : ngAnimateValue + '-' + type\r\n                : '';\r\n            var animationPolyfill = $animation(className);\r\n            var polyfillSetup = animationPolyfill && animationPolyfill.setup;\r\n            var polyfillStart = animationPolyfill && animationPolyfill.start;\r\n            var polyfillCancel = animationPolyfill && animationPolyfill.cancel;\r\n\r\n            if (!className) {\r\n              beforeFn(element, parent, after);\r\n              afterFn(element, parent, after);\r\n            } else {\r\n              var activeClassName = className + '-active';\r\n\r\n              if (!parent) {\r\n                parent = after ? after.parent() : element.parent();\r\n              }\r\n              if ((!$sniffer.transitions && !polyfillSetup && !polyfillStart) ||\r\n                  (parent.inheritedData(NG_ANIMATE_CONTROLLER) || noop).running) {\r\n                beforeFn(element, parent, after);\r\n                afterFn(element, parent, after);\r\n                return;\r\n              }\r\n\r\n              var animationData = element.data(NG_ANIMATE_CONTROLLER) || {};\r\n              if(animationData.running) {\r\n                (polyfillCancel || noop)(element);\r\n                animationData.done();\r\n              }\r\n\r\n              element.data(NG_ANIMATE_CONTROLLER, {running:true, done:done});\r\n              element.addClass(className);\r\n              beforeFn(element, parent, after);\r\n              if (element.length == 0) return done();\r\n\r\n              var memento = (polyfillSetup || noop)(element);\r\n\r\n              // $window.setTimeout(beginAnimation, 0); this was causing the element not to animate\r\n              // keep at 1 for animation dom rerender\r\n              $window.setTimeout(beginAnimation, 1);\r\n            }\r\n\r\n            function parseMaxTime(str) {\r\n              var total = 0, values = isString(str) ? str.split(/\\s*,\\s*/) : [];\r\n              forEach(values, function(value) {\r\n                total = Math.max(parseFloat(value) || 0, total);\r\n              });\r\n              return total;\r\n            }\r\n\r\n            function beginAnimation() {\r\n              element.addClass(activeClassName);\r\n              if (polyfillStart) {\r\n                polyfillStart(element, done, memento);\r\n              } else if (isFunction($window.getComputedStyle)) {\r\n                //one day all browsers will have these properties\r\n                var w3cAnimationProp = 'animation'; \r\n                var w3cTransitionProp = 'transition';\r\n\r\n                //but some still use vendor-prefixed styles \r\n                var vendorAnimationProp = $sniffer.vendorPrefix + 'Animation';\r\n                var vendorTransitionProp = $sniffer.vendorPrefix + 'Transition';\r\n\r\n                var durationKey = 'Duration',\r\n                    delayKey = 'Delay',\r\n                    animationIterationCountKey = 'IterationCount',\r\n                    duration = 0;\r\n                \r\n                //we want all the styles defined before and after\r\n                var ELEMENT_NODE = 1;\r\n                forEach(element, function(element) {\r\n                  if (element.nodeType == ELEMENT_NODE) {\r\n                    var w3cProp = w3cTransitionProp,\r\n                        vendorProp = vendorTransitionProp,\r\n                        iterations = 1,\r\n                        elementStyles = $window.getComputedStyle(element) || {};\r\n\r\n                    //use CSS Animations over CSS Transitions\r\n                    if(parseFloat(elementStyles[w3cAnimationProp + durationKey]) > 0 ||\r\n                       parseFloat(elementStyles[vendorAnimationProp + durationKey]) > 0) {\r\n                      w3cProp = w3cAnimationProp;\r\n                      vendorProp = vendorAnimationProp;\r\n                      iterations = Math.max(parseInt(elementStyles[w3cProp    + animationIterationCountKey]) || 0,\r\n                                            parseInt(elementStyles[vendorProp + animationIterationCountKey]) || 0,\r\n                                            iterations);\r\n                    }\r\n\r\n                    var parsedDelay     = Math.max(parseMaxTime(elementStyles[w3cProp     + delayKey]),\r\n                                                   parseMaxTime(elementStyles[vendorProp  + delayKey]));\r\n\r\n                    var parsedDuration  = Math.max(parseMaxTime(elementStyles[w3cProp     + durationKey]),\r\n                                                   parseMaxTime(elementStyles[vendorProp  + durationKey]));\r\n\r\n                    duration = Math.max(parsedDelay + (iterations * parsedDuration), duration);\r\n                  }\r\n                });\r\n                $window.setTimeout(done, duration * 1000);\r\n              } else {\r\n                done();\r\n              }\r\n            }\r\n\r\n            function done() {\r\n              if(!done.run) {\r\n                done.run = true;\r\n                afterFn(element, parent, after);\r\n                element.removeClass(className);\r\n                element.removeClass(activeClassName);\r\n                element.removeData(NG_ANIMATE_CONTROLLER);\r\n              }\r\n            }\r\n          };\r\n        }\r\n  \r\n        function show(element) {\r\n          element.css('display', '');\r\n        }\r\n  \r\n        function hide(element) {\r\n          element.css('display', 'none');\r\n        }\r\n  \r\n        function insert(element, parent, after) {\r\n          if (after) {\r\n            after.after(element);\r\n          } else {\r\n            parent.append(element);\r\n          }\r\n        }\r\n  \r\n        function remove(element) {\r\n          element.remove();\r\n        }\r\n  \r\n        function move(element, parent, after) {\r\n          // Do not remove element before insert. Removing will cause data associated with the\r\n          // element to be dropped. Insert will implicitly do the remove.\r\n          insert(element, parent, after);\r\n        }\r\n      };\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ng.animator#enabled\r\n     * @methodOf ng.$animator\r\n     * @function\r\n     *\r\n     * @param {Boolean=} If provided then set the animation on or off.\r\n     * @return {Boolean} Current animation state.\r\n     *\r\n     * @description\r\n     * Globally enables/disables animations.\r\n     *\r\n    */\r\n    AnimatorService.enabled = function(value) {\r\n      if (arguments.length) {\r\n        rootAnimateController.running = !value;\r\n      }\r\n      return !rootAnimateController.running;\r\n    };\r\n\r\n    return AnimatorService;\r\n  }];\r\n};\r\n\r\n/**\r\n * ! This is a private undocumented service !\r\n *\r\n * @name ng.$browser\r\n * @requires $log\r\n * @description\r\n * This object has two goals:\r\n *\r\n * - hide all the global state in the browser caused by the window object\r\n * - abstract away all the browser specific features and inconsistencies\r\n *\r\n * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`\r\n * service, which can be used for convenient testing of the application without the interaction with\r\n * the real browser apis.\r\n */\r\n/**\r\n * @param {object} window The global window object.\r\n * @param {object} document jQuery wrapped document.\r\n * @param {function()} XHR XMLHttpRequest constructor.\r\n * @param {object} $log console.log or an object with the same interface.\r\n * @param {object} $sniffer $sniffer service\r\n */\r\nfunction Browser(window, document, $log, $sniffer) {\r\n  var self = this,\r\n      rawDocument = document[0],\r\n      location = window.location,\r\n      history = window.history,\r\n      setTimeout = window.setTimeout,\r\n      clearTimeout = window.clearTimeout,\r\n      pendingDeferIds = {};\r\n\r\n  self.isMock = false;\r\n\r\n  var outstandingRequestCount = 0;\r\n  var outstandingRequestCallbacks = [];\r\n\r\n  // TODO(vojta): remove this temporary api\r\n  self.$$completeOutstandingRequest = completeOutstandingRequest;\r\n  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };\r\n\r\n  /**\r\n   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`\r\n   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.\r\n   */\r\n  function completeOutstandingRequest(fn) {\r\n    try {\r\n      fn.apply(null, sliceArgs(arguments, 1));\r\n    } finally {\r\n      outstandingRequestCount--;\r\n      if (outstandingRequestCount === 0) {\r\n        while(outstandingRequestCallbacks.length) {\r\n          try {\r\n            outstandingRequestCallbacks.pop()();\r\n          } catch (e) {\r\n            $log.error(e);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Note: this method is used only by scenario runner\r\n   * TODO(vojta): prefix this method with $$ ?\r\n   * @param {function()} callback Function that will be called when no outstanding request\r\n   */\r\n  self.notifyWhenNoOutstandingRequests = function(callback) {\r\n    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire\r\n    // at some deterministic time in respect to the test runner's actions. Leaving things up to the\r\n    // regular poller would result in flaky tests.\r\n    forEach(pollFns, function(pollFn){ pollFn(); });\r\n\r\n    if (outstandingRequestCount === 0) {\r\n      callback();\r\n    } else {\r\n      outstandingRequestCallbacks.push(callback);\r\n    }\r\n  };\r\n\r\n  //////////////////////////////////////////////////////////////\r\n  // Poll Watcher API\r\n  //////////////////////////////////////////////////////////////\r\n  var pollFns = [],\r\n      pollTimeout;\r\n\r\n  /**\r\n   * @name ng.$browser#addPollFn\r\n   * @methodOf ng.$browser\r\n   *\r\n   * @param {function()} fn Poll function to add\r\n   *\r\n   * @description\r\n   * Adds a function to the list of functions that poller periodically executes,\r\n   * and starts polling if not started yet.\r\n   *\r\n   * @returns {function()} the added function\r\n   */\r\n  self.addPollFn = function(fn) {\r\n    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);\r\n    pollFns.push(fn);\r\n    return fn;\r\n  };\r\n\r\n  /**\r\n   * @param {number} interval How often should browser call poll functions (ms)\r\n   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.\r\n   *\r\n   * @description\r\n   * Configures the poller to run in the specified intervals, using the specified\r\n   * setTimeout fn and kicks it off.\r\n   */\r\n  function startPoller(interval, setTimeout) {\r\n    (function check() {\r\n      forEach(pollFns, function(pollFn){ pollFn(); });\r\n      pollTimeout = setTimeout(check, interval);\r\n    })();\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////\r\n  // URL API\r\n  //////////////////////////////////////////////////////////////\r\n\r\n  var lastBrowserUrl = location.href,\r\n      baseElement = document.find('base');\r\n\r\n  /**\r\n   * @name ng.$browser#url\r\n   * @methodOf ng.$browser\r\n   *\r\n   * @description\r\n   * GETTER:\r\n   * Without any argument, this method just returns current value of location.href.\r\n   *\r\n   * SETTER:\r\n   * With at least one argument, this method sets url to new value.\r\n   * If html5 history api supported, pushState/replaceState is used, otherwise\r\n   * location.href/location.replace is used.\r\n   * Returns its own instance to allow chaining\r\n   *\r\n   * NOTE: this api is intended for use only by the $location service. Please use the\r\n   * {@link ng.$location $location service} to change url.\r\n   *\r\n   * @param {string} url New url (when used as setter)\r\n   * @param {boolean=} replace Should new url replace current history record ?\r\n   */\r\n  self.url = function(url, replace) {\r\n    // setter\r\n    if (url) {\r\n      if (lastBrowserUrl == url) return;\r\n      lastBrowserUrl = url;\r\n      if ($sniffer.history) {\r\n        if (replace) history.replaceState(null, '', url);\r\n        else {\r\n          history.pushState(null, '', url);\r\n          // Crazy Opera Bug: http://my.opera.com/community/forums/topic.dml?id=1185462\r\n          baseElement.attr('href', baseElement.attr('href'));\r\n        }\r\n      } else {\r\n        if (replace) location.replace(url);\r\n        else location.href = url;\r\n      }\r\n      return self;\r\n    // getter\r\n    } else {\r\n      // the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172\r\n      return location.href.replace(/%27/g,\"'\");\r\n    }\r\n  };\r\n\r\n  var urlChangeListeners = [],\r\n      urlChangeInit = false;\r\n\r\n  function fireUrlChange() {\r\n    if (lastBrowserUrl == self.url()) return;\r\n\r\n    lastBrowserUrl = self.url();\r\n    forEach(urlChangeListeners, function(listener) {\r\n      listener(self.url());\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @name ng.$browser#onUrlChange\r\n   * @methodOf ng.$browser\r\n   * @TODO(vojta): refactor to use node's syntax for events\r\n   *\r\n   * @description\r\n   * Register callback function that will be called, when url changes.\r\n   *\r\n   * It's only called when the url is changed by outside of angular:\r\n   * - user types different url into address bar\r\n   * - user clicks on history (forward/back) button\r\n   * - user clicks on a link\r\n   *\r\n   * It's not called when url is changed by $browser.url() method\r\n   *\r\n   * The listener gets called with new url as parameter.\r\n   *\r\n   * NOTE: this api is intended for use only by the $location service. Please use the\r\n   * {@link ng.$location $location service} to monitor url changes in angular apps.\r\n   *\r\n   * @param {function(string)} listener Listener function to be called when url changes.\r\n   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.\r\n   */\r\n  self.onUrlChange = function(callback) {\r\n    if (!urlChangeInit) {\r\n      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)\r\n      // don't fire popstate when user change the address bar and don't fire hashchange when url\r\n      // changed by push/replaceState\r\n\r\n      // html5 history api - popstate event\r\n      if ($sniffer.history) jqLite(window).bind('popstate', fireUrlChange);\r\n      // hashchange event\r\n      if ($sniffer.hashchange) jqLite(window).bind('hashchange', fireUrlChange);\r\n      // polling\r\n      else self.addPollFn(fireUrlChange);\r\n\r\n      urlChangeInit = true;\r\n    }\r\n\r\n    urlChangeListeners.push(callback);\r\n    return callback;\r\n  };\r\n\r\n  //////////////////////////////////////////////////////////////\r\n  // Misc API\r\n  //////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   * Returns current <base href>\r\n   * (always relative - without domain)\r\n   *\r\n   * @returns {string=}\r\n   */\r\n  self.baseHref = function() {\r\n    var href = baseElement.attr('href');\r\n    return href ? href.replace(/^https?\\:\\/\\/[^\\/]*/, '') : '';\r\n  };\r\n\r\n  //////////////////////////////////////////////////////////////\r\n  // Cookies API\r\n  //////////////////////////////////////////////////////////////\r\n  var lastCookies = {};\r\n  var lastCookieString = '';\r\n  var cookiePath = self.baseHref();\r\n\r\n  /**\r\n   * @name ng.$browser#cookies\r\n   * @methodOf ng.$browser\r\n   *\r\n   * @param {string=} name Cookie name\r\n   * @param {string=} value Cookie value\r\n   *\r\n   * @description\r\n   * The cookies method provides a 'private' low level access to browser cookies.\r\n   * It is not meant to be used directly, use the $cookie service instead.\r\n   *\r\n   * The return values vary depending on the arguments that the method was called with as follows:\r\n   * <ul>\r\n   *   <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>\r\n   *   <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>\r\n   *   <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>\r\n   * </ul>\r\n   *\r\n   * @returns {Object} Hash of all cookies (if called without any parameter)\r\n   */\r\n  self.cookies = function(name, value) {\r\n    var cookieLength, cookieArray, cookie, i, index;\r\n\r\n    if (name) {\r\n      if (value === undefined) {\r\n        rawDocument.cookie = escape(name) + \"=;path=\" + cookiePath + \";expires=Thu, 01 Jan 1970 00:00:00 GMT\";\r\n      } else {\r\n        if (isString(value)) {\r\n          cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;\r\n\r\n          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\r\n          // - 300 cookies\r\n          // - 20 cookies per unique domain\r\n          // - 4096 bytes per cookie\r\n          if (cookieLength > 4096) {\r\n            $log.warn(\"Cookie '\"+ name +\"' possibly not set or overflowed because it was too large (\"+\r\n              cookieLength + \" > 4096 bytes)!\");\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      if (rawDocument.cookie !== lastCookieString) {\r\n        lastCookieString = rawDocument.cookie;\r\n        cookieArray = lastCookieString.split(\"; \");\r\n        lastCookies = {};\r\n\r\n        for (i = 0; i < cookieArray.length; i++) {\r\n          cookie = cookieArray[i];\r\n          index = cookie.indexOf('=');\r\n          if (index > 0) { //ignore nameless cookies\r\n            var name = unescape(cookie.substring(0, index));\r\n            // the first value that is seen for a cookie is the most\r\n            // specific one.  values for the same cookie name that\r\n            // follow are for less specific paths.\r\n            if (lastCookies[name] === undefined) {\r\n              lastCookies[name] = unescape(cookie.substring(index + 1));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return lastCookies;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @name ng.$browser#defer\r\n   * @methodOf ng.$browser\r\n   * @param {function()} fn A function, who's execution should be defered.\r\n   * @param {number=} [delay=0] of milliseconds to defer the function execution.\r\n   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.\r\n   *\r\n   * @description\r\n   * Executes a fn asynchronously via `setTimeout(fn, delay)`.\r\n   *\r\n   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using\r\n   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed\r\n   * via `$browser.defer.flush()`.\r\n   *\r\n   */\r\n  self.defer = function(fn, delay) {\r\n    var timeoutId;\r\n    outstandingRequestCount++;\r\n    timeoutId = setTimeout(function() {\r\n      delete pendingDeferIds[timeoutId];\r\n      completeOutstandingRequest(fn);\r\n    }, delay || 0);\r\n    pendingDeferIds[timeoutId] = true;\r\n    return timeoutId;\r\n  };\r\n\r\n\r\n  /**\r\n   * @name ng.$browser#defer.cancel\r\n   * @methodOf ng.$browser.defer\r\n   *\r\n   * @description\r\n   * Cancels a defered task identified with `deferId`.\r\n   *\r\n   * @param {*} deferId Token returned by the `$browser.defer` function.\r\n   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully canceled.\r\n   */\r\n  self.defer.cancel = function(deferId) {\r\n    if (pendingDeferIds[deferId]) {\r\n      delete pendingDeferIds[deferId];\r\n      clearTimeout(deferId);\r\n      completeOutstandingRequest(noop);\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n}\r\n\r\nfunction $BrowserProvider(){\r\n  this.$get = ['$window', '$log', '$sniffer', '$document',\r\n      function( $window,   $log,   $sniffer,   $document){\r\n        return new Browser($window, $document, $log, $sniffer);\r\n      }];\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$cacheFactory\r\n *\r\n * @description\r\n * Factory that constructs cache objects.\r\n *\r\n *\r\n * @param {string} cacheId Name or id of the newly created cache.\r\n * @param {object=} options Options object that specifies the cache behavior. Properties:\r\n *\r\n *   - `{number=}` `capacity`  turns the cache into LRU cache.\r\n *\r\n * @returns {object} Newly created cache object with the following set of methods:\r\n *\r\n * - `{object}` `info()`  Returns id, size, and options of cache.\r\n * - `{{*}}` `put({string} key, {*} value)`  Puts a new key-value pair into the cache and returns it.\r\n * - `{{*}}` `get({string} key)`  Returns cached value for `key` or undefined for cache miss.\r\n * - `{void}` `remove({string} key)`  Removes a key-value pair from the cache.\r\n * - `{void}` `removeAll()`  Removes all cached values.\r\n * - `{void}` `destroy()`  Removes references to this cache from $cacheFactory.\r\n *\r\n */\r\nfunction $CacheFactoryProvider() {\r\n\r\n  this.$get = function() {\r\n    var caches = {};\r\n\r\n    function cacheFactory(cacheId, options) {\r\n      if (cacheId in caches) {\r\n        throw Error('cacheId ' + cacheId + ' taken');\r\n      }\r\n\r\n      var size = 0,\r\n          stats = extend({}, options, {id: cacheId}),\r\n          data = {},\r\n          capacity = (options && options.capacity) || Number.MAX_VALUE,\r\n          lruHash = {},\r\n          freshEnd = null,\r\n          staleEnd = null;\r\n\r\n      return caches[cacheId] = {\r\n\r\n        put: function(key, value) {\r\n          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});\r\n\r\n          refresh(lruEntry);\r\n\r\n          if (isUndefined(value)) return;\r\n          if (!(key in data)) size++;\r\n          data[key] = value;\r\n\r\n          if (size > capacity) {\r\n            this.remove(staleEnd.key);\r\n          }\r\n\r\n          return value;\r\n        },\r\n\r\n\r\n        get: function(key) {\r\n          var lruEntry = lruHash[key];\r\n\r\n          if (!lruEntry) return;\r\n\r\n          refresh(lruEntry);\r\n\r\n          return data[key];\r\n        },\r\n\r\n\r\n        remove: function(key) {\r\n          var lruEntry = lruHash[key];\r\n\r\n          if (!lruEntry) return;\r\n\r\n          if (lruEntry == freshEnd) freshEnd = lruEntry.p;\r\n          if (lruEntry == staleEnd) staleEnd = lruEntry.n;\r\n          link(lruEntry.n,lruEntry.p);\r\n\r\n          delete lruHash[key];\r\n          delete data[key];\r\n          size--;\r\n        },\r\n\r\n\r\n        removeAll: function() {\r\n          data = {};\r\n          size = 0;\r\n          lruHash = {};\r\n          freshEnd = staleEnd = null;\r\n        },\r\n\r\n\r\n        destroy: function() {\r\n          data = null;\r\n          stats = null;\r\n          lruHash = null;\r\n          delete caches[cacheId];\r\n        },\r\n\r\n\r\n        info: function() {\r\n          return extend({}, stats, {size: size});\r\n        }\r\n      };\r\n\r\n\r\n      /**\r\n       * makes the `entry` the freshEnd of the LRU linked list\r\n       */\r\n      function refresh(entry) {\r\n        if (entry != freshEnd) {\r\n          if (!staleEnd) {\r\n            staleEnd = entry;\r\n          } else if (staleEnd == entry) {\r\n            staleEnd = entry.n;\r\n          }\r\n\r\n          link(entry.n, entry.p);\r\n          link(entry, freshEnd);\r\n          freshEnd = entry;\r\n          freshEnd.n = null;\r\n        }\r\n      }\r\n\r\n\r\n      /**\r\n       * bidirectionally links two entries of the LRU linked list\r\n       */\r\n      function link(nextEntry, prevEntry) {\r\n        if (nextEntry != prevEntry) {\r\n          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify\r\n          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    cacheFactory.info = function() {\r\n      var info = {};\r\n      forEach(caches, function(cache, cacheId) {\r\n        info[cacheId] = cache.info();\r\n      });\r\n      return info;\r\n    };\r\n\r\n\r\n    cacheFactory.get = function(cacheId) {\r\n      return caches[cacheId];\r\n    };\r\n\r\n\r\n    return cacheFactory;\r\n  };\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$templateCache\r\n *\r\n * @description\r\n * Cache used for storing html templates.\r\n *\r\n * See {@link ng.$cacheFactory $cacheFactory}.\r\n *\r\n */\r\nfunction $TemplateCacheProvider() {\r\n  this.$get = ['$cacheFactory', function($cacheFactory) {\r\n    return $cacheFactory('templates');\r\n  }];\r\n}\r\n\r\n/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!\r\n *\r\n * DOM-related variables:\r\n *\r\n * - \"node\" - DOM Node\r\n * - \"element\" - DOM Element or Node\r\n * - \"$node\" or \"$element\" - jqLite-wrapped node or element\r\n *\r\n *\r\n * Compiler related stuff:\r\n *\r\n * - \"linkFn\" - linking fn of a single directive\r\n * - \"nodeLinkFn\" - function that aggregates all linking fns for a particular node\r\n * - \"childLinkFn\" -  function that aggregates all linking fns for child nodes of a particular node\r\n * - \"compositeLinkFn\" - function that aggregates all linking fns for a compilation root (nodeList)\r\n */\r\n\r\n\r\nvar NON_ASSIGNABLE_MODEL_EXPRESSION = 'Non-assignable model expression: ';\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.$compile\r\n * @function\r\n *\r\n * @description\r\n * Compiles a piece of HTML string or DOM into a template and produces a template function, which\r\n * can then be used to link {@link ng.$rootScope.Scope scope} and the template together.\r\n *\r\n * The compilation is a process of walking the DOM tree and trying to match DOM elements to\r\n * {@link ng.$compileProvider#directive directives}. For each match it\r\n * executes corresponding template function and collects the\r\n * instance functions into a single template function which is then returned.\r\n *\r\n * The template function can then be used once to produce the view or as it is the case with\r\n * {@link ng.directive:ngRepeat repeater} many-times, in which\r\n * case each call results in a view that is a DOM clone of the original template.\r\n *\r\n <doc:example module=\"compile\">\r\n   <doc:source>\r\n    <script>\r\n      // declare a new module, and inject the $compileProvider\r\n      angular.module('compile', [], function($compileProvider) {\r\n        // configure new 'compile' directive by passing a directive\r\n        // factory function. The factory function injects the '$compile'\r\n        $compileProvider.directive('compile', function($compile) {\r\n          // directive factory creates a link function\r\n          return function(scope, element, attrs) {\r\n            scope.$watch(\r\n              function(scope) {\r\n                 // watch the 'compile' expression for changes\r\n                return scope.$eval(attrs.compile);\r\n              },\r\n              function(value) {\r\n                // when the 'compile' expression changes\r\n                // assign it into the current DOM\r\n                element.html(value);\r\n\r\n                // compile the new DOM and link it to the current\r\n                // scope.\r\n                // NOTE: we only compile .childNodes so that\r\n                // we don't get into infinite loop compiling ourselves\r\n                $compile(element.contents())(scope);\r\n              }\r\n            );\r\n          };\r\n        })\r\n      });\r\n\r\n      function Ctrl($scope) {\r\n        $scope.name = 'Angular';\r\n        $scope.html = 'Hello {{name}}';\r\n      }\r\n    </script>\r\n    <div ng-controller=\"Ctrl\">\r\n      <input ng-model=\"name\"> <br>\r\n      <textarea ng-model=\"html\"></textarea> <br>\r\n      <div compile=\"html\"></div>\r\n    </div>\r\n   </doc:source>\r\n   <doc:scenario>\r\n     it('should auto compile', function() {\r\n       expect(element('div[compile]').text()).toBe('Hello Angular');\r\n       input('html').enter('{{name}}!');\r\n       expect(element('div[compile]').text()).toBe('Angular!');\r\n     });\r\n   </doc:scenario>\r\n </doc:example>\r\n\r\n *\r\n *\r\n * @param {string|DOMElement} element Element or HTML string to compile into a template function.\r\n * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.\r\n * @param {number} maxPriority only apply directives lower then given priority (Only effects the\r\n *                 root element(s), not their children)\r\n * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template\r\n * (a DOM element/tree) to a scope. Where:\r\n *\r\n *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.\r\n *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the\r\n *               `template` and call the `cloneAttachFn` function allowing the caller to attach the\r\n *               cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is\r\n *               called as: <br> `cloneAttachFn(clonedElement, scope)` where:\r\n *\r\n *      * `clonedElement` - is a clone of the original `element` passed into the compiler.\r\n *      * `scope` - is the current scope with which the linking function is working with.\r\n *\r\n * Calling the linking function returns the element of the template. It is either the original element\r\n * passed in, or the clone of the element if the `cloneAttachFn` is provided.\r\n *\r\n * After linking the view is not updated until after a call to $digest which typically is done by\r\n * Angular automatically.\r\n *\r\n * If you need access to the bound view, there are two ways to do it:\r\n *\r\n * - If you are not asking the linking function to clone the template, create the DOM element(s)\r\n *   before you send them to the compiler and keep this reference around.\r\n *   <pre>\r\n *     var element = $compile('<p>{{total}}</p>')(scope);\r\n *   </pre>\r\n *\r\n * - if on the other hand, you need the element to be cloned, the view reference from the original\r\n *   example would not point to the clone, but rather to the original template that was cloned. In\r\n *   this case, you can access the clone via the cloneAttachFn:\r\n *   <pre>\r\n *     var templateHTML = angular.element('<p>{{total}}</p>'),\r\n *         scope = ....;\r\n *\r\n *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {\r\n *       //attach the clone to DOM document at the right place\r\n *     });\r\n *\r\n *     //now we have reference to the cloned DOM via `clone`\r\n *   </pre>\r\n *\r\n *\r\n * For information on how the compiler works, see the\r\n * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name ng.$compileProvider\r\n * @function\r\n *\r\n * @description\r\n */\r\n$CompileProvider.$inject = ['$provide'];\r\nfunction $CompileProvider($provide) {\r\n  var hasDirectives = {},\r\n      Suffix = 'Directive',\r\n      COMMENT_DIRECTIVE_REGEXP = /^\\s*directive\\:\\s*([\\d\\w\\-_]+)\\s+(.*)$/,\r\n      CLASS_DIRECTIVE_REGEXP = /(([\\d\\w\\-_]+)(?:\\:([^;]+))?;?)/,\r\n      MULTI_ROOT_TEMPLATE_ERROR = 'Template must have exactly one root element. was: ',\r\n      urlSanitizationWhitelist = /^\\s*(https?|ftp|mailto|file):/;\r\n\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.$compileProvider#directive\r\n   * @methodOf ng.$compileProvider\r\n   * @function\r\n   *\r\n   * @description\r\n   * Register a new directives with the compiler.\r\n   *\r\n   * @param {string} name Name of the directive in camel-case. (ie <code>ngBind</code> which will match as\r\n   *                <code>ng-bind</code>).\r\n   * @param {function} directiveFactory An injectable directive factory function. See {@link guide/directive} for more\r\n   *                info.\r\n   * @returns {ng.$compileProvider} Self for chaining.\r\n   */\r\n   this.directive = function registerDirective(name, directiveFactory) {\r\n    if (isString(name)) {\r\n      assertArg(directiveFactory, 'directive');\r\n      if (!hasDirectives.hasOwnProperty(name)) {\r\n        hasDirectives[name] = [];\r\n        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',\r\n          function($injector, $exceptionHandler) {\r\n            var directives = [];\r\n            forEach(hasDirectives[name], function(directiveFactory) {\r\n              try {\r\n                var directive = $injector.invoke(directiveFactory);\r\n                if (isFunction(directive)) {\r\n                  directive = { compile: valueFn(directive) };\r\n                } else if (!directive.compile && directive.link) {\r\n                  directive.compile = valueFn(directive.link);\r\n                }\r\n                directive.priority = directive.priority || 0;\r\n                directive.name = directive.name || name;\r\n                directive.require = directive.require || (directive.controller && directive.name);\r\n                directive.restrict = directive.restrict || 'A';\r\n                directives.push(directive);\r\n              } catch (e) {\r\n                $exceptionHandler(e);\r\n              }\r\n            });\r\n            return directives;\r\n          }]);\r\n      }\r\n      hasDirectives[name].push(directiveFactory);\r\n    } else {\r\n      forEach(name, reverseParams(registerDirective));\r\n    }\r\n    return this;\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.$compileProvider#urlSanitizationWhitelist\r\n   * @methodOf ng.$compileProvider\r\n   * @function\r\n   *\r\n   * @description\r\n   * Retrieves or overrides the default regular expression that is used for whitelisting of safe\r\n   * urls during a[href] sanitization.\r\n   *\r\n   * The sanitization is a security measure aimed at prevent XSS attacks via html links.\r\n   *\r\n   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into an\r\n   * absolute url. Afterwards the url is matched against the `urlSanitizationWhitelist` regular\r\n   * expression. If a match is found the original url is written into the dom. Otherwise the\r\n   * absolute url is prefixed with `'unsafe:'` string and only then it is written into the DOM.\r\n   *\r\n   * @param {RegExp=} regexp New regexp to whitelist urls with.\r\n   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for\r\n   *    chaining otherwise.\r\n   */\r\n  this.urlSanitizationWhitelist = function(regexp) {\r\n    if (isDefined(regexp)) {\r\n      urlSanitizationWhitelist = regexp;\r\n      return this;\r\n    }\r\n    return urlSanitizationWhitelist;\r\n  };\r\n\r\n\r\n  this.$get = [\r\n            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',\r\n            '$controller', '$rootScope', '$document',\r\n    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,\r\n             $controller,   $rootScope,   $document) {\r\n\r\n    var Attributes = function(element, attr) {\r\n      this.$$element = element;\r\n      this.$attr = attr || {};\r\n    };\r\n\r\n    Attributes.prototype = {\r\n      $normalize: directiveNormalize,\r\n\r\n\r\n      /**\r\n       * Set a normalized attribute on the element in a way such that all directives\r\n       * can share the attribute. This function properly handles boolean attributes.\r\n       * @param {string} key Normalized key. (ie ngAttribute)\r\n       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.\r\n       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.\r\n       *     Defaults to true.\r\n       * @param {string=} attrName Optional none normalized name. Defaults to key.\r\n       */\r\n      $set: function(key, value, writeAttr, attrName) {\r\n        var booleanKey = getBooleanAttrName(this.$$element[0], key),\r\n            $$observers = this.$$observers,\r\n            normalizedVal;\r\n\r\n        if (booleanKey) {\r\n          this.$$element.prop(key, value);\r\n          attrName = booleanKey;\r\n        }\r\n\r\n        this[key] = value;\r\n\r\n        // translate normalized key to actual key\r\n        if (attrName) {\r\n          this.$attr[key] = attrName;\r\n        } else {\r\n          attrName = this.$attr[key];\r\n          if (!attrName) {\r\n            this.$attr[key] = attrName = snake_case(key, '-');\r\n          }\r\n        }\r\n\r\n\r\n        // sanitize a[href] values\r\n        if (nodeName_(this.$$element[0]) === 'A' && key === 'href') {\r\n          urlSanitizationNode.setAttribute('href', value);\r\n\r\n          // href property always returns normalized absolute url, so we can match against that\r\n          normalizedVal = urlSanitizationNode.href;\r\n          if (!normalizedVal.match(urlSanitizationWhitelist)) {\r\n            this[key] = value = 'unsafe:' + normalizedVal;\r\n          }\r\n        }\r\n\r\n\r\n        if (writeAttr !== false) {\r\n          if (value === null || value === undefined) {\r\n            this.$$element.removeAttr(attrName);\r\n          } else {\r\n            this.$$element.attr(attrName, value);\r\n          }\r\n        }\r\n\r\n        // fire observers\r\n        $$observers && forEach($$observers[key], function(fn) {\r\n          try {\r\n            fn(value);\r\n          } catch (e) {\r\n            $exceptionHandler(e);\r\n          }\r\n        });\r\n      },\r\n\r\n\r\n      /**\r\n       * Observe an interpolated attribute.\r\n       * The observer will never be called, if given attribute is not interpolated.\r\n       *\r\n       * @param {string} key Normalized key. (ie ngAttribute) .\r\n       * @param {function(*)} fn Function that will be called whenever the attribute value changes.\r\n       * @returns {function(*)} the `fn` Function passed in.\r\n       */\r\n      $observe: function(key, fn) {\r\n        var attrs = this,\r\n            $$observers = (attrs.$$observers || (attrs.$$observers = {})),\r\n            listeners = ($$observers[key] || ($$observers[key] = []));\r\n\r\n        listeners.push(fn);\r\n        $rootScope.$evalAsync(function() {\r\n          if (!listeners.$$inter) {\r\n            // no one registered attribute interpolation function, so lets call it manually\r\n            fn(attrs[key]);\r\n          }\r\n        });\r\n        return fn;\r\n      }\r\n    };\r\n\r\n    var urlSanitizationNode = $document[0].createElement('a'),\r\n        startSymbol = $interpolate.startSymbol(),\r\n        endSymbol = $interpolate.endSymbol(),\r\n        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')\r\n            ? identity\r\n            : function denormalizeTemplate(template) {\r\n              return template.replace(/\\{\\{/g, startSymbol).replace(/}}/g, endSymbol);\r\n        },\r\n        NG_ATTR_BINDING = /^ngAttr[A-Z]/;\r\n\r\n\r\n    return compile;\r\n\r\n    //================================\r\n\r\n    function compile($compileNodes, transcludeFn, maxPriority) {\r\n      if (!($compileNodes instanceof jqLite)) {\r\n        // jquery always rewraps, whereas we need to preserve the original selector so that we can modify it.\r\n        $compileNodes = jqLite($compileNodes);\r\n      }\r\n      // We can not compile top level text elements since text nodes can be merged and we will\r\n      // not be able to attach scope data to them, so we will wrap them in <span>\r\n      forEach($compileNodes, function(node, index){\r\n        if (node.nodeType == 3 /* text node */ && node.nodeValue.match(/\\S+/) /* non-empty */ ) {\r\n          $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];\r\n        }\r\n      });\r\n      var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);\r\n      return function publicLinkFn(scope, cloneConnectFn){\r\n        assertArg(scope, 'scope');\r\n        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart\r\n        // and sometimes changes the structure of the DOM.\r\n        var $linkNode = cloneConnectFn\r\n          ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!\r\n          : $compileNodes;\r\n\r\n        // Attach scope only to non-text nodes.\r\n        for(var i = 0, ii = $linkNode.length; i<ii; i++) {\r\n          var node = $linkNode[i];\r\n          if (node.nodeType == 1 /* element */ || node.nodeType == 9 /* document */) {\r\n            $linkNode.eq(i).data('$scope', scope);\r\n          }\r\n        }\r\n        safeAddClass($linkNode, 'ng-scope');\r\n        if (cloneConnectFn) cloneConnectFn($linkNode, scope);\r\n        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);\r\n        return $linkNode;\r\n      };\r\n    }\r\n\r\n    function wrongMode(localName, mode) {\r\n      throw Error(\"Unsupported '\" + mode + \"' for '\" + localName + \"'.\");\r\n    }\r\n\r\n    function safeAddClass($element, className) {\r\n      try {\r\n        $element.addClass(className);\r\n      } catch(e) {\r\n        // ignore, since it means that we are trying to set class on\r\n        // SVG element, where class name is read-only.\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Compile function matches each node in nodeList against the directives. Once all directives\r\n     * for a particular node are collected their compile functions are executed. The compile\r\n     * functions return values - the linking functions - are combined into a composite linking\r\n     * function, which is the a linking function for the node.\r\n     *\r\n     * @param {NodeList} nodeList an array of nodes or NodeList to compile\r\n     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the\r\n     *        scope argument is auto-generated to the new child of the transcluded parent scope.\r\n     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then the\r\n     *        rootElement must be set the jqLite collection of the compile root. This is\r\n     *        needed so that the jqLite collection items can be replaced with widgets.\r\n     * @param {number=} max directive priority\r\n     * @returns {?function} A composite linking function of all of the matched directives or null.\r\n     */\r\n    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {\r\n      var linkFns = [],\r\n          nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;\r\n\r\n      for(var i = 0; i < nodeList.length; i++) {\r\n        attrs = new Attributes();\r\n\r\n        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.\r\n        directives = collectDirectives(nodeList[i], [], attrs, maxPriority);\r\n\r\n        nodeLinkFn = (directives.length)\r\n            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement)\r\n            : null;\r\n\r\n        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length)\r\n            ? null\r\n            : compileNodes(nodeList[i].childNodes,\r\n                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);\r\n\r\n        linkFns.push(nodeLinkFn);\r\n        linkFns.push(childLinkFn);\r\n        linkFnFound = (linkFnFound || nodeLinkFn || childLinkFn);\r\n      }\r\n\r\n      // return a linking function if we have found anything, null otherwise\r\n      return linkFnFound ? compositeLinkFn : null;\r\n\r\n      function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {\r\n        var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;\r\n\r\n        // copy nodeList so that linking doesn't break due to live list updates.\r\n        var stableNodeList = [];\r\n        for (i = 0, ii = nodeList.length; i < ii; i++) {\r\n          stableNodeList.push(nodeList[i]);\r\n        }\r\n\r\n        for(i = 0, n = 0, ii = linkFns.length; i < ii; n++) {\r\n          node = stableNodeList[n];\r\n          nodeLinkFn = linkFns[i++];\r\n          childLinkFn = linkFns[i++];\r\n\r\n          if (nodeLinkFn) {\r\n            if (nodeLinkFn.scope) {\r\n              childScope = scope.$new(isObject(nodeLinkFn.scope));\r\n              jqLite(node).data('$scope', childScope);\r\n            } else {\r\n              childScope = scope;\r\n            }\r\n            childTranscludeFn = nodeLinkFn.transclude;\r\n            if (childTranscludeFn || (!boundTranscludeFn && transcludeFn)) {\r\n              nodeLinkFn(childLinkFn, childScope, node, $rootElement,\r\n                  (function(transcludeFn) {\r\n                    return function(cloneFn) {\r\n                      var transcludeScope = scope.$new();\r\n                      transcludeScope.$$transcluded = true;\r\n\r\n                      return transcludeFn(transcludeScope, cloneFn).\r\n                          bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));\r\n                    };\r\n                  })(childTranscludeFn || transcludeFn)\r\n              );\r\n            } else {\r\n              nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);\r\n            }\r\n          } else if (childLinkFn) {\r\n            childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Looks for directives on the given node and adds them to the directive collection which is\r\n     * sorted.\r\n     *\r\n     * @param node Node to search.\r\n     * @param directives An array to which the directives are added to. This array is sorted before\r\n     *        the function returns.\r\n     * @param attrs The shared attrs object which is used to populate the normalized attributes.\r\n     * @param {number=} maxPriority Max directive priority.\r\n     */\r\n    function collectDirectives(node, directives, attrs, maxPriority) {\r\n      var nodeType = node.nodeType,\r\n          attrsMap = attrs.$attr,\r\n          match,\r\n          className;\r\n\r\n      switch(nodeType) {\r\n        case 1: /* Element */\r\n          // use the node name: <directive>\r\n          addDirective(directives,\r\n              directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);\r\n\r\n          // iterate over the attributes\r\n          for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,\r\n                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {\r\n            attr = nAttrs[j];\r\n            if (attr.specified) {\r\n              name = attr.name;\r\n              // support ngAttr attribute binding\r\n              ngAttrName = directiveNormalize(name);\r\n              if (NG_ATTR_BINDING.test(ngAttrName)) {\r\n                name = ngAttrName.substr(6).toLowerCase();\r\n              }\r\n              nName = directiveNormalize(name.toLowerCase());\r\n              attrsMap[nName] = name;\r\n              attrs[nName] = value = trim((msie && name == 'href')\r\n                ? decodeURIComponent(node.getAttribute(name, 2))\r\n                : attr.value);\r\n              if (getBooleanAttrName(node, nName)) {\r\n                attrs[nName] = true; // presence means true\r\n              }\r\n              addAttrInterpolateDirective(node, directives, value, nName);\r\n              addDirective(directives, nName, 'A', maxPriority);\r\n            }\r\n          }\r\n\r\n          // use class as directive\r\n          className = node.className;\r\n          if (isString(className) && className !== '') {\r\n            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {\r\n              nName = directiveNormalize(match[2]);\r\n              if (addDirective(directives, nName, 'C', maxPriority)) {\r\n                attrs[nName] = trim(match[3]);\r\n              }\r\n              className = className.substr(match.index + match[0].length);\r\n            }\r\n          }\r\n          break;\r\n        case 3: /* Text Node */\r\n          addTextInterpolateDirective(directives, node.nodeValue);\r\n          break;\r\n        case 8: /* Comment */\r\n          try {\r\n            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);\r\n            if (match) {\r\n              nName = directiveNormalize(match[1]);\r\n              if (addDirective(directives, nName, 'M', maxPriority)) {\r\n                attrs[nName] = trim(match[2]);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            // turns out that under some circumstances IE9 throws errors when one attempts to read comment's node value.\r\n            // Just ignore it and continue. (Can't seem to reproduce in test case.)\r\n          }\r\n          break;\r\n      }\r\n\r\n      directives.sort(byPriority);\r\n      return directives;\r\n    }\r\n\r\n\r\n    /**\r\n     * Once the directives have been collected, their compile functions are executed. This method\r\n     * is responsible for inlining directive templates as well as terminating the application\r\n     * of the directives if the terminal directive has been reached.\r\n     *\r\n     * @param {Array} directives Array of collected directives to execute their compile function.\r\n     *        this needs to be pre-sorted by priority order.\r\n     * @param {Node} compileNode The raw DOM node to apply the compile functions to\r\n     * @param {Object} templateAttrs The shared attribute function\r\n     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the\r\n     *        scope argument is auto-generated to the new child of the transcluded parent scope.\r\n     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this\r\n     *        argument has the root jqLite array so that we can replace nodes on it.\r\n     * @returns linkFn\r\n     */\r\n    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {\r\n      var terminalPriority = -Number.MAX_VALUE,\r\n          preLinkFns = [],\r\n          postLinkFns = [],\r\n          newScopeDirective = null,\r\n          newIsolateScopeDirective = null,\r\n          templateDirective = null,\r\n          $compileNode = templateAttrs.$$element = jqLite(compileNode),\r\n          directive,\r\n          directiveName,\r\n          $template,\r\n          transcludeDirective,\r\n          childTranscludeFn = transcludeFn,\r\n          controllerDirectives,\r\n          linkFn,\r\n          directiveValue;\r\n\r\n      // executes all directives on the current element\r\n      for(var i = 0, ii = directives.length; i < ii; i++) {\r\n        directive = directives[i];\r\n        $template = undefined;\r\n\r\n        if (terminalPriority > directive.priority) {\r\n          break; // prevent further processing of directives\r\n        }\r\n\r\n        if (directiveValue = directive.scope) {\r\n          assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);\r\n          if (isObject(directiveValue)) {\r\n            safeAddClass($compileNode, 'ng-isolate-scope');\r\n            newIsolateScopeDirective = directive;\r\n          }\r\n          safeAddClass($compileNode, 'ng-scope');\r\n          newScopeDirective = newScopeDirective || directive;\r\n        }\r\n\r\n        directiveName = directive.name;\r\n\r\n        if (directiveValue = directive.controller) {\r\n          controllerDirectives = controllerDirectives || {};\r\n          assertNoDuplicate(\"'\" + directiveName + \"' controller\",\r\n              controllerDirectives[directiveName], directive, $compileNode);\r\n          controllerDirectives[directiveName] = directive;\r\n        }\r\n\r\n        if (directiveValue = directive.transclude) {\r\n          assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);\r\n          transcludeDirective = directive;\r\n          terminalPriority = directive.priority;\r\n          if (directiveValue == 'element') {\r\n            $template = jqLite(compileNode);\r\n            $compileNode = templateAttrs.$$element =\r\n                jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));\r\n            compileNode = $compileNode[0];\r\n            replaceWith(jqCollection, jqLite($template[0]), compileNode);\r\n            childTranscludeFn = compile($template, transcludeFn, terminalPriority);\r\n          } else {\r\n            $template = jqLite(JQLiteClone(compileNode)).contents();\r\n            $compileNode.html(''); // clear contents\r\n            childTranscludeFn = compile($template, transcludeFn);\r\n          }\r\n        }\r\n\r\n        if (directive.template) {\r\n          assertNoDuplicate('template', templateDirective, directive, $compileNode);\r\n          templateDirective = directive;\r\n\r\n          directiveValue = (isFunction(directive.template))\r\n              ? directive.template($compileNode, templateAttrs)\r\n              : directive.template;\r\n\r\n          directiveValue = denormalizeTemplate(directiveValue);\r\n\r\n          if (directive.replace) {\r\n            $template = jqLite('<div>' +\r\n                                 trim(directiveValue) +\r\n                               '</div>').contents();\r\n            compileNode = $template[0];\r\n\r\n            if ($template.length != 1 || compileNode.nodeType !== 1) {\r\n              throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);\r\n            }\r\n\r\n            replaceWith(jqCollection, $compileNode, compileNode);\r\n\r\n            var newTemplateAttrs = {$attr: {}};\r\n\r\n            // combine directives from the original node and from the template:\r\n            // - take the array of directives for this element\r\n            // - split it into two parts, those that were already applied and those that weren't\r\n            // - collect directives from the template, add them to the second group and sort them\r\n            // - append the second group with new directives to the first group\r\n            directives = directives.concat(\r\n                collectDirectives(\r\n                    compileNode,\r\n                    directives.splice(i + 1, directives.length - (i + 1)),\r\n                    newTemplateAttrs\r\n                )\r\n            );\r\n            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);\r\n\r\n            ii = directives.length;\r\n          } else {\r\n            $compileNode.html(directiveValue);\r\n          }\r\n        }\r\n\r\n        if (directive.templateUrl) {\r\n          assertNoDuplicate('template', templateDirective, directive, $compileNode);\r\n          templateDirective = directive;\r\n          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i),\r\n              nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace,\r\n              childTranscludeFn);\r\n          ii = directives.length;\r\n        } else if (directive.compile) {\r\n          try {\r\n            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);\r\n            if (isFunction(linkFn)) {\r\n              addLinkFns(null, linkFn);\r\n            } else if (linkFn) {\r\n              addLinkFns(linkFn.pre, linkFn.post);\r\n            }\r\n          } catch (e) {\r\n            $exceptionHandler(e, startingTag($compileNode));\r\n          }\r\n        }\r\n\r\n        if (directive.terminal) {\r\n          nodeLinkFn.terminal = true;\r\n          terminalPriority = Math.max(terminalPriority, directive.priority);\r\n        }\r\n\r\n      }\r\n\r\n      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;\r\n      nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;\r\n\r\n      // might be normal or delayed nodeLinkFn depending on if templateUrl is present\r\n      return nodeLinkFn;\r\n\r\n      ////////////////////\r\n\r\n      function addLinkFns(pre, post) {\r\n        if (pre) {\r\n          pre.require = directive.require;\r\n          preLinkFns.push(pre);\r\n        }\r\n        if (post) {\r\n          post.require = directive.require;\r\n          postLinkFns.push(post);\r\n        }\r\n      }\r\n\r\n\r\n      function getControllers(require, $element) {\r\n        var value, retrievalMethod = 'data', optional = false;\r\n        if (isString(require)) {\r\n          while((value = require.charAt(0)) == '^' || value == '?') {\r\n            require = require.substr(1);\r\n            if (value == '^') {\r\n              retrievalMethod = 'inheritedData';\r\n            }\r\n            optional = optional || value == '?';\r\n          }\r\n          value = $element[retrievalMethod]('$' + require + 'Controller');\r\n          if (!value && !optional) {\r\n            throw Error(\"No controller: \" + require);\r\n          }\r\n          return value;\r\n        } else if (isArray(require)) {\r\n          value = [];\r\n          forEach(require, function(require) {\r\n            value.push(getControllers(require, $element));\r\n          });\r\n        }\r\n        return value;\r\n      }\r\n\r\n\r\n      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {\r\n        var attrs, $element, i, ii, linkFn, controller;\r\n\r\n        if (compileNode === linkNode) {\r\n          attrs = templateAttrs;\r\n        } else {\r\n          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));\r\n        }\r\n        $element = attrs.$$element;\r\n\r\n        if (newIsolateScopeDirective) {\r\n          var LOCAL_REGEXP = /^\\s*([@=&])(\\??)\\s*(\\w*)\\s*$/;\r\n\r\n          var parentScope = scope.$parent || scope;\r\n\r\n          forEach(newIsolateScopeDirective.scope, function(definiton, scopeName) {\r\n            var match = definiton.match(LOCAL_REGEXP) || [],\r\n                attrName = match[3] || scopeName,\r\n                optional = (match[2] == '?'),\r\n                mode = match[1], // @, =, or &\r\n                lastValue,\r\n                parentGet, parentSet;\r\n\r\n            scope.$$isolateBindings[scopeName] = mode + attrName;\r\n\r\n            switch (mode) {\r\n\r\n              case '@': {\r\n                attrs.$observe(attrName, function(value) {\r\n                  scope[scopeName] = value;\r\n                });\r\n                attrs.$$observers[attrName].$$scope = parentScope;\r\n                if( attrs[attrName] ) {\r\n                  // If the attribute has been provided then we trigger an interpolation to ensure the value is there for use in the link fn\r\n                  scope[scopeName] = $interpolate(attrs[attrName])(parentScope);\r\n                }\r\n                break;\r\n              }\r\n\r\n              case '=': {\r\n                if (optional && !attrs[attrName]) {\r\n                  return;\r\n                }\r\n                parentGet = $parse(attrs[attrName]);\r\n                parentSet = parentGet.assign || function() {\r\n                  // reset the change, or we will throw this exception on every $digest\r\n                  lastValue = scope[scopeName] = parentGet(parentScope);\r\n                  throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] +\r\n                      ' (directive: ' + newIsolateScopeDirective.name + ')');\r\n                };\r\n                lastValue = scope[scopeName] = parentGet(parentScope);\r\n                scope.$watch(function parentValueWatch() {\r\n                  var parentValue = parentGet(parentScope);\r\n\r\n                  if (parentValue !== scope[scopeName]) {\r\n                    // we are out of sync and need to copy\r\n                    if (parentValue !== lastValue) {\r\n                      // parent changed and it has precedence\r\n                      lastValue = scope[scopeName] = parentValue;\r\n                    } else {\r\n                      // if the parent can be assigned then do so\r\n                      parentSet(parentScope, parentValue = lastValue = scope[scopeName]);\r\n                    }\r\n                  }\r\n                  return parentValue;\r\n                });\r\n                break;\r\n              }\r\n\r\n              case '&': {\r\n                parentGet = $parse(attrs[attrName]);\r\n                scope[scopeName] = function(locals) {\r\n                  return parentGet(parentScope, locals);\r\n                };\r\n                break;\r\n              }\r\n\r\n              default: {\r\n                throw Error('Invalid isolate scope definition for directive ' +\r\n                    newIsolateScopeDirective.name + ': ' + definiton);\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        if (controllerDirectives) {\r\n          forEach(controllerDirectives, function(directive) {\r\n            var locals = {\r\n              $scope: scope,\r\n              $element: $element,\r\n              $attrs: attrs,\r\n              $transclude: boundTranscludeFn\r\n            };\r\n\r\n            controller = directive.controller;\r\n            if (controller == '@') {\r\n              controller = attrs[directive.name];\r\n            }\r\n\r\n            $element.data(\r\n                '$' + directive.name + 'Controller',\r\n                $controller(controller, locals));\r\n          });\r\n        }\r\n\r\n        // PRELINKING\r\n        for(i = 0, ii = preLinkFns.length; i < ii; i++) {\r\n          try {\r\n            linkFn = preLinkFns[i];\r\n            linkFn(scope, $element, attrs,\r\n                linkFn.require && getControllers(linkFn.require, $element));\r\n          } catch (e) {\r\n            $exceptionHandler(e, startingTag($element));\r\n          }\r\n        }\r\n\r\n        // RECURSION\r\n        childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);\r\n\r\n        // POSTLINKING\r\n        for(i = 0, ii = postLinkFns.length; i < ii; i++) {\r\n          try {\r\n            linkFn = postLinkFns[i];\r\n            linkFn(scope, $element, attrs,\r\n                linkFn.require && getControllers(linkFn.require, $element));\r\n          } catch (e) {\r\n            $exceptionHandler(e, startingTag($element));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * looks up the directive and decorates it with exception handling and proper parameters. We\r\n     * call this the boundDirective.\r\n     *\r\n     * @param {string} name name of the directive to look up.\r\n     * @param {string} location The directive must be found in specific format.\r\n     *   String containing any of theses characters:\r\n     *\r\n     *   * `E`: element name\r\n     *   * `A': attribute\r\n     *   * `C`: class\r\n     *   * `M`: comment\r\n     * @returns true if directive was added.\r\n     */\r\n    function addDirective(tDirectives, name, location, maxPriority) {\r\n      var match = false;\r\n      if (hasDirectives.hasOwnProperty(name)) {\r\n        for(var directive, directives = $injector.get(name + Suffix),\r\n            i = 0, ii = directives.length; i<ii; i++) {\r\n          try {\r\n            directive = directives[i];\r\n            if ( (maxPriority === undefined || maxPriority > directive.priority) &&\r\n                 directive.restrict.indexOf(location) != -1) {\r\n              tDirectives.push(directive);\r\n              match = true;\r\n            }\r\n          } catch(e) { $exceptionHandler(e); }\r\n        }\r\n      }\r\n      return match;\r\n    }\r\n\r\n\r\n    /**\r\n     * When the element is replaced with HTML template then the new attributes\r\n     * on the template need to be merged with the existing attributes in the DOM.\r\n     * The desired effect is to have both of the attributes present.\r\n     *\r\n     * @param {object} dst destination attributes (original DOM)\r\n     * @param {object} src source attributes (from the directive template)\r\n     */\r\n    function mergeTemplateAttributes(dst, src) {\r\n      var srcAttr = src.$attr,\r\n          dstAttr = dst.$attr,\r\n          $element = dst.$$element;\r\n\r\n      // reapply the old attributes to the new element\r\n      forEach(dst, function(value, key) {\r\n        if (key.charAt(0) != '$') {\r\n          if (src[key]) {\r\n            value += (key === 'style' ? ';' : ' ') + src[key];\r\n          }\r\n          dst.$set(key, value, true, srcAttr[key]);\r\n        }\r\n      });\r\n\r\n      // copy the new attributes on the old attrs object\r\n      forEach(src, function(value, key) {\r\n        if (key == 'class') {\r\n          safeAddClass($element, value);\r\n          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;\r\n        } else if (key == 'style') {\r\n          $element.attr('style', $element.attr('style') + ';' + value);\r\n        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {\r\n          dst[key] = value;\r\n          dstAttr[key] = srcAttr[key];\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs,\r\n        $rootElement, replace, childTranscludeFn) {\r\n      var linkQueue = [],\r\n          afterTemplateNodeLinkFn,\r\n          afterTemplateChildLinkFn,\r\n          beforeTemplateCompileNode = $compileNode[0],\r\n          origAsyncDirective = directives.shift(),\r\n          // The fact that we have to copy and patch the directive seems wrong!\r\n          derivedSyncDirective = extend({}, origAsyncDirective, {\r\n            controller: null, templateUrl: null, transclude: null, scope: null\r\n          }),\r\n          templateUrl = (isFunction(origAsyncDirective.templateUrl))\r\n              ? origAsyncDirective.templateUrl($compileNode, tAttrs)\r\n              : origAsyncDirective.templateUrl;\r\n\r\n      $compileNode.html('');\r\n\r\n      $http.get(templateUrl, {cache: $templateCache}).\r\n        success(function(content) {\r\n          var compileNode, tempTemplateAttrs, $template;\r\n\r\n          content = denormalizeTemplate(content);\r\n\r\n          if (replace) {\r\n            $template = jqLite('<div>' + trim(content) + '</div>').contents();\r\n            compileNode = $template[0];\r\n\r\n            if ($template.length != 1 || compileNode.nodeType !== 1) {\r\n              throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);\r\n            }\r\n\r\n            tempTemplateAttrs = {$attr: {}};\r\n            replaceWith($rootElement, $compileNode, compileNode);\r\n            collectDirectives(compileNode, directives, tempTemplateAttrs);\r\n            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);\r\n          } else {\r\n            compileNode = beforeTemplateCompileNode;\r\n            $compileNode.html(content);\r\n          }\r\n\r\n          directives.unshift(derivedSyncDirective);\r\n          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);\r\n          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);\r\n\r\n\r\n          while(linkQueue.length) {\r\n            var scope = linkQueue.shift(),\r\n                beforeTemplateLinkNode = linkQueue.shift(),\r\n                linkRootElement = linkQueue.shift(),\r\n                controller = linkQueue.shift(),\r\n                linkNode = compileNode;\r\n\r\n            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {\r\n              // it was cloned therefore we have to clone as well.\r\n              linkNode = JQLiteClone(compileNode);\r\n              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);\r\n            }\r\n\r\n            afterTemplateNodeLinkFn(function() {\r\n              beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);\r\n            }, scope, linkNode, $rootElement, controller);\r\n          }\r\n          linkQueue = null;\r\n        }).\r\n        error(function(response, code, headers, config) {\r\n          throw Error('Failed to load template: ' + config.url);\r\n        });\r\n\r\n      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {\r\n        if (linkQueue) {\r\n          linkQueue.push(scope);\r\n          linkQueue.push(node);\r\n          linkQueue.push(rootElement);\r\n          linkQueue.push(controller);\r\n        } else {\r\n          afterTemplateNodeLinkFn(function() {\r\n            beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);\r\n          }, scope, node, rootElement, controller);\r\n        }\r\n      };\r\n    }\r\n\r\n\r\n    /**\r\n     * Sorting function for bound directives.\r\n     */\r\n    function byPriority(a, b) {\r\n      return b.priority - a.priority;\r\n    }\r\n\r\n\r\n    function assertNoDuplicate(what, previousDirective, directive, element) {\r\n      if (previousDirective) {\r\n        throw Error('Multiple directives [' + previousDirective.name + ', ' +\r\n          directive.name + '] asking for ' + what + ' on: ' +  startingTag(element));\r\n      }\r\n    }\r\n\r\n\r\n    function addTextInterpolateDirective(directives, text) {\r\n      var interpolateFn = $interpolate(text, true);\r\n      if (interpolateFn) {\r\n        directives.push({\r\n          priority: 0,\r\n          compile: valueFn(function textInterpolateLinkFn(scope, node) {\r\n            var parent = node.parent(),\r\n                bindings = parent.data('$binding') || [];\r\n            bindings.push(interpolateFn);\r\n            safeAddClass(parent.data('$binding', bindings), 'ng-binding');\r\n            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {\r\n              node[0].nodeValue = value;\r\n            });\r\n          })\r\n        });\r\n      }\r\n    }\r\n\r\n\r\n    function addAttrInterpolateDirective(node, directives, value, name) {\r\n      var interpolateFn = $interpolate(value, true);\r\n\r\n      // no interpolation found -> ignore\r\n      if (!interpolateFn) return;\r\n\r\n\r\n      directives.push({\r\n        priority: 100,\r\n        compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {\r\n          var $$observers = (attr.$$observers || (attr.$$observers = {}));\r\n\r\n          // we need to interpolate again, in case the attribute value has been updated\r\n          // (e.g. by another directive's compile function)\r\n          interpolateFn = $interpolate(attr[name], true);\r\n\r\n          // if attribute was updated so that there is no interpolation going on we don't want to\r\n          // register any observers\r\n          if (!interpolateFn) return;\r\n\r\n          attr[name] = interpolateFn(scope);\r\n          ($$observers[name] || ($$observers[name] = [])).$$inter = true;\r\n          (attr.$$observers && attr.$$observers[name].$$scope || scope).\r\n            $watch(interpolateFn, function interpolateFnWatchAction(value) {\r\n              attr.$set(name, value);\r\n            });\r\n        })\r\n      });\r\n    }\r\n\r\n\r\n    /**\r\n     * This is a special jqLite.replaceWith, which can replace items which\r\n     * have no parents, provided that the containing jqLite collection is provided.\r\n     *\r\n     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes\r\n     *    in the root of the tree.\r\n     * @param {JqLite} $element The jqLite element which we are going to replace. We keep the shell,\r\n     *    but replace its DOM node reference.\r\n     * @param {Node} newNode The new DOM node.\r\n     */\r\n    function replaceWith($rootElement, $element, newNode) {\r\n      var oldNode = $element[0],\r\n          parent = oldNode.parentNode,\r\n          i, ii;\r\n\r\n      if ($rootElement) {\r\n        for(i = 0, ii = $rootElement.length; i < ii; i++) {\r\n          if ($rootElement[i] == oldNode) {\r\n            $rootElement[i] = newNode;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (parent) {\r\n        parent.replaceChild(newNode, oldNode);\r\n      }\r\n\r\n      newNode[jqLite.expando] = oldNode[jqLite.expando];\r\n      $element[0] = newNode;\r\n    }\r\n  }];\r\n}\r\n\r\nvar PREFIX_REGEXP = /^(x[\\:\\-_]|data[\\:\\-_])/i;\r\n/**\r\n * Converts all accepted directives format into proper directive name.\r\n * All of these will become 'myDirective':\r\n *   my:DiRective\r\n *   my-directive\r\n *   x-my-directive\r\n *   data-my:directive\r\n *\r\n * Also there is special case for Moz prefix starting with upper case letter.\r\n * @param name Name to normalize\r\n */\r\nfunction directiveNormalize(name) {\r\n  return camelCase(name.replace(PREFIX_REGEXP, ''));\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$compile.directive.Attributes\r\n * @description\r\n *\r\n * A shared object between directive compile / linking functions which contains normalized DOM element\r\n * attributes. The the values reflect current binding state `{{ }}`. The normalization is needed\r\n * since all of these are treated as equivalent in Angular:\r\n *\r\n *          <span ng:bind=\"a\" ng-bind=\"a\" data-ng-bind=\"a\" x-ng-bind=\"a\">\r\n */\r\n\r\n/**\r\n * @ngdoc property\r\n * @name ng.$compile.directive.Attributes#$attr\r\n * @propertyOf ng.$compile.directive.Attributes\r\n * @returns {object} A map of DOM element attribute names to the normalized name. This is\r\n *          needed to do reverse lookup from normalized name back to actual name.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.$compile.directive.Attributes#$set\r\n * @methodOf ng.$compile.directive.Attributes\r\n * @function\r\n *\r\n * @description\r\n * Set DOM element attribute value.\r\n *\r\n *\r\n * @param {string} name Normalized element attribute name of the property to modify. The name is\r\n *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}\r\n *          property to the original name.\r\n * @param {string} value Value to set the attribute to. The value can be an interpolated string.\r\n */\r\n\r\n\r\n\r\n/**\r\n * Closure compiler type information\r\n */\r\n\r\nfunction nodesetLinkingFn(\r\n  /* angular.Scope */ scope,\r\n  /* NodeList */ nodeList,\r\n  /* Element */ rootElement,\r\n  /* function(Function) */ boundTranscludeFn\r\n){}\r\n\r\nfunction directiveLinkingFn(\r\n  /* nodesetLinkingFn */ nodesetLinkingFn,\r\n  /* angular.Scope */ scope,\r\n  /* Node */ node,\r\n  /* Element */ rootElement,\r\n  /* function(Function) */ boundTranscludeFn\r\n){}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$controllerProvider\r\n * @description\r\n * The {@link ng.$controller $controller service} is used by Angular to create new\r\n * controllers.\r\n *\r\n * This provider allows controller registration via the\r\n * {@link ng.$controllerProvider#register register} method.\r\n */\r\nfunction $ControllerProvider() {\r\n  var controllers = {},\r\n      CNTRL_REG = /^(\\S+)(\\s+as\\s+(\\w+))?$/;\r\n\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.$controllerProvider#register\r\n   * @methodOf ng.$controllerProvider\r\n   * @param {string} name Controller name\r\n   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI\r\n   *    annotations in the array notation).\r\n   */\r\n  this.register = function(name, constructor) {\r\n    if (isObject(name)) {\r\n      extend(controllers, name)\r\n    } else {\r\n      controllers[name] = constructor;\r\n    }\r\n  };\r\n\r\n\r\n  this.$get = ['$injector', '$window', function($injector, $window) {\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ng.$controller\r\n     * @requires $injector\r\n     *\r\n     * @param {Function|string} constructor If called with a function then it's considered to be the\r\n     *    controller constructor function. Otherwise it's considered to be a string which is used\r\n     *    to retrieve the controller constructor using the following steps:\r\n     *\r\n     *    * check if a controller with given name is registered via `$controllerProvider`\r\n     *    * check if evaluating the string on the current scope returns a constructor\r\n     *    * check `window[constructor]` on the global `window` object\r\n     *\r\n     * @param {Object} locals Injection locals for Controller.\r\n     * @return {Object} Instance of given controller.\r\n     *\r\n     * @description\r\n     * `$controller` service is responsible for instantiating controllers.\r\n     *\r\n     * It's just a simple call to {@link AUTO.$injector $injector}, but extracted into\r\n     * a service, so that one can override this service with {@link https://gist.github.com/1649788\r\n     * BC version}.\r\n     */\r\n    return function(expression, locals) {\r\n      var instance, match, constructor, identifier;\r\n\r\n      if(isString(expression)) {\r\n        match = expression.match(CNTRL_REG),\r\n        constructor = match[1],\r\n        identifier = match[3];\r\n        expression = controllers.hasOwnProperty(constructor)\r\n            ? controllers[constructor]\r\n            : getter(locals.$scope, constructor, true) || getter($window, constructor, true);\r\n\r\n        assertArgFn(expression, constructor, true);\r\n      }\r\n\r\n      instance = $injector.instantiate(expression, locals);\r\n\r\n      if (identifier) {\r\n        if (typeof locals.$scope !== 'object') {\r\n          throw new Error('Can not export controller as \"' + identifier + '\". ' +\r\n              'No scope object provided!');\r\n        }\r\n\r\n        locals.$scope[identifier] = instance;\r\n      }\r\n\r\n      return instance;\r\n    };\r\n  }];\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$document\r\n * @requires $window\r\n *\r\n * @description\r\n * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`\r\n * element.\r\n */\r\nfunction $DocumentProvider(){\r\n  this.$get = ['$window', function(window){\r\n    return jqLite(window.document);\r\n  }];\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.$exceptionHandler\r\n * @requires $log\r\n *\r\n * @description\r\n * Any uncaught exception in angular expressions is delegated to this service.\r\n * The default implementation simply delegates to `$log.error` which logs it into\r\n * the browser console.\r\n *\r\n * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by\r\n * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.\r\n *\r\n * @param {Error} exception Exception associated with the error.\r\n * @param {string=} cause optional information about the context in which\r\n *       the error was thrown.\r\n *\r\n */\r\nfunction $ExceptionHandlerProvider() {\r\n  this.$get = ['$log', function($log) {\r\n    return function(exception, cause) {\r\n      $log.error.apply($log, arguments);\r\n    };\r\n  }];\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$interpolateProvider\r\n * @function\r\n *\r\n * @description\r\n *\r\n * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.\r\n */\r\nfunction $InterpolateProvider() {\r\n  var startSymbol = '{{';\r\n  var endSymbol = '}}';\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$interpolateProvider#startSymbol\r\n   * @methodOf ng.$interpolateProvider\r\n   * @description\r\n   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.\r\n   *\r\n   * @param {string=} value new value to set the starting symbol to.\r\n   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.\r\n   */\r\n  this.startSymbol = function(value){\r\n    if (value) {\r\n      startSymbol = value;\r\n      return this;\r\n    } else {\r\n      return startSymbol;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$interpolateProvider#endSymbol\r\n   * @methodOf ng.$interpolateProvider\r\n   * @description\r\n   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\r\n   *\r\n   * @param {string=} value new value to set the ending symbol to.\r\n   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.\r\n   */\r\n  this.endSymbol = function(value){\r\n    if (value) {\r\n      endSymbol = value;\r\n      return this;\r\n    } else {\r\n      return endSymbol;\r\n    }\r\n  };\r\n\r\n\r\n  this.$get = ['$parse', '$exceptionHandler', function($parse, $exceptionHandler) {\r\n    var startSymbolLength = startSymbol.length,\r\n        endSymbolLength = endSymbol.length;\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ng.$interpolate\r\n     * @function\r\n     *\r\n     * @requires $parse\r\n     *\r\n     * @description\r\n     *\r\n     * Compiles a string with markup into an interpolation function. This service is used by the\r\n     * HTML {@link ng.$compile $compile} service for data binding. See\r\n     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the\r\n     * interpolation markup.\r\n     *\r\n     *\r\n       <pre>\r\n         var $interpolate = ...; // injected\r\n         var exp = $interpolate('Hello {{name}}!');\r\n         expect(exp({name:'Angular'}).toEqual('Hello Angular!');\r\n       </pre>\r\n     *\r\n     *\r\n     * @param {string} text The text with markup to interpolate.\r\n     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have\r\n     *    embedded expression in order to return an interpolation function. Strings with no\r\n     *    embedded expression will return null for the interpolation function.\r\n     * @returns {function(context)} an interpolation function which is used to compute the interpolated\r\n     *    string. The function has these parameters:\r\n     *\r\n     *    * `context`: an object against which any expressions embedded in the strings are evaluated\r\n     *      against.\r\n     *\r\n     */\r\n    function $interpolate(text, mustHaveExpression) {\r\n      var startIndex,\r\n          endIndex,\r\n          index = 0,\r\n          parts = [],\r\n          length = text.length,\r\n          hasInterpolation = false,\r\n          fn,\r\n          exp,\r\n          concat = [];\r\n\r\n      while(index < length) {\r\n        if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &&\r\n             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {\r\n          (index != startIndex) && parts.push(text.substring(index, startIndex));\r\n          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));\r\n          fn.exp = exp;\r\n          index = endIndex + endSymbolLength;\r\n          hasInterpolation = true;\r\n        } else {\r\n          // we did not find anything, so we have to add the remainder to the parts array\r\n          (index != length) && parts.push(text.substring(index));\r\n          index = length;\r\n        }\r\n      }\r\n\r\n      if (!(length = parts.length)) {\r\n        // we added, nothing, must have been an empty string.\r\n        parts.push('');\r\n        length = 1;\r\n      }\r\n\r\n      if (!mustHaveExpression  || hasInterpolation) {\r\n        concat.length = length;\r\n        fn = function(context) {\r\n          try {\r\n            for(var i = 0, ii = length, part; i<ii; i++) {\r\n              if (typeof (part = parts[i]) == 'function') {\r\n                part = part(context);\r\n                if (part == null || part == undefined) {\r\n                  part = '';\r\n                } else if (typeof part != 'string') {\r\n                  part = toJson(part);\r\n                }\r\n              }\r\n              concat[i] = part;\r\n            }\r\n            return concat.join('');\r\n          }\r\n          catch(err) {\r\n            var newErr = new Error('Error while interpolating: ' + text + '\\n' + err.toString());\r\n            $exceptionHandler(newErr);\r\n          }\r\n        };\r\n        fn.exp = text;\r\n        fn.parts = parts;\r\n        return fn;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ng.$interpolate#startSymbol\r\n     * @methodOf ng.$interpolate\r\n     * @description\r\n     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.\r\n     *\r\n     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change\r\n     * the symbol.\r\n     *\r\n     * @returns {string} start symbol.\r\n     */\r\n    $interpolate.startSymbol = function() {\r\n      return startSymbol;\r\n    }\r\n\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ng.$interpolate#endSymbol\r\n     * @methodOf ng.$interpolate\r\n     * @description\r\n     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\r\n     *\r\n     * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change\r\n     * the symbol.\r\n     *\r\n     * @returns {string} start symbol.\r\n     */\r\n    $interpolate.endSymbol = function() {\r\n      return endSymbol;\r\n    }\r\n\r\n    return $interpolate;\r\n  }];\r\n}\r\n\r\nvar SERVER_MATCH = /^([^:]+):\\/\\/(\\w+:{0,1}\\w*@)?(\\{?[\\w\\.-]*\\}?)(:([0-9]+))?(\\/[^\\?#]*)?(\\?([^#]*))?(#(.*))?$/,\r\n    PATH_MATCH = /^([^\\?#]*)(\\?([^#]*))?(#(.*))?$/,\r\n    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};\r\n\r\n\r\n/**\r\n * Encode path using encodeUriSegment, ignoring forward slashes\r\n *\r\n * @param {string} path Path to encode\r\n * @returns {string}\r\n */\r\nfunction encodePath(path) {\r\n  var segments = path.split('/'),\r\n      i = segments.length;\r\n\r\n  while (i--) {\r\n    segments[i] = encodeUriSegment(segments[i]);\r\n  }\r\n\r\n  return segments.join('/');\r\n}\r\n\r\nfunction matchUrl(url, obj) {\r\n  var match = SERVER_MATCH.exec(url);\r\n\r\n  obj.$$protocol = match[1];\r\n  obj.$$host = match[3];\r\n  obj.$$port = int(match[5]) || DEFAULT_PORTS[match[1]] || null;\r\n}\r\n\r\nfunction matchAppUrl(url, obj) {\r\n  var match = PATH_MATCH.exec(url);\r\n\r\n  obj.$$path = decodeURIComponent(match[1]);\r\n  obj.$$search = parseKeyValue(match[3]);\r\n  obj.$$hash = decodeURIComponent(match[5] || '');\r\n\r\n  // make sure path starts with '/';\r\n  if (obj.$$path && obj.$$path.charAt(0) != '/') obj.$$path = '/' + obj.$$path;\r\n}\r\n\r\n\r\nfunction composeProtocolHostPort(protocol, host, port) {\r\n  return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} begin\r\n * @param {string} whole\r\n * @param {string} otherwise\r\n * @returns {string} returns text from whole after begin or otherwise if it does not begin with expected string.\r\n */\r\nfunction beginsWith(begin, whole, otherwise) {\r\n  return whole.indexOf(begin) == 0 ? whole.substr(begin.length) : otherwise;\r\n}\r\n\r\n\r\nfunction stripHash(url) {\r\n  var index = url.indexOf('#');\r\n  return index == -1 ? url : url.substr(0, index);\r\n}\r\n\r\n\r\nfunction stripFile(url) {\r\n  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);\r\n}\r\n\r\n/* return the server only */\r\nfunction serverBase(url) {\r\n  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));\r\n}\r\n\r\n\r\n/**\r\n * LocationHtml5Url represents an url\r\n * This object is exposed as $location service when HTML5 mode is enabled and supported\r\n *\r\n * @constructor\r\n * @param {string} appBase application base URL\r\n * @param {string} basePrefix url path prefix\r\n */\r\nfunction LocationHtml5Url(appBase, basePrefix) {\r\n  basePrefix = basePrefix || '';\r\n  var appBaseNoFile = stripFile(appBase);\r\n  /**\r\n   * Parse given html5 (regular) url string into properties\r\n   * @param {string} newAbsoluteUrl HTML5 url\r\n   * @private\r\n   */\r\n  this.$$parse = function(url) {\r\n    var parsed = {}\r\n    matchUrl(url, parsed);\r\n    var pathUrl = beginsWith(appBaseNoFile, url);\r\n    if (!isString(pathUrl)) {\r\n      throw Error('Invalid url \"' + url + '\", missing path prefix \"' + appBaseNoFile + '\".');\r\n    }\r\n    matchAppUrl(pathUrl, parsed);\r\n    extend(this, parsed);\r\n    if (!this.$$path) {\r\n      this.$$path = '/';\r\n    }\r\n\r\n    this.$$compose();\r\n  };\r\n\r\n  /**\r\n   * Compose url and update `absUrl` property\r\n   * @private\r\n   */\r\n  this.$$compose = function() {\r\n    var search = toKeyValue(this.$$search),\r\n        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';\r\n\r\n    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;\r\n    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'\r\n  };\r\n\r\n  this.$$rewrite = function(url) {\r\n    var appUrl, prevAppUrl;\r\n\r\n    if ( (appUrl = beginsWith(appBase, url)) !== undefined ) {\r\n      prevAppUrl = appUrl;\r\n      if ( (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ) {\r\n        return appBaseNoFile + (beginsWith('/', appUrl) || appUrl);\r\n      } else {\r\n        return appBase + prevAppUrl;\r\n      }\r\n    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ) {\r\n      return appBaseNoFile + appUrl;\r\n    } else if (appBaseNoFile == url + '/') {\r\n      return appBaseNoFile;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * LocationHashbangUrl represents url\r\n * This object is exposed as $location service when html5 history api is disabled or not supported\r\n *\r\n * @constructor\r\n * @param {string} appBase application base URL\r\n * @param {string} hashPrefix hashbang prefix\r\n */\r\nfunction LocationHashbangUrl(appBase, hashPrefix) {\r\n  var appBaseNoFile = stripFile(appBase);\r\n\r\n  /**\r\n   * Parse given hashbang url into properties\r\n   * @param {string} url Hashbang url\r\n   * @private\r\n   */\r\n  this.$$parse = function(url) {\r\n    matchUrl(url, this);\r\n    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);\r\n    if (!isString(withoutBaseUrl)) {\r\n      throw new Error('Invalid url \"' + url + '\", does not start with \"' + appBase +  '\".');\r\n    }\r\n    var withoutHashUrl = withoutBaseUrl.charAt(0) == '#' ? beginsWith(hashPrefix, withoutBaseUrl) : withoutBaseUrl;\r\n    if (!isString(withoutHashUrl)) {\r\n      throw new Error('Invalid url \"' + url + '\", missing hash prefix \"' + hashPrefix + '\".');\r\n    }\r\n    matchAppUrl(withoutHashUrl, this);\r\n    this.$$compose();\r\n  };\r\n\r\n  /**\r\n   * Compose hashbang url and update `absUrl` property\r\n   * @private\r\n   */\r\n  this.$$compose = function() {\r\n    var search = toKeyValue(this.$$search),\r\n        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';\r\n\r\n    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;\r\n    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');\r\n  };\r\n\r\n  this.$$rewrite = function(url) {\r\n    if(stripHash(appBase) == stripHash(url)) {\r\n      return url;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * LocationHashbangUrl represents url\r\n * This object is exposed as $location service when html5 history api is enabled but the browser\r\n * does not support it.\r\n *\r\n * @constructor\r\n * @param {string} appBase application base URL\r\n * @param {string} hashPrefix hashbang prefix\r\n */\r\nfunction LocationHashbangInHtml5Url(appBase, hashPrefix) {\r\n  LocationHashbangUrl.apply(this, arguments);\r\n\r\n  var appBaseNoFile = stripFile(appBase);\r\n\r\n  this.$$rewrite = function(url) {\r\n    var appUrl;\r\n\r\n    if ( appBase == stripHash(url) ) {\r\n      return url;\r\n    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) ) {\r\n      return appBase + hashPrefix + appUrl;\r\n    } else if ( appBaseNoFile === url + '/') {\r\n      return appBaseNoFile;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nLocationHashbangInHtml5Url.prototype =\r\n  LocationHashbangUrl.prototype =\r\n  LocationHtml5Url.prototype = {\r\n\r\n  /**\r\n   * Has any change been replacing ?\r\n   * @private\r\n   */\r\n  $$replace: false,\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#absUrl\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * This method is getter only.\r\n   *\r\n   * Return full url representation with all segments encoded according to rules specified in\r\n   * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.\r\n   *\r\n   * @return {string} full url\r\n   */\r\n  absUrl: locationGetter('$$absUrl'),\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#url\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * This method is getter / setter.\r\n   *\r\n   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.\r\n   *\r\n   * Change path, search and hash, when called with parameter and return `$location`.\r\n   *\r\n   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)\r\n   * @return {string} url\r\n   */\r\n  url: function(url, replace) {\r\n    if (isUndefined(url))\r\n      return this.$$url;\r\n\r\n    var match = PATH_MATCH.exec(url);\r\n    if (match[1]) this.path(decodeURIComponent(match[1]));\r\n    if (match[2] || match[1]) this.search(match[3] || '');\r\n    this.hash(match[5] || '', replace);\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#protocol\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * This method is getter only.\r\n   *\r\n   * Return protocol of current url.\r\n   *\r\n   * @return {string} protocol of current url\r\n   */\r\n  protocol: locationGetter('$$protocol'),\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#host\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * This method is getter only.\r\n   *\r\n   * Return host of current url.\r\n   *\r\n   * @return {string} host of current url.\r\n   */\r\n  host: locationGetter('$$host'),\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#port\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * This method is getter only.\r\n   *\r\n   * Return port of current url.\r\n   *\r\n   * @return {Number} port\r\n   */\r\n  port: locationGetter('$$port'),\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#path\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * This method is getter / setter.\r\n   *\r\n   * Return path of current url when called without any parameter.\r\n   *\r\n   * Change path when called with parameter and return `$location`.\r\n   *\r\n   * Note: Path should always begin with forward slash (/), this method will add the forward slash\r\n   * if it is missing.\r\n   *\r\n   * @param {string=} path New path\r\n   * @return {string} path\r\n   */\r\n  path: locationGetterSetter('$$path', function(path) {\r\n    return path.charAt(0) == '/' ? path : '/' + path;\r\n  }),\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#search\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * This method is getter / setter.\r\n   *\r\n   * Return search part (as object) of current url when called without any parameter.\r\n   *\r\n   * Change search part when called with parameter and return `$location`.\r\n   *\r\n   * @param {string|object<string,string>=} search New search params - string or hash object\r\n   * @param {string=} paramValue If `search` is a string, then `paramValue` will override only a\r\n   *    single search parameter. If the value is `null`, the parameter will be deleted.\r\n   *\r\n   * @return {string} search\r\n   */\r\n  search: function(search, paramValue) {\r\n    if (isUndefined(search))\r\n      return this.$$search;\r\n\r\n    if (isDefined(paramValue)) {\r\n      if (paramValue === null) {\r\n        delete this.$$search[search];\r\n      } else {\r\n        this.$$search[search] = paramValue;\r\n      }\r\n    } else {\r\n      this.$$search = isString(search) ? parseKeyValue(search) : search;\r\n    }\r\n\r\n    this.$$compose();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#hash\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * This method is getter / setter.\r\n   *\r\n   * Return hash fragment when called without any parameter.\r\n   *\r\n   * Change hash fragment when called with parameter and return `$location`.\r\n   *\r\n   * @param {string=} hash New hash fragment\r\n   * @return {string} hash\r\n   */\r\n  hash: locationGetterSetter('$$hash', identity),\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$location#replace\r\n   * @methodOf ng.$location\r\n   *\r\n   * @description\r\n   * If called, all changes to $location during current `$digest` will be replacing current history\r\n   * record, instead of adding new one.\r\n   */\r\n  replace: function() {\r\n    this.$$replace = true;\r\n    return this;\r\n  }\r\n};\r\n\r\nfunction locationGetter(property) {\r\n  return function() {\r\n    return this[property];\r\n  };\r\n}\r\n\r\n\r\nfunction locationGetterSetter(property, preprocess) {\r\n  return function(value) {\r\n    if (isUndefined(value))\r\n      return this[property];\r\n\r\n    this[property] = preprocess(value);\r\n    this.$$compose();\r\n\r\n    return this;\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$location\r\n *\r\n * @requires $browser\r\n * @requires $sniffer\r\n * @requires $rootElement\r\n *\r\n * @description\r\n * The $location service parses the URL in the browser address bar (based on the\r\n * {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL\r\n * available to your application. Changes to the URL in the address bar are reflected into\r\n * $location service and changes to $location are reflected into the browser address bar.\r\n *\r\n * **The $location service:**\r\n *\r\n * - Exposes the current URL in the browser address bar, so you can\r\n *   - Watch and observe the URL.\r\n *   - Change the URL.\r\n * - Synchronizes the URL with the browser when the user\r\n *   - Changes the address bar.\r\n *   - Clicks the back or forward button (or clicks a History link).\r\n *   - Clicks on a link.\r\n * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).\r\n *\r\n * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular\r\n * Services: Using $location}\r\n */\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$locationProvider\r\n * @description\r\n * Use the `$locationProvider` to configure how the application deep linking paths are stored.\r\n */\r\nfunction $LocationProvider(){\r\n  var hashPrefix = '',\r\n      html5Mode = false;\r\n\r\n  /**\r\n   * @ngdoc property\r\n   * @name ng.$locationProvider#hashPrefix\r\n   * @methodOf ng.$locationProvider\r\n   * @description\r\n   * @param {string=} prefix Prefix for hash part (containing path and search)\r\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\r\n   */\r\n  this.hashPrefix = function(prefix) {\r\n    if (isDefined(prefix)) {\r\n      hashPrefix = prefix;\r\n      return this;\r\n    } else {\r\n      return hashPrefix;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @ngdoc property\r\n   * @name ng.$locationProvider#html5Mode\r\n   * @methodOf ng.$locationProvider\r\n   * @description\r\n   * @param {string=} mode Use HTML5 strategy if available.\r\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\r\n   */\r\n  this.html5Mode = function(mode) {\r\n    if (isDefined(mode)) {\r\n      html5Mode = mode;\r\n      return this;\r\n    } else {\r\n      return html5Mode;\r\n    }\r\n  };\r\n\r\n  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',\r\n      function( $rootScope,   $browser,   $sniffer,   $rootElement) {\r\n    var $location,\r\n        LocationMode,\r\n        baseHref = $browser.baseHref(),\r\n        initialUrl = $browser.url(),\r\n        appBase;\r\n\r\n    if (html5Mode) {\r\n      appBase = baseHref ? serverBase(initialUrl) + baseHref : initialUrl;\r\n      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;\r\n    } else {\r\n      appBase = stripHash(initialUrl);\r\n      LocationMode = LocationHashbangUrl;\r\n    }\r\n    $location = new LocationMode(appBase, '#' + hashPrefix);\r\n    $location.$$parse($location.$$rewrite(initialUrl));\r\n\r\n    $rootElement.bind('click', function(event) {\r\n      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)\r\n      // currently we open nice url link and redirect then\r\n\r\n      if (event.ctrlKey || event.metaKey || event.which == 2) return;\r\n\r\n      var elm = jqLite(event.target);\r\n\r\n      // traverse the DOM up to find first A tag\r\n      while (lowercase(elm[0].nodeName) !== 'a') {\r\n        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)\r\n        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;\r\n      }\r\n\r\n      var absHref = elm.prop('href');\r\n      var rewrittenUrl = $location.$$rewrite(absHref);\r\n\r\n      if (absHref && !elm.attr('target') && rewrittenUrl && !event.isDefaultPrevented()) {\r\n        event.preventDefault();\r\n        if (rewrittenUrl != $browser.url()) {\r\n          // update location manually\r\n          $location.$$parse(rewrittenUrl);\r\n          $rootScope.$apply();\r\n          // hack to work around FF6 bug 684208 when scenario runner clicks on links\r\n          window.angular['ff-684208-preventDefault'] = true;\r\n        }\r\n      }\r\n    });\r\n\r\n\r\n    // rewrite hashbang url <> html5 url\r\n    if ($location.absUrl() != initialUrl) {\r\n      $browser.url($location.absUrl(), true);\r\n    }\r\n\r\n    // update $location when $browser url changes\r\n    $browser.onUrlChange(function(newUrl) {\r\n      if ($location.absUrl() != newUrl) {\r\n        if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {\r\n          $browser.url($location.absUrl());\r\n          return;\r\n        }\r\n        $rootScope.$evalAsync(function() {\r\n          var oldUrl = $location.absUrl();\r\n\r\n          $location.$$parse(newUrl);\r\n          afterLocationChange(oldUrl);\r\n        });\r\n        if (!$rootScope.$$phase) $rootScope.$digest();\r\n      }\r\n    });\r\n\r\n    // update browser\r\n    var changeCounter = 0;\r\n    $rootScope.$watch(function $locationWatch() {\r\n      var oldUrl = $browser.url();\r\n      var currentReplace = $location.$$replace;\r\n\r\n      if (!changeCounter || oldUrl != $location.absUrl()) {\r\n        changeCounter++;\r\n        $rootScope.$evalAsync(function() {\r\n          if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).\r\n              defaultPrevented) {\r\n            $location.$$parse(oldUrl);\r\n          } else {\r\n            $browser.url($location.absUrl(), currentReplace);\r\n            afterLocationChange(oldUrl);\r\n          }\r\n        });\r\n      }\r\n      $location.$$replace = false;\r\n\r\n      return changeCounter;\r\n    });\r\n\r\n    return $location;\r\n\r\n    function afterLocationChange(oldUrl) {\r\n      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);\r\n    }\r\n}];\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$log\r\n * @requires $window\r\n *\r\n * @description\r\n * Simple service for logging. Default implementation writes the message\r\n * into the browser's console (if present).\r\n *\r\n * The main purpose of this service is to simplify debugging and troubleshooting.\r\n *\r\n * @example\r\n   <example>\r\n     <file name=\"script.js\">\r\n       function LogCtrl($scope, $log) {\r\n         $scope.$log = $log;\r\n         $scope.message = 'Hello World!';\r\n       }\r\n     </file>\r\n     <file name=\"index.html\">\r\n       <div ng-controller=\"LogCtrl\">\r\n         <p>Reload this page with open console, enter text and hit the log button...</p>\r\n         Message:\r\n         <input type=\"text\" ng-model=\"message\"/>\r\n         <button ng-click=\"$log.log(message)\">log</button>\r\n         <button ng-click=\"$log.warn(message)\">warn</button>\r\n         <button ng-click=\"$log.info(message)\">info</button>\r\n         <button ng-click=\"$log.error(message)\">error</button>\r\n       </div>\r\n     </file>\r\n   </example>\r\n */\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$logProvider\r\n * @description\r\n * Use the `$logProvider` to configure how the application logs messages\r\n */\r\nfunction $LogProvider(){\r\n  var debug = true,\r\n      self = this;\r\n  \r\n  /**\r\n   * @ngdoc property\r\n   * @name ng.$logProvider#debugEnabled\r\n   * @methodOf ng.$logProvider\r\n   * @description\r\n   * @param {string=} flag enable or disable debug level messages\r\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\r\n   */\r\n  this.debugEnabled = function(flag) {\r\n\t  if (isDefined(flag)) {\r\n\t\t  debug = flag;\r\n\t\t  return this;\r\n\t  } else {\r\n\t\t  return debug;\r\n\t  }\r\n  };\r\n  \r\n  this.$get = ['$window', function($window){\r\n    return {\r\n      /**\r\n       * @ngdoc method\r\n       * @name ng.$log#log\r\n       * @methodOf ng.$log\r\n       *\r\n       * @description\r\n       * Write a log message\r\n       */\r\n      log: consoleLog('log'),\r\n\r\n      /**\r\n       * @ngdoc method\r\n       * @name ng.$log#warn\r\n       * @methodOf ng.$log\r\n       *\r\n       * @description\r\n       * Write a warning message\r\n       */\r\n      warn: consoleLog('warn'),\r\n\r\n      /**\r\n       * @ngdoc method\r\n       * @name ng.$log#info\r\n       * @methodOf ng.$log\r\n       *\r\n       * @description\r\n       * Write an information message\r\n       */\r\n      info: consoleLog('info'),\r\n\r\n      /**\r\n       * @ngdoc method\r\n       * @name ng.$log#error\r\n       * @methodOf ng.$log\r\n       *\r\n       * @description\r\n       * Write an error message\r\n       */\r\n      error: consoleLog('error'),\r\n      \r\n      /**\r\n       * @ngdoc method\r\n       * @name ng.$log#debug\r\n       * @methodOf ng.$log\r\n       * \r\n       * @description\r\n       * Write a debug message\r\n       */\r\n      debug: (function () {\r\n    \tvar fn = consoleLog('debug');\r\n    \t\r\n    \treturn function() {\r\n    \t\tif (debug) {\r\n    \t\t\tfn.apply(self, arguments);\r\n    \t\t}\r\n    \t}\r\n      }())\r\n    };\r\n\r\n    function formatError(arg) {\r\n      if (arg instanceof Error) {\r\n        if (arg.stack) {\r\n          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)\r\n              ? 'Error: ' + arg.message + '\\n' + arg.stack\r\n              : arg.stack;\r\n        } else if (arg.sourceURL) {\r\n          arg = arg.message + '\\n' + arg.sourceURL + ':' + arg.line;\r\n        }\r\n      }\r\n      return arg;\r\n    }\r\n\r\n    function consoleLog(type) {\r\n      var console = $window.console || {},\r\n          logFn = console[type] || console.log || noop;\r\n\r\n      if (logFn.apply) {\r\n        return function() {\r\n          var args = [];\r\n          forEach(arguments, function(arg) {\r\n            args.push(formatError(arg));\r\n          });\r\n          return logFn.apply(console, args);\r\n        };\r\n      }\r\n\r\n      // we are IE which either doesn't have window.console => this is noop and we do nothing,\r\n      // or we are IE where console.log doesn't have apply so we log at least first 2 args\r\n      return function(arg1, arg2) {\r\n        logFn(arg1, arg2);\r\n      }\r\n    }\r\n  }];\r\n}\r\n\r\nvar OPERATORS = {\r\n    'null':function(){return null;},\r\n    'true':function(){return true;},\r\n    'false':function(){return false;},\r\n    undefined:noop,\r\n    '+':function(self, locals, a,b){\r\n      a=a(self, locals); b=b(self, locals);\r\n      if (isDefined(a)) {\r\n        if (isDefined(b)) {\r\n          return a + b;\r\n        }\r\n        return a;\r\n      }\r\n      return isDefined(b)?b:undefined;},\r\n    '-':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},\r\n    '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},\r\n    '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},\r\n    '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},\r\n    '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},\r\n    '=':noop,\r\n    '===':function(self, locals, a, b){return a(self, locals)===b(self, locals);},\r\n    '!==':function(self, locals, a, b){return a(self, locals)!==b(self, locals);},\r\n    '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},\r\n    '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},\r\n    '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},\r\n    '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},\r\n    '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},\r\n    '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},\r\n    '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},\r\n    '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},\r\n    '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},\r\n//    '|':function(self, locals, a,b){return a|b;},\r\n    '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},\r\n    '!':function(self, locals, a){return !a(self, locals);}\r\n};\r\nvar ESCAPE = {\"n\":\"\\n\", \"f\":\"\\f\", \"r\":\"\\r\", \"t\":\"\\t\", \"v\":\"\\v\", \"'\":\"'\", '\"':'\"'};\r\n\r\nfunction lex(text, csp){\r\n  var tokens = [],\r\n      token,\r\n      index = 0,\r\n      json = [],\r\n      ch,\r\n      lastCh = ':'; // can start regexp\r\n\r\n  while (index < text.length) {\r\n    ch = text.charAt(index);\r\n    if (is('\"\\'')) {\r\n      readString(ch);\r\n    } else if (isNumber(ch) || is('.') && isNumber(peek())) {\r\n      readNumber();\r\n    } else if (isIdent(ch)) {\r\n      readIdent();\r\n      // identifiers can only be if the preceding char was a { or ,\r\n      if (was('{,') && json[0]=='{' &&\r\n         (token=tokens[tokens.length-1])) {\r\n        token.json = token.text.indexOf('.') == -1;\r\n      }\r\n    } else if (is('(){}[].,;:?')) {\r\n      tokens.push({\r\n        index:index,\r\n        text:ch,\r\n        json:(was(':[,') && is('{[')) || is('}]:,')\r\n      });\r\n      if (is('{[')) json.unshift(ch);\r\n      if (is('}]')) json.shift();\r\n      index++;\r\n    } else if (isWhitespace(ch)) {\r\n      index++;\r\n      continue;\r\n    } else {\r\n      var ch2 = ch + peek(),\r\n          ch3 = ch2 + peek(2),\r\n          fn = OPERATORS[ch],\r\n          fn2 = OPERATORS[ch2],\r\n          fn3 = OPERATORS[ch3];\r\n      if (fn3) {\r\n        tokens.push({index:index, text:ch3, fn:fn3});\r\n        index += 3;\r\n      } else if (fn2) {\r\n        tokens.push({index:index, text:ch2, fn:fn2});\r\n        index += 2;\r\n      } else if (fn) {\r\n        tokens.push({index:index, text:ch, fn:fn, json: was('[,:') && is('+-')});\r\n        index += 1;\r\n      } else {\r\n        throwError(\"Unexpected next character \", index, index+1);\r\n      }\r\n    }\r\n    lastCh = ch;\r\n  }\r\n  return tokens;\r\n\r\n  function is(chars) {\r\n    return chars.indexOf(ch) != -1;\r\n  }\r\n\r\n  function was(chars) {\r\n    return chars.indexOf(lastCh) != -1;\r\n  }\r\n\r\n  function peek(i) {\r\n    var num = i || 1;\r\n    return index + num < text.length ? text.charAt(index + num) : false;\r\n  }\r\n  function isNumber(ch) {\r\n    return '0' <= ch && ch <= '9';\r\n  }\r\n  function isWhitespace(ch) {\r\n    return ch == ' ' || ch == '\\r' || ch == '\\t' ||\r\n           ch == '\\n' || ch == '\\v' || ch == '\\u00A0'; // IE treats non-breaking space as \\u00A0\r\n  }\r\n  function isIdent(ch) {\r\n    return 'a' <= ch && ch <= 'z' ||\r\n           'A' <= ch && ch <= 'Z' ||\r\n           '_' == ch || ch == '$';\r\n  }\r\n  function isExpOperator(ch) {\r\n    return ch == '-' || ch == '+' || isNumber(ch);\r\n  }\r\n\r\n  function throwError(error, start, end) {\r\n    end = end || index;\r\n    throw Error(\"Lexer Error: \" + error + \" at column\" +\r\n        (isDefined(start)\r\n            ? \"s \" + start +  \"-\" + index + \" [\" + text.substring(start, end) + \"]\"\r\n            : \" \" + end) +\r\n        \" in expression [\" + text + \"].\");\r\n  }\r\n\r\n  function readNumber() {\r\n    var number = \"\";\r\n    var start = index;\r\n    while (index < text.length) {\r\n      var ch = lowercase(text.charAt(index));\r\n      if (ch == '.' || isNumber(ch)) {\r\n        number += ch;\r\n      } else {\r\n        var peekCh = peek();\r\n        if (ch == 'e' && isExpOperator(peekCh)) {\r\n          number += ch;\r\n        } else if (isExpOperator(ch) &&\r\n            peekCh && isNumber(peekCh) &&\r\n            number.charAt(number.length - 1) == 'e') {\r\n          number += ch;\r\n        } else if (isExpOperator(ch) &&\r\n            (!peekCh || !isNumber(peekCh)) &&\r\n            number.charAt(number.length - 1) == 'e') {\r\n          throwError('Invalid exponent');\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      index++;\r\n    }\r\n    number = 1 * number;\r\n    tokens.push({index:start, text:number, json:true,\r\n      fn:function() {return number;}});\r\n  }\r\n  function readIdent() {\r\n    var ident = \"\",\r\n        start = index,\r\n        lastDot, peekIndex, methodName, ch;\r\n\r\n    while (index < text.length) {\r\n      ch = text.charAt(index);\r\n      if (ch == '.' || isIdent(ch) || isNumber(ch)) {\r\n        if (ch == '.') lastDot = index;\r\n        ident += ch;\r\n      } else {\r\n        break;\r\n      }\r\n      index++;\r\n    }\r\n\r\n    //check if this is not a method invocation and if it is back out to last dot\r\n    if (lastDot) {\r\n      peekIndex = index;\r\n      while(peekIndex < text.length) {\r\n        ch = text.charAt(peekIndex);\r\n        if (ch == '(') {\r\n          methodName = ident.substr(lastDot - start + 1);\r\n          ident = ident.substr(0, lastDot - start);\r\n          index = peekIndex;\r\n          break;\r\n        }\r\n        if(isWhitespace(ch)) {\r\n          peekIndex++;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    var token = {\r\n      index:start,\r\n      text:ident\r\n    };\r\n\r\n    if (OPERATORS.hasOwnProperty(ident)) {\r\n      token.fn = token.json = OPERATORS[ident];\r\n    } else {\r\n      var getter = getterFn(ident, csp);\r\n      token.fn = extend(function(self, locals) {\r\n        return (getter(self, locals));\r\n      }, {\r\n        assign: function(self, value) {\r\n          return setter(self, ident, value);\r\n        }\r\n      });\r\n    }\r\n\r\n    tokens.push(token);\r\n\r\n    if (methodName) {\r\n      tokens.push({\r\n        index:lastDot,\r\n        text: '.',\r\n        json: false\r\n      });\r\n      tokens.push({\r\n        index: lastDot + 1,\r\n        text: methodName,\r\n        json: false\r\n      });\r\n    }\r\n  }\r\n\r\n  function readString(quote) {\r\n    var start = index;\r\n    index++;\r\n    var string = \"\";\r\n    var rawString = quote;\r\n    var escape = false;\r\n    while (index < text.length) {\r\n      var ch = text.charAt(index);\r\n      rawString += ch;\r\n      if (escape) {\r\n        if (ch == 'u') {\r\n          var hex = text.substring(index + 1, index + 5);\r\n          if (!hex.match(/[\\da-f]{4}/i))\r\n            throwError( \"Invalid unicode escape [\\\\u\" + hex + \"]\");\r\n          index += 4;\r\n          string += String.fromCharCode(parseInt(hex, 16));\r\n        } else {\r\n          var rep = ESCAPE[ch];\r\n          if (rep) {\r\n            string += rep;\r\n          } else {\r\n            string += ch;\r\n          }\r\n        }\r\n        escape = false;\r\n      } else if (ch == '\\\\') {\r\n        escape = true;\r\n      } else if (ch == quote) {\r\n        index++;\r\n        tokens.push({\r\n          index:start,\r\n          text:rawString,\r\n          string:string,\r\n          json:true,\r\n          fn:function() { return string; }\r\n        });\r\n        return;\r\n      } else {\r\n        string += ch;\r\n      }\r\n      index++;\r\n    }\r\n    throwError(\"Unterminated quote\", start);\r\n  }\r\n}\r\n\r\n/////////////////////////////////////////\r\n\r\nfunction parser(text, json, $filter, csp){\r\n  var ZERO = valueFn(0),\r\n      value,\r\n      tokens = lex(text, csp),\r\n      assignment = _assignment,\r\n      functionCall = _functionCall,\r\n      fieldAccess = _fieldAccess,\r\n      objectIndex = _objectIndex,\r\n      filterChain = _filterChain;\r\n\r\n  if(json){\r\n    // The extra level of aliasing is here, just in case the lexer misses something, so that\r\n    // we prevent any accidental execution in JSON.\r\n    assignment = logicalOR;\r\n    functionCall =\r\n      fieldAccess =\r\n      objectIndex =\r\n      filterChain =\r\n        function() { throwError(\"is not valid json\", {text:text, index:0}); };\r\n    value = primary();\r\n  } else {\r\n    value = statements();\r\n  }\r\n  if (tokens.length !== 0) {\r\n    throwError(\"is an unexpected token\", tokens[0]);\r\n  }\r\n  value.literal = !!value.literal;\r\n  value.constant = !!value.constant;\r\n  return value;\r\n\r\n  ///////////////////////////////////\r\n  function throwError(msg, token) {\r\n    throw Error(\"Syntax Error: Token '\" + token.text +\r\n      \"' \" + msg + \" at column \" +\r\n      (token.index + 1) + \" of the expression [\" +\r\n      text + \"] starting at [\" + text.substring(token.index) + \"].\");\r\n  }\r\n\r\n  function peekToken() {\r\n    if (tokens.length === 0)\r\n      throw Error(\"Unexpected end of expression: \" + text);\r\n    return tokens[0];\r\n  }\r\n\r\n  function peek(e1, e2, e3, e4) {\r\n    if (tokens.length > 0) {\r\n      var token = tokens[0];\r\n      var t = token.text;\r\n      if (t==e1 || t==e2 || t==e3 || t==e4 ||\r\n          (!e1 && !e2 && !e3 && !e4)) {\r\n        return token;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function expect(e1, e2, e3, e4){\r\n    var token = peek(e1, e2, e3, e4);\r\n    if (token) {\r\n      if (json && !token.json) {\r\n        throwError(\"is not valid json\", token);\r\n      }\r\n      tokens.shift();\r\n      return token;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function consume(e1){\r\n    if (!expect(e1)) {\r\n      throwError(\"is unexpected, expecting [\" + e1 + \"]\", peek());\r\n    }\r\n  }\r\n\r\n  function unaryFn(fn, right) {\r\n    return extend(function(self, locals) {\r\n      return fn(self, locals, right);\r\n    }, {\r\n      constant:right.constant\r\n    });\r\n  }\r\n\r\n  function ternaryFn(left, middle, right){\r\n    return extend(function(self, locals){\r\n      return left(self, locals) ? middle(self, locals) : right(self, locals);\r\n    }, {\r\n      constant: left.constant && middle.constant && right.constant\r\n    });\r\n  }\r\n  \r\n  function binaryFn(left, fn, right) {\r\n    return extend(function(self, locals) {\r\n      return fn(self, locals, left, right);\r\n    }, {\r\n      constant:left.constant && right.constant\r\n    });\r\n  }\r\n\r\n  function statements() {\r\n    var statements = [];\r\n    while(true) {\r\n      if (tokens.length > 0 && !peek('}', ')', ';', ']'))\r\n        statements.push(filterChain());\r\n      if (!expect(';')) {\r\n        // optimize for the common case where there is only one statement.\r\n        // TODO(size): maybe we should not support multiple statements?\r\n        return statements.length == 1\r\n          ? statements[0]\r\n          : function(self, locals){\r\n            var value;\r\n            for ( var i = 0; i < statements.length; i++) {\r\n              var statement = statements[i];\r\n              if (statement)\r\n                value = statement(self, locals);\r\n            }\r\n            return value;\r\n          };\r\n      }\r\n    }\r\n  }\r\n\r\n  function _filterChain() {\r\n    var left = expression();\r\n    var token;\r\n    while(true) {\r\n      if ((token = expect('|'))) {\r\n        left = binaryFn(left, token.fn, filter());\r\n      } else {\r\n        return left;\r\n      }\r\n    }\r\n  }\r\n\r\n  function filter() {\r\n    var token = expect();\r\n    var fn = $filter(token.text);\r\n    var argsFn = [];\r\n    while(true) {\r\n      if ((token = expect(':'))) {\r\n        argsFn.push(expression());\r\n      } else {\r\n        var fnInvoke = function(self, locals, input){\r\n          var args = [input];\r\n          for ( var i = 0; i < argsFn.length; i++) {\r\n            args.push(argsFn[i](self, locals));\r\n          }\r\n          return fn.apply(self, args);\r\n        };\r\n        return function() {\r\n          return fnInvoke;\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  function expression() {\r\n    return assignment();\r\n  }\r\n\r\n  function _assignment() {\r\n    var left = ternary();\r\n    var right;\r\n    var token;\r\n    if ((token = expect('='))) {\r\n      if (!left.assign) {\r\n        throwError(\"implies assignment but [\" +\r\n          text.substring(0, token.index) + \"] can not be assigned to\", token);\r\n      }\r\n      right = ternary();\r\n      return function(scope, locals){\r\n        return left.assign(scope, right(scope, locals), locals);\r\n      };\r\n    } else {\r\n      return left;\r\n    }\r\n  }\r\n\r\n  function ternary() {\r\n    var left = logicalOR();\r\n    var middle;\r\n    var token;\r\n    if((token = expect('?'))){\r\n      middle = ternary();\r\n      if((token = expect(':'))){\r\n        return ternaryFn(left, middle, ternary());\r\n      }\r\n      else {\r\n        throwError('expected :', token);\r\n      }\r\n    }\r\n    else {\r\n      return left;\r\n    }\r\n  }\r\n  \r\n  function logicalOR() {\r\n    var left = logicalAND();\r\n    var token;\r\n    while(true) {\r\n      if ((token = expect('||'))) {\r\n        left = binaryFn(left, token.fn, logicalAND());\r\n      } else {\r\n        return left;\r\n      }\r\n    }\r\n  }\r\n\r\n  function logicalAND() {\r\n    var left = equality();\r\n    var token;\r\n    if ((token = expect('&&'))) {\r\n      left = binaryFn(left, token.fn, logicalAND());\r\n    }\r\n    return left;\r\n  }\r\n\r\n  function equality() {\r\n    var left = relational();\r\n    var token;\r\n    if ((token = expect('==','!=','===','!=='))) {\r\n      left = binaryFn(left, token.fn, equality());\r\n    }\r\n    return left;\r\n  }\r\n\r\n  function relational() {\r\n    var left = additive();\r\n    var token;\r\n    if ((token = expect('<', '>', '<=', '>='))) {\r\n      left = binaryFn(left, token.fn, relational());\r\n    }\r\n    return left;\r\n  }\r\n\r\n  function additive() {\r\n    var left = multiplicative();\r\n    var token;\r\n    while ((token = expect('+','-'))) {\r\n      left = binaryFn(left, token.fn, multiplicative());\r\n    }\r\n    return left;\r\n  }\r\n\r\n  function multiplicative() {\r\n    var left = unary();\r\n    var token;\r\n    while ((token = expect('*','/','%'))) {\r\n      left = binaryFn(left, token.fn, unary());\r\n    }\r\n    return left;\r\n  }\r\n\r\n  function unary() {\r\n    var token;\r\n    if (expect('+')) {\r\n      return primary();\r\n    } else if ((token = expect('-'))) {\r\n      return binaryFn(ZERO, token.fn, unary());\r\n    } else if ((token = expect('!'))) {\r\n      return unaryFn(token.fn, unary());\r\n    } else {\r\n      return primary();\r\n    }\r\n  }\r\n\r\n\r\n  function primary() {\r\n    var primary;\r\n    if (expect('(')) {\r\n      primary = filterChain();\r\n      consume(')');\r\n    } else if (expect('[')) {\r\n      primary = arrayDeclaration();\r\n    } else if (expect('{')) {\r\n      primary = object();\r\n    } else {\r\n      var token = expect();\r\n      primary = token.fn;\r\n      if (!primary) {\r\n        throwError(\"not a primary expression\", token);\r\n      }\r\n      if (token.json) {\r\n        primary.constant = primary.literal = true;\r\n      }\r\n    }\r\n\r\n    var next, context;\r\n    while ((next = expect('(', '[', '.'))) {\r\n      if (next.text === '(') {\r\n        primary = functionCall(primary, context);\r\n        context = null;\r\n      } else if (next.text === '[') {\r\n        context = primary;\r\n        primary = objectIndex(primary);\r\n      } else if (next.text === '.') {\r\n        context = primary;\r\n        primary = fieldAccess(primary);\r\n      } else {\r\n        throwError(\"IMPOSSIBLE\");\r\n      }\r\n    }\r\n    return primary;\r\n  }\r\n\r\n  function _fieldAccess(object) {\r\n    var field = expect().text;\r\n    var getter = getterFn(field, csp);\r\n    return extend(\r\n        function(scope, locals, self) {\r\n          return getter(self || object(scope, locals), locals);\r\n        },\r\n        {\r\n          assign:function(scope, value, locals) {\r\n            return setter(object(scope, locals), field, value);\r\n          }\r\n        }\r\n    );\r\n  }\r\n\r\n  function _objectIndex(obj) {\r\n    var indexFn = expression();\r\n    consume(']');\r\n    return extend(\r\n      function(self, locals){\r\n        var o = obj(self, locals),\r\n            i = indexFn(self, locals),\r\n            v, p;\r\n\r\n        if (!o) return undefined;\r\n        v = o[i];\r\n        if (v && v.then) {\r\n          p = v;\r\n          if (!('$$v' in v)) {\r\n            p.$$v = undefined;\r\n            p.then(function(val) { p.$$v = val; });\r\n          }\r\n          v = v.$$v;\r\n        }\r\n        return v;\r\n      }, {\r\n        assign:function(self, value, locals){\r\n          return obj(self, locals)[indexFn(self, locals)] = value;\r\n        }\r\n      });\r\n  }\r\n\r\n  function _functionCall(fn, contextGetter) {\r\n    var argsFn = [];\r\n    if (peekToken().text != ')') {\r\n      do {\r\n        argsFn.push(expression());\r\n      } while (expect(','));\r\n    }\r\n    consume(')');\r\n    return function(scope, locals){\r\n      var args = [],\r\n          context = contextGetter ? contextGetter(scope, locals) : scope;\r\n\r\n      for ( var i = 0; i < argsFn.length; i++) {\r\n        args.push(argsFn[i](scope, locals));\r\n      }\r\n      var fnPtr = fn(scope, locals, context) || noop;\r\n      // IE stupidity!\r\n      return fnPtr.apply\r\n          ? fnPtr.apply(context, args)\r\n          : fnPtr(args[0], args[1], args[2], args[3], args[4]);\r\n    };\r\n  }\r\n\r\n  // This is used with json array declaration\r\n  function arrayDeclaration () {\r\n    var elementFns = [];\r\n    var allConstant = true;\r\n    if (peekToken().text != ']') {\r\n      do {\r\n        var elementFn = expression();\r\n        elementFns.push(elementFn);\r\n        if (!elementFn.constant) {\r\n          allConstant = false;\r\n        }\r\n      } while (expect(','));\r\n    }\r\n    consume(']');\r\n    return extend(function(self, locals){\r\n      var array = [];\r\n      for ( var i = 0; i < elementFns.length; i++) {\r\n        array.push(elementFns[i](self, locals));\r\n      }\r\n      return array;\r\n    }, {\r\n      literal:true,\r\n      constant:allConstant\r\n    });\r\n  }\r\n\r\n  function object () {\r\n    var keyValues = [];\r\n    var allConstant = true;\r\n    if (peekToken().text != '}') {\r\n      do {\r\n        var token = expect(),\r\n        key = token.string || token.text;\r\n        consume(\":\");\r\n        var value = expression();\r\n        keyValues.push({key:key, value:value});\r\n        if (!value.constant) {\r\n          allConstant = false;\r\n        }\r\n      } while (expect(','));\r\n    }\r\n    consume('}');\r\n    return extend(function(self, locals){\r\n      var object = {};\r\n      for ( var i = 0; i < keyValues.length; i++) {\r\n        var keyValue = keyValues[i];\r\n        object[keyValue.key] = keyValue.value(self, locals);\r\n      }\r\n      return object;\r\n    }, {\r\n      literal:true,\r\n      constant:allConstant\r\n    });\r\n  }\r\n}\r\n\r\n//////////////////////////////////////////////////\r\n// Parser helper functions\r\n//////////////////////////////////////////////////\r\n\r\nfunction setter(obj, path, setValue) {\r\n  var element = path.split('.');\r\n  for (var i = 0; element.length > 1; i++) {\r\n    var key = element.shift();\r\n    var propertyObj = obj[key];\r\n    if (!propertyObj) {\r\n      propertyObj = {};\r\n      obj[key] = propertyObj;\r\n    }\r\n    obj = propertyObj;\r\n  }\r\n  obj[element.shift()] = setValue;\r\n  return setValue;\r\n}\r\n\r\n/**\r\n * Return the value accessible from the object by path. Any undefined traversals are ignored\r\n * @param {Object} obj starting object\r\n * @param {string} path path to traverse\r\n * @param {boolean=true} bindFnToScope\r\n * @returns value as accessible by path\r\n */\r\n//TODO(misko): this function needs to be removed\r\nfunction getter(obj, path, bindFnToScope) {\r\n  if (!path) return obj;\r\n  var keys = path.split('.');\r\n  var key;\r\n  var lastInstance = obj;\r\n  var len = keys.length;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    key = keys[i];\r\n    if (obj) {\r\n      obj = (lastInstance = obj)[key];\r\n    }\r\n  }\r\n  if (!bindFnToScope && isFunction(obj)) {\r\n    return bind(lastInstance, obj);\r\n  }\r\n  return obj;\r\n}\r\n\r\nvar getterFnCache = {};\r\n\r\n/**\r\n * Implementation of the \"Black Hole\" variant from:\r\n * - http://jsperf.com/angularjs-parse-getter/4\r\n * - http://jsperf.com/path-evaluation-simplified/7\r\n */\r\nfunction cspSafeGetterFn(key0, key1, key2, key3, key4) {\r\n  return function(scope, locals) {\r\n    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,\r\n        promise;\r\n\r\n    if (pathVal === null || pathVal === undefined) return pathVal;\r\n\r\n    pathVal = pathVal[key0];\r\n    if (pathVal && pathVal.then) {\r\n      if (!(\"$$v\" in pathVal)) {\r\n        promise = pathVal;\r\n        promise.$$v = undefined;\r\n        promise.then(function(val) { promise.$$v = val; });\r\n      }\r\n      pathVal = pathVal.$$v;\r\n    }\r\n    if (!key1 || pathVal === null || pathVal === undefined) return pathVal;\r\n\r\n    pathVal = pathVal[key1];\r\n    if (pathVal && pathVal.then) {\r\n      if (!(\"$$v\" in pathVal)) {\r\n        promise = pathVal;\r\n        promise.$$v = undefined;\r\n        promise.then(function(val) { promise.$$v = val; });\r\n      }\r\n      pathVal = pathVal.$$v;\r\n    }\r\n    if (!key2 || pathVal === null || pathVal === undefined) return pathVal;\r\n\r\n    pathVal = pathVal[key2];\r\n    if (pathVal && pathVal.then) {\r\n      if (!(\"$$v\" in pathVal)) {\r\n        promise = pathVal;\r\n        promise.$$v = undefined;\r\n        promise.then(function(val) { promise.$$v = val; });\r\n      }\r\n      pathVal = pathVal.$$v;\r\n    }\r\n    if (!key3 || pathVal === null || pathVal === undefined) return pathVal;\r\n\r\n    pathVal = pathVal[key3];\r\n    if (pathVal && pathVal.then) {\r\n      if (!(\"$$v\" in pathVal)) {\r\n        promise = pathVal;\r\n        promise.$$v = undefined;\r\n        promise.then(function(val) { promise.$$v = val; });\r\n      }\r\n      pathVal = pathVal.$$v;\r\n    }\r\n    if (!key4 || pathVal === null || pathVal === undefined) return pathVal;\r\n\r\n    pathVal = pathVal[key4];\r\n    if (pathVal && pathVal.then) {\r\n      if (!(\"$$v\" in pathVal)) {\r\n        promise = pathVal;\r\n        promise.$$v = undefined;\r\n        promise.then(function(val) { promise.$$v = val; });\r\n      }\r\n      pathVal = pathVal.$$v;\r\n    }\r\n    return pathVal;\r\n  };\r\n}\r\n\r\nfunction getterFn(path, csp) {\r\n  if (getterFnCache.hasOwnProperty(path)) {\r\n    return getterFnCache[path];\r\n  }\r\n\r\n  var pathKeys = path.split('.'),\r\n      pathKeysLength = pathKeys.length,\r\n      fn;\r\n\r\n  if (csp) {\r\n    fn = (pathKeysLength < 6)\r\n        ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4])\r\n        : function(scope, locals) {\r\n          var i = 0, val;\r\n          do {\r\n            val = cspSafeGetterFn(\r\n                    pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++]\r\n                  )(scope, locals);\r\n\r\n            locals = undefined; // clear after first iteration\r\n            scope = val;\r\n          } while (i < pathKeysLength);\r\n          return val;\r\n        }\r\n  } else {\r\n    var code = 'var l, fn, p;\\n';\r\n    forEach(pathKeys, function(key, index) {\r\n      code += 'if(s === null || s === undefined) return s;\\n' +\r\n              'l=s;\\n' +\r\n              's='+ (index\r\n                      // we simply dereference 's' on any .dot notation\r\n                      ? 's'\r\n                      // but if we are first then we check locals first, and if so read it first\r\n                      : '((k&&k.hasOwnProperty(\"' + key + '\"))?k:s)') + '[\"' + key + '\"]' + ';\\n' +\r\n              'if (s && s.then) {\\n' +\r\n                ' if (!(\"$$v\" in s)) {\\n' +\r\n                  ' p=s;\\n' +\r\n                  ' p.$$v = undefined;\\n' +\r\n                  ' p.then(function(v) {p.$$v=v;});\\n' +\r\n                  '}\\n' +\r\n                ' s=s.$$v\\n' +\r\n              '}\\n';\r\n    });\r\n    code += 'return s;';\r\n    fn = Function('s', 'k', code); // s=scope, k=locals\r\n    fn.toString = function() { return code; };\r\n  }\r\n\r\n  return getterFnCache[path] = fn;\r\n}\r\n\r\n///////////////////////////////////\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.$parse\r\n * @function\r\n *\r\n * @description\r\n *\r\n * Converts Angular {@link guide/expression expression} into a function.\r\n *\r\n * <pre>\r\n *   var getter = $parse('user.name');\r\n *   var setter = getter.assign;\r\n *   var context = {user:{name:'angular'}};\r\n *   var locals = {user:{name:'local'}};\r\n *\r\n *   expect(getter(context)).toEqual('angular');\r\n *   setter(context, 'newValue');\r\n *   expect(context.user.name).toEqual('newValue');\r\n *   expect(getter(context, locals)).toEqual('local');\r\n * </pre>\r\n *\r\n *\r\n * @param {string} expression String expression to compile.\r\n * @returns {function(context, locals)} a function which represents the compiled expression:\r\n *\r\n *    * `context`  `{object}`  an object against which any expressions embedded in the strings\r\n *      are evaluated against (typically a scope object).\r\n *    * `locals`  `{object=}`  local variables context object, useful for overriding values in\r\n *      `context`.\r\n *\r\n *    The returned function also has the following properties:\r\n *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript\r\n *        literal.\r\n *      * `constant`  `{boolean}`  whether the expression is made entirely of JavaScript\r\n *        constant literals.\r\n *      * `assign`  `{?function(context, value)}`  if the expression is assignable, this will be\r\n *        set to a function to change its value on the given context.\r\n *\r\n */\r\nfunction $ParseProvider() {\r\n  var cache = {};\r\n  this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {\r\n    return function(exp) {\r\n      switch(typeof exp) {\r\n        case 'string':\r\n          return cache.hasOwnProperty(exp)\r\n            ? cache[exp]\r\n            : cache[exp] =  parser(exp, false, $filter, $sniffer.csp);\r\n        case 'function':\r\n          return exp;\r\n        default:\r\n          return noop;\r\n      }\r\n    };\r\n  }];\r\n}\r\n\r\n/**\r\n * @ngdoc service\r\n * @name ng.$q\r\n * @requires $rootScope\r\n *\r\n * @description\r\n * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).\r\n *\r\n * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an\r\n * interface for interacting with an object that represents the result of an action that is\r\n * performed asynchronously, and may or may not be finished at any given point in time.\r\n *\r\n * From the perspective of dealing with error handling, deferred and promise APIs are to\r\n * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.\r\n *\r\n * <pre>\r\n *   // for the purpose of this example let's assume that variables `$q` and `scope` are\r\n *   // available in the current lexical scope (they could have been injected or passed in).\r\n *\r\n *   function asyncGreet(name) {\r\n *     var deferred = $q.defer();\r\n *\r\n *     setTimeout(function() {\r\n *       // since this fn executes async in a future turn of the event loop, we need to wrap\r\n *       // our code into an $apply call so that the model changes are properly observed.\r\n *       scope.$apply(function() {\r\n *         if (okToGreet(name)) {\r\n *           deferred.resolve('Hello, ' + name + '!');\r\n *         } else {\r\n *           deferred.reject('Greeting ' + name + ' is not allowed.');\r\n *         }\r\n *       });\r\n *     }, 1000);\r\n *\r\n *     return deferred.promise;\r\n *   }\r\n *\r\n *   var promise = asyncGreet('Robin Hood');\r\n *   promise.then(function(greeting) {\r\n *     alert('Success: ' + greeting);\r\n *   }, function(reason) {\r\n *     alert('Failed: ' + reason);\r\n *   });\r\n * </pre>\r\n *\r\n * At first it might not be obvious why this extra complexity is worth the trouble. The payoff\r\n * comes in the way of\r\n * [guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).\r\n *\r\n * Additionally the promise api allows for composition that is very hard to do with the\r\n * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.\r\n * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the\r\n * section on serial or parallel joining of promises.\r\n *\r\n *\r\n * # The Deferred API\r\n *\r\n * A new instance of deferred is constructed by calling `$q.defer()`.\r\n *\r\n * The purpose of the deferred object is to expose the associated Promise instance as well as APIs\r\n * that can be used for signaling the successful or unsuccessful completion of the task.\r\n *\r\n * **Methods**\r\n *\r\n * - `resolve(value)`  resolves the derived promise with the `value`. If the value is a rejection\r\n *   constructed via `$q.reject`, the promise will be rejected instead.\r\n * - `reject(reason)`  rejects the derived promise with the `reason`. This is equivalent to\r\n *   resolving it with a rejection constructed via `$q.reject`.\r\n *\r\n * **Properties**\r\n *\r\n * - promise  `{Promise}`  promise object associated with this deferred.\r\n *\r\n *\r\n * # The Promise API\r\n *\r\n * A new promise instance is created when a deferred instance is created and can be retrieved by\r\n * calling `deferred.promise`.\r\n *\r\n * The purpose of the promise object is to allow for interested parties to get access to the result\r\n * of the deferred task when it completes.\r\n *\r\n * **Methods**\r\n *\r\n * - `then(successCallback, errorCallback)`  regardless of when the promise was or will be resolved\r\n *   or rejected calls one of the success or error callbacks asynchronously as soon as the result\r\n *   is available. The callbacks are called with a single argument the result or rejection reason.\r\n *\r\n *   This method *returns a new promise* which is resolved or rejected via the return value of the\r\n *   `successCallback` or `errorCallback`.\r\n *\r\n * - `always(callback)`  allows you to observe either the fulfillment or rejection of a promise,\r\n *   but to do so without modifying the final value. This is useful to release resources or do some\r\n *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full\r\n *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for\r\n *   more information.\r\n *\r\n * # Chaining promises\r\n *\r\n * Because calling `then` api of a promise returns a new derived promise, it is easily possible\r\n * to create a chain of promises:\r\n *\r\n * <pre>\r\n *   promiseB = promiseA.then(function(result) {\r\n *     return result + 1;\r\n *   });\r\n *\r\n *   // promiseB will be resolved immediately after promiseA is resolved and its value will be\r\n *   // the result of promiseA incremented by 1\r\n * </pre>\r\n *\r\n * It is possible to create chains of any length and since a promise can be resolved with another\r\n * promise (which will defer its resolution further), it is possible to pause/defer resolution of\r\n * the promises at any point in the chain. This makes it possible to implement powerful apis like\r\n * $http's response interceptors.\r\n *\r\n *\r\n * # Differences between Kris Kowal's Q and $q\r\n *\r\n *  There are three main differences:\r\n *\r\n * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation\r\n *   mechanism in angular, which means faster propagation of resolution or rejection into your\r\n *   models and avoiding unnecessary browser repaints, which would result in flickering UI.\r\n * - $q promises are recognized by the templating engine in angular, which means that in templates\r\n *   you can treat promises attached to a scope as if they were the resulting values.\r\n * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains\r\n *   all the important functionality needed for common async tasks.\r\n * \r\n *  # Testing\r\n * \r\n *  <pre>\r\n *    it('should simulate promise', inject(function($q, $rootScope) {\r\n *      var deferred = $q.defer();\r\n *      var promise = deferred.promise;\r\n *      var resolvedValue;\r\n * \r\n *      promise.then(function(value) { resolvedValue = value; });\r\n *      expect(resolvedValue).toBeUndefined();\r\n * \r\n *      // Simulate resolving of promise\r\n *      deferred.resolve(123);\r\n *      // Note that the 'then' function does not get called synchronously.\r\n *      // This is because we want the promise API to always be async, whether or not\r\n *      // it got called synchronously or asynchronously.\r\n *      expect(resolvedValue).toBeUndefined();\r\n * \r\n *      // Propagate promise resolution to 'then' functions using $apply().\r\n *      $rootScope.$apply();\r\n *      expect(resolvedValue).toEqual(123);\r\n *    });\r\n *  </pre>\r\n */\r\nfunction $QProvider() {\r\n\r\n  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {\r\n    return qFactory(function(callback) {\r\n      $rootScope.$evalAsync(callback);\r\n    }, $exceptionHandler);\r\n  }];\r\n}\r\n\r\n\r\n/**\r\n * Constructs a promise manager.\r\n *\r\n * @param {function(function)} nextTick Function for executing functions in the next turn.\r\n * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for\r\n *     debugging purposes.\r\n * @returns {object} Promise manager.\r\n */\r\nfunction qFactory(nextTick, exceptionHandler) {\r\n\r\n  /**\r\n   * @ngdoc\r\n   * @name ng.$q#defer\r\n   * @methodOf ng.$q\r\n   * @description\r\n   * Creates a `Deferred` object which represents a task which will finish in the future.\r\n   *\r\n   * @returns {Deferred} Returns a new instance of deferred.\r\n   */\r\n  var defer = function() {\r\n    var pending = [],\r\n        value, deferred;\r\n\r\n    deferred = {\r\n\r\n      resolve: function(val) {\r\n        if (pending) {\r\n          var callbacks = pending;\r\n          pending = undefined;\r\n          value = ref(val);\r\n\r\n          if (callbacks.length) {\r\n            nextTick(function() {\r\n              var callback;\r\n              for (var i = 0, ii = callbacks.length; i < ii; i++) {\r\n                callback = callbacks[i];\r\n                value.then(callback[0], callback[1]);\r\n              }\r\n            });\r\n          }\r\n        }\r\n      },\r\n\r\n\r\n      reject: function(reason) {\r\n        deferred.resolve(reject(reason));\r\n      },\r\n\r\n\r\n      promise: {\r\n        then: function(callback, errback) {\r\n          var result = defer();\r\n\r\n          var wrappedCallback = function(value) {\r\n            try {\r\n              result.resolve((callback || defaultCallback)(value));\r\n            } catch(e) {\r\n              exceptionHandler(e);\r\n              result.reject(e);\r\n            }\r\n          };\r\n\r\n          var wrappedErrback = function(reason) {\r\n            try {\r\n              result.resolve((errback || defaultErrback)(reason));\r\n            } catch(e) {\r\n              exceptionHandler(e);\r\n              result.reject(e);\r\n            }\r\n          };\r\n\r\n          if (pending) {\r\n            pending.push([wrappedCallback, wrappedErrback]);\r\n          } else {\r\n            value.then(wrappedCallback, wrappedErrback);\r\n          }\r\n\r\n          return result.promise;\r\n        },\r\n        always: function(callback) {\r\n          \r\n          function makePromise(value, resolved) {\r\n            var result = defer();\r\n            if (resolved) {\r\n              result.resolve(value);\r\n            } else {\r\n              result.reject(value);\r\n            }\r\n            return result.promise;\r\n          }\r\n          \r\n          function handleCallback(value, isResolved) {\r\n            var callbackOutput = null;            \r\n            try {\r\n              callbackOutput = (callback ||defaultCallback)();\r\n            } catch(e) {\r\n              return makePromise(e, false);\r\n            }            \r\n            if (callbackOutput && callbackOutput.then) {\r\n              return callbackOutput.then(function() {\r\n                return makePromise(value, isResolved);\r\n              }, function(error) {\r\n                return makePromise(error, false);\r\n              });\r\n            } else {\r\n              return makePromise(value, isResolved);\r\n            }\r\n          }\r\n          \r\n          return this.then(function(value) {\r\n            return handleCallback(value, true);\r\n          }, function(error) {\r\n            return handleCallback(error, false);\r\n          });\r\n        }\r\n      }\r\n    };\r\n\r\n    return deferred;\r\n  };\r\n\r\n\r\n  var ref = function(value) {\r\n    if (value && value.then) return value;\r\n    return {\r\n      then: function(callback) {\r\n        var result = defer();\r\n        nextTick(function() {\r\n          result.resolve(callback(value));\r\n        });\r\n        return result.promise;\r\n      }\r\n    };\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc\r\n   * @name ng.$q#reject\r\n   * @methodOf ng.$q\r\n   * @description\r\n   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be\r\n   * used to forward rejection in a chain of promises. If you are dealing with the last promise in\r\n   * a promise chain, you don't need to worry about it.\r\n   *\r\n   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of\r\n   * `reject` as the `throw` keyword in JavaScript. This also means that if you \"catch\" an error via\r\n   * a promise error callback and you want to forward the error to the promise derived from the\r\n   * current promise, you have to \"rethrow\" the error by returning a rejection constructed via\r\n   * `reject`.\r\n   *\r\n   * <pre>\r\n   *   promiseB = promiseA.then(function(result) {\r\n   *     // success: do something and resolve promiseB\r\n   *     //          with the old or a new result\r\n   *     return result;\r\n   *   }, function(reason) {\r\n   *     // error: handle the error if possible and\r\n   *     //        resolve promiseB with newPromiseOrValue,\r\n   *     //        otherwise forward the rejection to promiseB\r\n   *     if (canHandle(reason)) {\r\n   *      // handle the error and recover\r\n   *      return newPromiseOrValue;\r\n   *     }\r\n   *     return $q.reject(reason);\r\n   *   });\r\n   * </pre>\r\n   *\r\n   * @param {*} reason Constant, message, exception or an object representing the rejection reason.\r\n   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.\r\n   */\r\n  var reject = function(reason) {\r\n    return {\r\n      then: function(callback, errback) {\r\n        var result = defer();\r\n        nextTick(function() {\r\n          result.resolve((errback || defaultErrback)(reason));\r\n        });\r\n        return result.promise;\r\n      }\r\n    };\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc\r\n   * @name ng.$q#when\r\n   * @methodOf ng.$q\r\n   * @description\r\n   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.\r\n   * This is useful when you are dealing with an object that might or might not be a promise, or if\r\n   * the promise comes from a source that can't be trusted.\r\n   *\r\n   * @param {*} value Value or a promise\r\n   * @returns {Promise} Returns a promise of the passed value or promise\r\n   */\r\n  var when = function(value, callback, errback) {\r\n    var result = defer(),\r\n        done;\r\n\r\n    var wrappedCallback = function(value) {\r\n      try {\r\n        return (callback || defaultCallback)(value);\r\n      } catch (e) {\r\n        exceptionHandler(e);\r\n        return reject(e);\r\n      }\r\n    };\r\n\r\n    var wrappedErrback = function(reason) {\r\n      try {\r\n        return (errback || defaultErrback)(reason);\r\n      } catch (e) {\r\n        exceptionHandler(e);\r\n        return reject(e);\r\n      }\r\n    };\r\n\r\n    nextTick(function() {\r\n      ref(value).then(function(value) {\r\n        if (done) return;\r\n        done = true;\r\n        result.resolve(ref(value).then(wrappedCallback, wrappedErrback));\r\n      }, function(reason) {\r\n        if (done) return;\r\n        done = true;\r\n        result.resolve(wrappedErrback(reason));\r\n      });\r\n    });\r\n\r\n    return result.promise;\r\n  };\r\n\r\n\r\n  function defaultCallback(value) {\r\n    return value;\r\n  }\r\n\r\n\r\n  function defaultErrback(reason) {\r\n    return reject(reason);\r\n  }\r\n\r\n\r\n  /**\r\n   * @ngdoc\r\n   * @name ng.$q#all\r\n   * @methodOf ng.$q\r\n   * @description\r\n   * Combines multiple promises into a single promise that is resolved when all of the input\r\n   * promises are resolved.\r\n   *\r\n   * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.\r\n   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,\r\n   *   each value corresponding to the promise at the same index/key in the `promises` array/hash. If any of\r\n   *   the promises is resolved with a rejection, this resulting promise will be resolved with the\r\n   *   same rejection.\r\n   */\r\n  function all(promises) {\r\n    var deferred = defer(),\r\n        counter = 0,\r\n        results = isArray(promises) ? [] : {};\r\n\r\n    forEach(promises, function(promise, key) {\r\n      counter++;\r\n      ref(promise).then(function(value) {\r\n        if (results.hasOwnProperty(key)) return;\r\n        results[key] = value;\r\n        if (!(--counter)) deferred.resolve(results);\r\n      }, function(reason) {\r\n        if (results.hasOwnProperty(key)) return;\r\n        deferred.reject(reason);\r\n      });\r\n    });\r\n\r\n    if (counter === 0) {\r\n      deferred.resolve(results);\r\n    }\r\n\r\n    return deferred.promise;\r\n  }\r\n\r\n  return {\r\n    defer: defer,\r\n    reject: reject,\r\n    when: when,\r\n    all: all\r\n  };\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$routeProvider\r\n * @function\r\n *\r\n * @description\r\n *\r\n * Used for configuring routes. See {@link ng.$route $route} for an example.\r\n */\r\nfunction $RouteProvider(){\r\n  var routes = {};\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$routeProvider#when\r\n   * @methodOf ng.$routeProvider\r\n   *\r\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\r\n   *    contains redundant trailing slash or is missing one, the route will still match and the\r\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\r\n   *    route definition.\r\n   *\r\n   *      * `path` can contain named groups starting with a colon (`:name`). All characters up\r\n   *        to the next slash are matched and stored in `$routeParams` under the given `name`\r\n   *        when the route matches.\r\n   *      * `path` can contain named groups starting with a star (`*name`). All characters are\r\n   *        eagerly stored in `$routeParams` under the given `name` when the route matches.\r\n   *\r\n   *    For example, routes like `/color/:color/largecode/*largecode/edit` will match\r\n   *    `/color/brown/largecode/code/with/slashs/edit` and extract:\r\n   *\r\n   *      * `color: brown`\r\n   *      * `largecode: code/with/slashs`.\r\n   *\r\n   *\r\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\r\n   *    match.\r\n   *\r\n   *    Object properties:\r\n   *\r\n   *    - `controller`  `{(string|function()=}`  Controller fn that should be associated with newly\r\n   *      created scope or the name of a {@link angular.Module#controller registered controller}\r\n   *      if passed as a string.\r\n   *    - `controllerAs`  `{string=}`  A controller alias name. If present the controller will be\r\n   *      published to scope under the `controllerAs` name.\r\n   *    - `template`  `{string=|function()=}`  html template as a string or function that returns\r\n   *      an html template as a string which should be used by {@link ng.directive:ngView ngView} or\r\n   *      {@link ng.directive:ngInclude ngInclude} directives.\r\n   *      This property takes precedence over `templateUrl`.\r\n   *\r\n   *      If `template` is a function, it will be called with the following parameters:\r\n   *\r\n   *      - `{Array.<Object>}` - route parameters extracted from the current\r\n   *        `$location.path()` by applying the current route\r\n   *\r\n   *    - `templateUrl`  `{string=|function()=}`  path or function that returns a path to an html\r\n   *      template that should be used by {@link ng.directive:ngView ngView}.\r\n   *\r\n   *      If `templateUrl` is a function, it will be called with the following parameters:\r\n   *\r\n   *      - `{Array.<Object>}` - route parameters extracted from the current\r\n   *        `$location.path()` by applying the current route\r\n   *\r\n   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\r\n   *      be injected into the controller. If any of these dependencies are promises, they will be\r\n   *      resolved and converted to a value before the controller is instantiated and the\r\n   *      `$routeChangeSuccess` event is fired. The map object is:\r\n   *\r\n   *      - `key`  `{string}`: a name of a dependency to be injected into the controller.\r\n   *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\r\n   *        Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}\r\n   *        and the return value is treated as the dependency. If the result is a promise, it is resolved\r\n   *        before its value is injected into the controller.\r\n   *\r\n   *    - `redirectTo`  {(string|function())=}  value to update\r\n   *      {@link ng.$location $location} path with and trigger route redirection.\r\n   *\r\n   *      If `redirectTo` is a function, it will be called with the following parameters:\r\n   *\r\n   *      - `{Object.<string>}` - route parameters extracted from the current\r\n   *        `$location.path()` by applying the current route templateUrl.\r\n   *      - `{string}` - current `$location.path()`\r\n   *      - `{Object}` - current `$location.search()`\r\n   *\r\n   *      The custom `redirectTo` function is expected to return a string which will be used\r\n   *      to update `$location.path()` and `$location.search()`.\r\n   *\r\n   *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()\r\n   *    changes.\r\n   *\r\n   *      If the option is set to `false` and url in the browser changes, then\r\n   *      `$routeUpdate` event is broadcasted on the root scope.\r\n   *\r\n   *    - `[caseInsensitiveMatch=false]` - {boolean=} - match routes without being case sensitive\r\n   *\r\n   *      If the option is set to `true`, then the particular route can be matched without being\r\n   *      case sensitive\r\n   *\r\n   * @returns {Object} self\r\n   *\r\n   * @description\r\n   * Adds a new route definition to the `$route` service.\r\n   */\r\n  this.when = function(path, route) {\r\n    routes[path] = extend({reloadOnSearch: true, caseInsensitiveMatch: false}, route);\r\n\r\n    // create redirection for trailing slashes\r\n    if (path) {\r\n      var redirectPath = (path[path.length-1] == '/')\r\n          ? path.substr(0, path.length-1)\r\n          : path +'/';\r\n\r\n      routes[redirectPath] = {redirectTo: path};\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name ng.$routeProvider#otherwise\r\n   * @methodOf ng.$routeProvider\r\n   *\r\n   * @description\r\n   * Sets route definition that will be used on route change when no other route definition\r\n   * is matched.\r\n   *\r\n   * @param {Object} params Mapping information to be assigned to `$route.current`.\r\n   * @returns {Object} self\r\n   */\r\n  this.otherwise = function(params) {\r\n    this.when(null, params);\r\n    return this;\r\n  };\r\n\r\n\r\n  this.$get = ['$rootScope', '$location', '$routeParams', '$q', '$injector', '$http', '$templateCache',\r\n      function( $rootScope,   $location,   $routeParams,   $q,   $injector,   $http,   $templateCache) {\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ng.$route\r\n     * @requires $location\r\n     * @requires $routeParams\r\n     *\r\n     * @property {Object} current Reference to the current route definition.\r\n     * The route definition contains:\r\n     *\r\n     *   - `controller`: The controller constructor as define in route definition.\r\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\r\n     *     controller instantiation. The `locals` contain\r\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\r\n     *\r\n     *     - `$scope` - The current route scope.\r\n     *     - `$template` - The current route template HTML.\r\n     *\r\n     * @property {Array.<Object>} routes Array of all configured routes.\r\n     *\r\n     * @description\r\n     * Is used for deep-linking URLs to controllers and views (HTML partials).\r\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\r\n     *\r\n     * You can define routes through {@link ng.$routeProvider $routeProvider}'s API.\r\n     *\r\n     * The `$route` service is typically used in conjunction with {@link ng.directive:ngView ngView}\r\n     * directive and the {@link ng.$routeParams $routeParams} service.\r\n     *\r\n     * @example\r\n       This example shows how changing the URL hash causes the `$route` to match a route against the\r\n       URL, and the `ngView` pulls in the partial.\r\n\r\n       Note that this example is using {@link ng.directive:script inlined templates}\r\n       to get it working on jsfiddle as well.\r\n\r\n     <example module=\"ngView\">\r\n       <file name=\"index.html\">\r\n         <div ng-controller=\"MainCntl\">\r\n           Choose:\r\n           <a href=\"Book/Moby\">Moby</a> |\r\n           <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\r\n           <a href=\"Book/Gatsby\">Gatsby</a> |\r\n           <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\r\n           <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\r\n\r\n           <div ng-view></div>\r\n           <hr />\r\n\r\n           <pre>$location.path() = {{$location.path()}}</pre>\r\n           <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\r\n           <pre>$route.current.params = {{$route.current.params}}</pre>\r\n           <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\r\n           <pre>$routeParams = {{$routeParams}}</pre>\r\n         </div>\r\n       </file>\r\n\r\n       <file name=\"book.html\">\r\n         controller: {{name}}<br />\r\n         Book Id: {{params.bookId}}<br />\r\n       </file>\r\n\r\n       <file name=\"chapter.html\">\r\n         controller: {{name}}<br />\r\n         Book Id: {{params.bookId}}<br />\r\n         Chapter Id: {{params.chapterId}}\r\n       </file>\r\n\r\n       <file name=\"script.js\">\r\n         angular.module('ngView', [], function($routeProvider, $locationProvider) {\r\n           $routeProvider.when('/Book/:bookId', {\r\n             templateUrl: 'book.html',\r\n             controller: BookCntl,\r\n             resolve: {\r\n               // I will cause a 1 second delay\r\n               delay: function($q, $timeout) {\r\n                 var delay = $q.defer();\r\n                 $timeout(delay.resolve, 1000);\r\n                 return delay.promise;\r\n               }\r\n             }\r\n           });\r\n           $routeProvider.when('/Book/:bookId/ch/:chapterId', {\r\n             templateUrl: 'chapter.html',\r\n             controller: ChapterCntl\r\n           });\r\n\r\n           // configure html5 to get links working on jsfiddle\r\n           $locationProvider.html5Mode(true);\r\n         });\r\n\r\n         function MainCntl($scope, $route, $routeParams, $location) {\r\n           $scope.$route = $route;\r\n           $scope.$location = $location;\r\n           $scope.$routeParams = $routeParams;\r\n         }\r\n\r\n         function BookCntl($scope, $routeParams) {\r\n           $scope.name = \"BookCntl\";\r\n           $scope.params = $routeParams;\r\n         }\r\n\r\n         function ChapterCntl($scope, $routeParams) {\r\n           $scope.name = \"ChapterCntl\";\r\n           $scope.params = $routeParams;\r\n         }\r\n       </file>\r\n\r\n       <file name=\"scenario.js\">\r\n         it('should load and compile correct template', function() {\r\n           element('a:contains(\"Moby: Ch1\")').click();\r\n           var content = element('.doc-example-live [ng-view]').text();\r\n           expect(content).toMatch(/controller\\: ChapterCntl/);\r\n           expect(content).toMatch(/Book Id\\: Moby/);\r\n           expect(content).toMatch(/Chapter Id\\: 1/);\r\n\r\n           element('a:contains(\"Scarlet\")').click();\r\n           sleep(2); // promises are not part of scenario waiting\r\n           content = element('.doc-example-live [ng-view]').text();\r\n           expect(content).toMatch(/controller\\: BookCntl/);\r\n           expect(content).toMatch(/Book Id\\: Scarlet/);\r\n         });\r\n       </file>\r\n     </example>\r\n     */\r\n\r\n    /**\r\n     * @ngdoc event\r\n     * @name ng.$route#$routeChangeStart\r\n     * @eventOf ng.$route\r\n     * @eventType broadcast on root scope\r\n     * @description\r\n     * Broadcasted before a route change. At this  point the route services starts\r\n     * resolving all of the dependencies needed for the route change to occurs.\r\n     * Typically this involves fetching the view template as well as any dependencies\r\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\r\n     * `$routeChangeSuccess` is fired.\r\n     *\r\n     * @param {Route} next Future route information.\r\n     * @param {Route} current Current route information.\r\n     */\r\n\r\n    /**\r\n     * @ngdoc event\r\n     * @name ng.$route#$routeChangeSuccess\r\n     * @eventOf ng.$route\r\n     * @eventType broadcast on root scope\r\n     * @description\r\n     * Broadcasted after a route dependencies are resolved.\r\n     * {@link ng.directive:ngView ngView} listens for the directive\r\n     * to instantiate the controller and render the view.\r\n     *\r\n     * @param {Object} angularEvent Synthetic event object.\r\n     * @param {Route} current Current route information.\r\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is first route entered.\r\n     */\r\n\r\n    /**\r\n     * @ngdoc event\r\n     * @name ng.$route#$routeChangeError\r\n     * @eventOf ng.$route\r\n     * @eventType broadcast on root scope\r\n     * @description\r\n     * Broadcasted if any of the resolve promises are rejected.\r\n     *\r\n     * @param {Route} current Current route information.\r\n     * @param {Route} previous Previous route information.\r\n     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.\r\n     */\r\n\r\n    /**\r\n     * @ngdoc event\r\n     * @name ng.$route#$routeUpdate\r\n     * @eventOf ng.$route\r\n     * @eventType broadcast on root scope\r\n     * @description\r\n     *\r\n     * The `reloadOnSearch` property has been set to false, and we are reusing the same\r\n     * instance of the Controller.\r\n     */\r\n\r\n    var forceReload = false,\r\n        $route = {\r\n          routes: routes,\r\n\r\n          /**\r\n           * @ngdoc method\r\n           * @name ng.$route#reload\r\n           * @methodOf ng.$route\r\n           *\r\n           * @description\r\n           * Causes `$route` service to reload the current route even if\r\n           * {@link ng.$location $location} hasn't changed.\r\n           *\r\n           * As a result of that, {@link ng.directive:ngView ngView}\r\n           * creates new scope, reinstantiates the controller.\r\n           */\r\n          reload: function() {\r\n            forceReload = true;\r\n            $rootScope.$evalAsync(updateRoute);\r\n          }\r\n        };\r\n\r\n    $rootScope.$on('$locationChangeSuccess', updateRoute);\r\n\r\n    return $route;\r\n\r\n    /////////////////////////////////////////////////////\r\n\r\n    /**\r\n     * @param on {string} current url\r\n     * @param when {string} route when template to match the url against\r\n     * @param whenProperties {Object} properties to define when's matching behavior\r\n     * @return {?Object}\r\n     */\r\n    function switchRouteMatcher(on, when, whenProperties) {\r\n      // TODO(i): this code is convoluted and inefficient, we should construct the route matching\r\n      //   regex only once and then reuse it\r\n\r\n      // Escape regexp special characters.\r\n      when = '^' + when.replace(/[-\\/\\\\^$:*+?.()|[\\]{}]/g, \"\\\\$&\") + '$';\r\n\r\n      var regex = '',\r\n          params = [],\r\n          dst = {};\r\n\r\n      var re = /\\\\([:*])(\\w+)/g,\r\n          paramMatch,\r\n          lastMatchedIndex = 0;\r\n\r\n      while ((paramMatch = re.exec(when)) !== null) {\r\n        // Find each :param in `when` and replace it with a capturing group.\r\n        // Append all other sections of when unchanged.\r\n        regex += when.slice(lastMatchedIndex, paramMatch.index);\r\n        switch(paramMatch[1]) {\r\n          case ':':\r\n            regex += '([^\\\\/]*)';\r\n            break;\r\n          case '*':\r\n            regex += '(.*)';\r\n            break;\r\n        }\r\n        params.push(paramMatch[2]);\r\n        lastMatchedIndex = re.lastIndex;\r\n      }\r\n      // Append trailing path part.\r\n      regex += when.substr(lastMatchedIndex);\r\n\r\n      var match = on.match(new RegExp(regex, whenProperties.caseInsensitiveMatch ? 'i' : ''));\r\n      if (match) {\r\n        forEach(params, function(name, index) {\r\n          dst[name] = match[index + 1];\r\n        });\r\n      }\r\n      return match ? dst : null;\r\n    }\r\n\r\n    function updateRoute() {\r\n      var next = parseRoute(),\r\n          last = $route.current;\r\n\r\n      if (next && last && next.$$route === last.$$route\r\n          && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {\r\n        last.params = next.params;\r\n        copy(last.params, $routeParams);\r\n        $rootScope.$broadcast('$routeUpdate', last);\r\n      } else if (next || last) {\r\n        forceReload = false;\r\n        $rootScope.$broadcast('$routeChangeStart', next, last);\r\n        $route.current = next;\r\n        if (next) {\r\n          if (next.redirectTo) {\r\n            if (isString(next.redirectTo)) {\r\n              $location.path(interpolate(next.redirectTo, next.params)).search(next.params)\r\n                       .replace();\r\n            } else {\r\n              $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))\r\n                       .replace();\r\n            }\r\n          }\r\n        }\r\n\r\n        $q.when(next).\r\n          then(function() {\r\n            if (next) {\r\n              var locals = extend({}, next.resolve),\r\n                  template;\r\n\r\n              forEach(locals, function(value, key) {\r\n                locals[key] = isString(value) ? $injector.get(value) : $injector.invoke(value);\r\n              });\r\n\r\n              if (isDefined(template = next.template)) {\r\n                if (isFunction(template)) {\r\n                  template = template(next.params);\r\n                }\r\n              } else if (isDefined(template = next.templateUrl)) {\r\n                if (isFunction(template)) {\r\n                  template = template(next.params);\r\n                }\r\n                if (isDefined(template)) {\r\n                  next.loadedTemplateUrl = template;\r\n                  template = $http.get(template, {cache: $templateCache}).\r\n                      then(function(response) { return response.data; });\r\n                }\r\n              }\r\n              if (isDefined(template)) {\r\n                locals['$template'] = template;\r\n              }\r\n              return $q.all(locals);\r\n            }\r\n          }).\r\n          // after route change\r\n          then(function(locals) {\r\n            if (next == $route.current) {\r\n              if (next) {\r\n                next.locals = locals;\r\n                copy(next.params, $routeParams);\r\n              }\r\n              $rootScope.$broadcast('$routeChangeSuccess', next, last);\r\n            }\r\n          }, function(error) {\r\n            if (next == $route.current) {\r\n              $rootScope.$broadcast('$routeChangeError', next, last, error);\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @returns the current active route, by matching it against the URL\r\n     */\r\n    function parseRoute() {\r\n      // Match a route\r\n      var params, match;\r\n      forEach(routes, function(route, path) {\r\n        if (!match && (params = switchRouteMatcher($location.path(), path, route))) {\r\n          match = inherit(route, {\r\n            params: extend({}, $location.search(), params),\r\n            pathParams: params});\r\n          match.$$route = route;\r\n        }\r\n      });\r\n      // No route matched; fallback to \"otherwise\" route\r\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\r\n    }\r\n\r\n    /**\r\n     * @returns interpolation of the redirect path with the parameters\r\n     */\r\n    function interpolate(string, params) {\r\n      var result = [];\r\n      forEach((string||'').split(':'), function(segment, i) {\r\n        if (i == 0) {\r\n          result.push(segment);\r\n        } else {\r\n          var segmentMatch = segment.match(/(\\w+)(.*)/);\r\n          var key = segmentMatch[1];\r\n          result.push(params[key]);\r\n          result.push(segmentMatch[2] || '');\r\n          delete params[key];\r\n        }\r\n      });\r\n      return result.join('');\r\n    }\r\n  }];\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$routeParams\r\n * @requires $route\r\n *\r\n * @description\r\n * Current set of route parameters. The route parameters are a combination of the\r\n * {@link ng.$location $location} `search()`, and `path()`. The `path` parameters\r\n * are extracted when the {@link ng.$route $route} path is matched.\r\n *\r\n * In case of parameter name collision, `path` params take precedence over `search` params.\r\n *\r\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\r\n * (but its properties will likely change) even when a route change occurs.\r\n *\r\n * @example\r\n * <pre>\r\n *  // Given:\r\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\r\n *  // Route: /Chapter/:chapterId/Section/:sectionId\r\n *  //\r\n *  // Then\r\n *  $routeParams ==> {chapterId:1, sectionId:2, search:'moby'}\r\n * </pre>\r\n */\r\nfunction $RouteParamsProvider() {\r\n  this.$get = valueFn({});\r\n}\r\n\r\n/**\r\n * DESIGN NOTES\r\n *\r\n * The design decisions behind the scope are heavily favored for speed and memory consumption.\r\n *\r\n * The typical use of scope is to watch the expressions, which most of the time return the same\r\n * value as last time so we optimize the operation.\r\n *\r\n * Closures construction is expensive in terms of speed as well as memory:\r\n *   - No closures, instead use prototypical inheritance for API\r\n *   - Internal state needs to be stored on scope directly, which means that private state is\r\n *     exposed as $$____ properties\r\n *\r\n * Loop operations are optimized by using while(count--) { ... }\r\n *   - this means that in order to keep the same order of execution as addition we have to add\r\n *     items to the array at the beginning (shift) instead of at the end (push)\r\n *\r\n * Child scopes are created and removed often\r\n *   - Using an array would be slow since inserts in middle are expensive so we use linked list\r\n *\r\n * There are few watches then a lot of observers. This is why you don't want the observer to be\r\n * implemented in the same way as watch. Watch requires return of initialization function which\r\n * are expensive to construct.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$rootScopeProvider\r\n * @description\r\n *\r\n * Provider for the $rootScope service.\r\n */\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.$rootScopeProvider#digestTtl\r\n * @methodOf ng.$rootScopeProvider\r\n * @description\r\n *\r\n * Sets the number of digest iterations the scope should attempt to execute before giving up and\r\n * assuming that the model is unstable.\r\n *\r\n * The current default is 10 iterations.\r\n *\r\n * @param {number} limit The number of digest iterations.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$rootScope\r\n * @description\r\n *\r\n * Every application has a single root {@link ng.$rootScope.Scope scope}.\r\n * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide\r\n * event processing life-cycle. See {@link guide/scope developer guide on scopes}.\r\n */\r\nfunction $RootScopeProvider(){\r\n  var TTL = 10;\r\n\r\n  this.digestTtl = function(value) {\r\n    if (arguments.length) {\r\n      TTL = value;\r\n    }\r\n    return TTL;\r\n  };\r\n\r\n  this.$get = ['$injector', '$exceptionHandler', '$parse',\r\n      function( $injector,   $exceptionHandler,   $parse) {\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ng.$rootScope.Scope\r\n     *\r\n     * @description\r\n     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the\r\n     * {@link AUTO.$injector $injector}. Child scopes are created using the\r\n     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when\r\n     * compiled HTML template is executed.)\r\n     *\r\n     * Here is a simple scope snippet to show how you can interact with the scope.\r\n     * <pre>\r\n     * <file src=\"./test/ng/rootScopeSpec.js\" tag=\"docs1\" />\r\n     * </pre>\r\n     *\r\n     * # Inheritance\r\n     * A scope can inherit from a parent scope, as in this example:\r\n     * <pre>\r\n         var parent = $rootScope;\r\n         var child = parent.$new();\r\n\r\n         parent.salutation = \"Hello\";\r\n         child.name = \"World\";\r\n         expect(child.salutation).toEqual('Hello');\r\n\r\n         child.salutation = \"Welcome\";\r\n         expect(child.salutation).toEqual('Welcome');\r\n         expect(parent.salutation).toEqual('Hello');\r\n     * </pre>\r\n     *\r\n     *\r\n     * @param {Object.<string, function()>=} providers Map of service factory which need to be provided\r\n     *     for the current scope. Defaults to {@link ng}.\r\n     * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should\r\n     *     append/override services provided by `providers`. This is handy when unit-testing and having\r\n     *     the need to override a default service.\r\n     * @returns {Object} Newly created scope.\r\n     *\r\n     */\r\n    function Scope() {\r\n      this.$id = nextUid();\r\n      this.$$phase = this.$parent = this.$$watchers =\r\n                     this.$$nextSibling = this.$$prevSibling =\r\n                     this.$$childHead = this.$$childTail = null;\r\n      this['this'] = this.$root =  this;\r\n      this.$$destroyed = false;\r\n      this.$$asyncQueue = [];\r\n      this.$$listeners = {};\r\n      this.$$isolateBindings = {};\r\n    }\r\n\r\n    /**\r\n     * @ngdoc property\r\n     * @name ng.$rootScope.Scope#$id\r\n     * @propertyOf ng.$rootScope.Scope\r\n     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for\r\n     *   debugging.\r\n     */\r\n\r\n\r\n    Scope.prototype = {\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$new\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Creates a new child {@link ng.$rootScope.Scope scope}.\r\n       *\r\n       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and\r\n       * {@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope\r\n       * hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.\r\n       *\r\n       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for\r\n       * the scope and its child scopes to be permanently detached from the parent and thus stop\r\n       * participating in model change detection and listener notification by invoking.\r\n       *\r\n       * @param {boolean} isolate if true then the scope does not prototypically inherit from the\r\n       *         parent scope. The scope is isolated, as it can not see parent scope properties.\r\n       *         When creating widgets it is useful for the widget to not accidentally read parent\r\n       *         state.\r\n       *\r\n       * @returns {Object} The newly created child scope.\r\n       *\r\n       */\r\n      $new: function(isolate) {\r\n        var Child,\r\n            child;\r\n\r\n        if (isFunction(isolate)) {\r\n          // TODO: remove at some point\r\n          throw Error('API-CHANGE: Use $controller to instantiate controllers.');\r\n        }\r\n        if (isolate) {\r\n          child = new Scope();\r\n          child.$root = this.$root;\r\n        } else {\r\n          Child = function() {}; // should be anonymous; This is so that when the minifier munges\r\n            // the name it does not become random set of chars. These will then show up as class\r\n            // name in the debugger.\r\n          Child.prototype = this;\r\n          child = new Child();\r\n          child.$id = nextUid();\r\n        }\r\n        child['this'] = child;\r\n        child.$$listeners = {};\r\n        child.$parent = this;\r\n        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;\r\n        child.$$prevSibling = this.$$childTail;\r\n        if (this.$$childHead) {\r\n          this.$$childTail.$$nextSibling = child;\r\n          this.$$childTail = child;\r\n        } else {\r\n          this.$$childHead = this.$$childTail = child;\r\n        }\r\n        return child;\r\n      },\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$watch\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.\r\n       *\r\n       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest $digest()} and\r\n       *   should return the value which will be watched. (Since {@link ng.$rootScope.Scope#$digest $digest()}\r\n       *   reruns when it detects changes the `watchExpression` can execute multiple times per\r\n       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)\r\n       * - The `listener` is called only when the value from the current `watchExpression` and the\r\n       *   previous call to `watchExpression` are not equal (with the exception of the initial run,\r\n       *   see below). The inequality is determined according to\r\n       *   {@link angular.equals} function. To save the value of the object for later comparison, the\r\n       *   {@link angular.copy} function is used. It also means that watching complex options will\r\n       *   have adverse memory and performance implications.\r\n       * - The watch `listener` may change the model, which may trigger other `listener`s to fire. This\r\n       *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration\r\n       *   limit is 10 to prevent an infinite loop deadlock.\r\n       *\r\n       *\r\n       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,\r\n       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`\r\n       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a change is\r\n       * detected, be prepared for multiple calls to your listener.)\r\n       *\r\n       * After a watcher is registered with the scope, the `listener` fn is called asynchronously\r\n       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the\r\n       * watcher. In rare cases, this is undesirable because the listener is called when the result\r\n       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you\r\n       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the\r\n       * listener was called due to initialization.\r\n       *\r\n       *\r\n       * # Example\r\n       * <pre>\r\n           // let's assume that scope was dependency injected as the $rootScope\r\n           var scope = $rootScope;\r\n           scope.name = 'misko';\r\n           scope.counter = 0;\r\n\r\n           expect(scope.counter).toEqual(0);\r\n           scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; });\r\n           expect(scope.counter).toEqual(0);\r\n\r\n           scope.$digest();\r\n           // no variable change\r\n           expect(scope.counter).toEqual(0);\r\n\r\n           scope.name = 'adam';\r\n           scope.$digest();\r\n           expect(scope.counter).toEqual(1);\r\n       * </pre>\r\n       *\r\n       *\r\n       *\r\n       * @param {(function()|string)} watchExpression Expression that is evaluated on each\r\n       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a\r\n       *    call to the `listener`.\r\n       *\r\n       *    - `string`: Evaluated as {@link guide/expression expression}\r\n       *    - `function(scope)`: called with current `scope` as a parameter.\r\n       * @param {(function()|string)=} listener Callback called whenever the return value of\r\n       *   the `watchExpression` changes.\r\n       *\r\n       *    - `string`: Evaluated as {@link guide/expression expression}\r\n       *    - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.\r\n       *\r\n       * @param {boolean=} objectEquality Compare object for equality rather than for reference.\r\n       * @returns {function()} Returns a deregistration function for this listener.\r\n       */\r\n      $watch: function(watchExp, listener, objectEquality) {\r\n        var scope = this,\r\n            get = compileToFn(watchExp, 'watch'),\r\n            array = scope.$$watchers,\r\n            watcher = {\r\n              fn: listener,\r\n              last: initWatchVal,\r\n              get: get,\r\n              exp: watchExp,\r\n              eq: !!objectEquality\r\n            };\r\n\r\n        // in the case user pass string, we need to compile it, do we really need this ?\r\n        if (!isFunction(listener)) {\r\n          var listenFn = compileToFn(listener || noop, 'listener');\r\n          watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};\r\n        }\r\n\r\n        if (typeof watchExp == 'string' && get.constant) {\r\n          var originalFn = watcher.fn;\r\n          watcher.fn = function(newVal, oldVal, scope) {\r\n            originalFn.call(this, newVal, oldVal, scope);\r\n            arrayRemove(array, watcher);\r\n          };\r\n        }\r\n\r\n        if (!array) {\r\n          array = scope.$$watchers = [];\r\n        }\r\n        // we use unshift since we use a while loop in $digest for speed.\r\n        // the while loop reads in reverse order.\r\n        array.unshift(watcher);\r\n\r\n        return function() {\r\n          arrayRemove(array, watcher);\r\n        };\r\n      },\r\n\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$watchCollection\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Shallow watches the properties of an object and fires whenever any of the properties change\r\n       * (for arrays this implies watching the array items, for object maps this implies watching the properties).\r\n       * If a change is detected the `listener` callback is fired.\r\n       *\r\n       * - The `obj` collection is observed via standard $watch operation and is examined on every call to $digest() to\r\n       *   see if any items have been added, removed, or moved.\r\n       * - The `listener` is called whenever anything within the `obj` has changed. Examples include adding new items\r\n       *   into the object or array, removing and moving items around.\r\n       *\r\n       *\r\n       * # Example\r\n       * <pre>\r\n          $scope.names = ['igor', 'matias', 'misko', 'james'];\r\n          $scope.dataCount = 4;\r\n\r\n          $scope.$watchCollection('names', function(newNames, oldNames) {\r\n            $scope.dataCount = newNames.length;\r\n          });\r\n\r\n          expect($scope.dataCount).toEqual(4);\r\n          $scope.$digest();\r\n\r\n          //still at 4 ... no changes\r\n          expect($scope.dataCount).toEqual(4);\r\n\r\n          $scope.names.pop();\r\n          $scope.$digest();\r\n\r\n          //now there's been a change\r\n          expect($scope.dataCount).toEqual(3);\r\n       * </pre>\r\n       *\r\n       *\r\n       * @param {string|Function(scope)} obj Evaluated as {@link guide/expression expression}. The expression value\r\n       *    should evaluate to an object or an array which is observed on each\r\n       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the collection will trigger\r\n       *    a call to the `listener`.\r\n       *\r\n       * @param {function(newCollection, oldCollection, scope)} listener a callback function that is fired with both\r\n       *    the `newCollection` and `oldCollection` as parameters.\r\n       *    The `newCollection` object is the newly modified data obtained from the `obj` expression and the\r\n       *    `oldCollection` object is a copy of the former collection data.\r\n       *    The `scope` refers to the current scope.\r\n       *\r\n       * @returns {function()} Returns a de-registration function for this listener. When the de-registration function is executed\r\n       * then the internal watch operation is terminated.\r\n       */\r\n      $watchCollection: function(obj, listener) {\r\n        var self = this;\r\n        var oldValue;\r\n        var newValue;\r\n        var changeDetected = 0;\r\n        var objGetter = $parse(obj);\r\n        var internalArray = [];\r\n        var internalObject = {};\r\n        var oldLength = 0;\r\n\r\n        function $watchCollectionWatch() {\r\n          newValue = objGetter(self);\r\n          var newLength, key;\r\n\r\n          if (!isObject(newValue)) {\r\n            if (oldValue !== newValue) {\r\n              oldValue = newValue;\r\n              changeDetected++;\r\n            }\r\n          } else if (isArrayLike(newValue)) {\r\n            if (oldValue !== internalArray) {\r\n              // we are transitioning from something which was not an array into array.\r\n              oldValue = internalArray;\r\n              oldLength = oldValue.length = 0;\r\n              changeDetected++;\r\n            }\r\n\r\n            newLength = newValue.length;\r\n\r\n            if (oldLength !== newLength) {\r\n              // if lengths do not match we need to trigger change notification\r\n              changeDetected++;\r\n              oldValue.length = oldLength = newLength;\r\n            }\r\n            // copy the items to oldValue and look for changes.\r\n            for (var i = 0; i < newLength; i++) {\r\n              if (oldValue[i] !== newValue[i]) {\r\n                changeDetected++;\r\n                oldValue[i] = newValue[i];\r\n              }\r\n            }\r\n          } else {\r\n            if (oldValue !== internalObject) {\r\n              // we are transitioning from something which was not an object into object.\r\n              oldValue = internalObject = {};\r\n              oldLength = 0;\r\n              changeDetected++;\r\n            }\r\n            // copy the items to oldValue and look for changes.\r\n            newLength = 0;\r\n            for (key in newValue) {\r\n              if (newValue.hasOwnProperty(key)) {\r\n                newLength++;\r\n                if (oldValue.hasOwnProperty(key)) {\r\n                  if (oldValue[key] !== newValue[key]) {\r\n                    changeDetected++;\r\n                    oldValue[key] = newValue[key];\r\n                  }\r\n                } else {\r\n                  oldLength++;\r\n                  oldValue[key] = newValue[key];\r\n                  changeDetected++;\r\n                }\r\n              }\r\n            }\r\n            if (oldLength > newLength) {\r\n              // we used to have more keys, need to find them and destroy them.\r\n              changeDetected++;\r\n              for(key in oldValue) {\r\n                if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {\r\n                  oldLength--;\r\n                  delete oldValue[key];\r\n                }\r\n              }\r\n            }\r\n          }\r\n          return changeDetected;\r\n        }\r\n\r\n        function $watchCollectionAction() {\r\n          listener(newValue, oldValue, self);\r\n        }\r\n\r\n        return this.$watch($watchCollectionWatch, $watchCollectionAction);\r\n      },\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$digest\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and its children.\r\n       * Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the\r\n       * `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} until no more listeners are\r\n       * firing. This means that it is possible to get into an infinite loop. This function will throw\r\n       * `'Maximum iteration limit exceeded.'` if the number of iterations exceeds 10.\r\n       *\r\n       * Usually you don't call `$digest()` directly in\r\n       * {@link ng.directive:ngController controllers} or in\r\n       * {@link ng.$compileProvider#directive directives}.\r\n       * Instead a call to {@link ng.$rootScope.Scope#$apply $apply()} (typically from within a\r\n       * {@link ng.$compileProvider#directive directives}) will force a `$digest()`.\r\n       *\r\n       * If you want to be notified whenever `$digest()` is called,\r\n       * you can register a `watchExpression` function  with {@link ng.$rootScope.Scope#$watch $watch()}\r\n       * with no `listener`.\r\n       *\r\n       * You may have a need to call `$digest()` from within unit-tests, to simulate the scope\r\n       * life-cycle.\r\n       *\r\n       * # Example\r\n       * <pre>\r\n           var scope = ...;\r\n           scope.name = 'misko';\r\n           scope.counter = 0;\r\n\r\n           expect(scope.counter).toEqual(0);\r\n           scope.$watch('name', function(newValue, oldValue) {\r\n             scope.counter = scope.counter + 1;\r\n           });\r\n           expect(scope.counter).toEqual(0);\r\n\r\n           scope.$digest();\r\n           // no variable change\r\n           expect(scope.counter).toEqual(0);\r\n\r\n           scope.name = 'adam';\r\n           scope.$digest();\r\n           expect(scope.counter).toEqual(1);\r\n       * </pre>\r\n       *\r\n       */\r\n      $digest: function() {\r\n        var watch, value, last,\r\n            watchers,\r\n            asyncQueue = this.$$asyncQueue,\r\n            length,\r\n            dirty, ttl = TTL,\r\n            next, current, target = this,\r\n            watchLog = [],\r\n            logIdx, logMsg;\r\n\r\n        beginPhase('$digest');\r\n\r\n        do { // \"while dirty\" loop\r\n          dirty = false;\r\n          current = target;\r\n\r\n          while(asyncQueue.length) {\r\n            try {\r\n              current.$eval(asyncQueue.shift());\r\n            } catch (e) {\r\n              $exceptionHandler(e);\r\n            }\r\n          }\r\n\r\n          do { // \"traverse the scopes\" loop\r\n            if ((watchers = current.$$watchers)) {\r\n              // process our watches\r\n              length = watchers.length;\r\n              while (length--) {\r\n                try {\r\n                  watch = watchers[length];\r\n                  // Most common watches are on primitives, in which case we can short\r\n                  // circuit it with === operator, only when === fails do we use .equals\r\n                  if ((value = watch.get(current)) !== (last = watch.last) &&\r\n                      !(watch.eq\r\n                          ? equals(value, last)\r\n                          : (typeof value == 'number' && typeof last == 'number'\r\n                             && isNaN(value) && isNaN(last)))) {\r\n                    dirty = true;\r\n                    watch.last = watch.eq ? copy(value) : value;\r\n                    watch.fn(value, ((last === initWatchVal) ? value : last), current);\r\n                    if (ttl < 5) {\r\n                      logIdx = 4 - ttl;\r\n                      if (!watchLog[logIdx]) watchLog[logIdx] = [];\r\n                      logMsg = (isFunction(watch.exp))\r\n                          ? 'fn: ' + (watch.exp.name || watch.exp.toString())\r\n                          : watch.exp;\r\n                      logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);\r\n                      watchLog[logIdx].push(logMsg);\r\n                    }\r\n                  }\r\n                } catch (e) {\r\n                  $exceptionHandler(e);\r\n                }\r\n              }\r\n            }\r\n\r\n            // Insanity Warning: scope depth-first traversal\r\n            // yes, this code is a bit crazy, but it works and we have tests to prove it!\r\n            // this piece should be kept in sync with the traversal in $broadcast\r\n            if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {\r\n              while(current !== target && !(next = current.$$nextSibling)) {\r\n                current = current.$parent;\r\n              }\r\n            }\r\n          } while ((current = next));\r\n\r\n          if(dirty && !(ttl--)) {\r\n            clearPhase();\r\n            throw Error(TTL + ' $digest() iterations reached. Aborting!\\n' +\r\n                'Watchers fired in the last 5 iterations: ' + toJson(watchLog));\r\n          }\r\n        } while (dirty || asyncQueue.length);\r\n\r\n        clearPhase();\r\n      },\r\n\r\n\r\n      /**\r\n       * @ngdoc event\r\n       * @name ng.$rootScope.Scope#$destroy\r\n       * @eventOf ng.$rootScope.Scope\r\n       * @eventType broadcast on scope being destroyed\r\n       *\r\n       * @description\r\n       * Broadcasted when a scope and its children are being destroyed.\r\n       */\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$destroy\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Removes the current scope (and all of its children) from the parent scope. Removal implies\r\n       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer\r\n       * propagate to the current scope and its children. Removal also implies that the current\r\n       * scope is eligible for garbage collection.\r\n       *\r\n       * The `$destroy()` is usually used by directives such as\r\n       * {@link ng.directive:ngRepeat ngRepeat} for managing the\r\n       * unrolling of the loop.\r\n       *\r\n       * Just before a scope is destroyed a `$destroy` event is broadcasted on this scope.\r\n       * Application code can register a `$destroy` event handler that will give it chance to\r\n       * perform any necessary cleanup.\r\n       */\r\n      $destroy: function() {\r\n        // we can't destroy the root scope or a scope that has been already destroyed\r\n        if ($rootScope == this || this.$$destroyed) return;\r\n        var parent = this.$parent;\r\n\r\n        this.$broadcast('$destroy');\r\n        this.$$destroyed = true;\r\n\r\n        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;\r\n        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;\r\n        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;\r\n        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;\r\n\r\n        // This is bogus code that works around Chrome's GC leak\r\n        // see: https://github.com/angular/angular.js/issues/1313#issuecomment-10378451\r\n        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =\r\n            this.$$childTail = null;\r\n      },\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$eval\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Executes the `expression` on the current scope returning the result. Any exceptions in the\r\n       * expression are propagated (uncaught). This is useful when evaluating Angular expressions.\r\n       *\r\n       * # Example\r\n       * <pre>\r\n           var scope = ng.$rootScope.Scope();\r\n           scope.a = 1;\r\n           scope.b = 2;\r\n\r\n           expect(scope.$eval('a+b')).toEqual(3);\r\n           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);\r\n       * </pre>\r\n       *\r\n       * @param {(string|function())=} expression An angular expression to be executed.\r\n       *\r\n       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.\r\n       *    - `function(scope)`: execute the function with the current `scope` parameter.\r\n       *\r\n       * @returns {*} The result of evaluating the expression.\r\n       */\r\n      $eval: function(expr, locals) {\r\n        return $parse(expr)(this, locals);\r\n      },\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$evalAsync\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Executes the expression on the current scope at a later point in time.\r\n       *\r\n       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:\r\n       *\r\n       *   - it will execute in the current script execution context (before any DOM rendering).\r\n       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after\r\n       *     `expression` execution.\r\n       *\r\n       * Any exceptions from the execution of the expression are forwarded to the\r\n       * {@link ng.$exceptionHandler $exceptionHandler} service.\r\n       *\r\n       * @param {(string|function())=} expression An angular expression to be executed.\r\n       *\r\n       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.\r\n       *    - `function(scope)`: execute the function with the current `scope` parameter.\r\n       *\r\n       */\r\n      $evalAsync: function(expr) {\r\n        this.$$asyncQueue.push(expr);\r\n      },\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$apply\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * `$apply()` is used to execute an expression in angular from outside of the angular framework.\r\n       * (For example from browser DOM events, setTimeout, XHR or third party libraries).\r\n       * Because we are calling into the angular framework we need to perform proper scope life-cycle\r\n       * of {@link ng.$exceptionHandler exception handling},\r\n       * {@link ng.$rootScope.Scope#$digest executing watches}.\r\n       *\r\n       * ## Life cycle\r\n       *\r\n       * # Pseudo-Code of `$apply()`\r\n       * <pre>\r\n           function $apply(expr) {\r\n             try {\r\n               return $eval(expr);\r\n             } catch (e) {\r\n               $exceptionHandler(e);\r\n             } finally {\r\n               $root.$digest();\r\n             }\r\n           }\r\n       * </pre>\r\n       *\r\n       *\r\n       * Scope's `$apply()` method transitions through the following stages:\r\n       *\r\n       * 1. The {@link guide/expression expression} is executed using the\r\n       *    {@link ng.$rootScope.Scope#$eval $eval()} method.\r\n       * 2. Any exceptions from the execution of the expression are forwarded to the\r\n       *    {@link ng.$exceptionHandler $exceptionHandler} service.\r\n       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression\r\n       *    was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.\r\n       *\r\n       *\r\n       * @param {(string|function())=} exp An angular expression to be executed.\r\n       *\r\n       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.\r\n       *    - `function(scope)`: execute the function with current `scope` parameter.\r\n       *\r\n       * @returns {*} The result of evaluating the expression.\r\n       */\r\n      $apply: function(expr) {\r\n        try {\r\n          beginPhase('$apply');\r\n          return this.$eval(expr);\r\n        } catch (e) {\r\n          $exceptionHandler(e);\r\n        } finally {\r\n          clearPhase();\r\n          try {\r\n            $rootScope.$digest();\r\n          } catch (e) {\r\n            $exceptionHandler(e);\r\n            throw e;\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$on\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for discussion of\r\n       * event life cycle.\r\n       *\r\n       * The event listener function format is: `function(event, args...)`. The `event` object\r\n       * passed into the listener has the following attributes:\r\n       *\r\n       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or `$broadcast`-ed.\r\n       *   - `currentScope` - `{Scope}`: the current scope which is handling the event.\r\n       *   - `name` - `{string}`: Name of the event.\r\n       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel further event\r\n       *     propagation (available only for events that were `$emit`-ed).\r\n       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag to true.\r\n       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.\r\n       *\r\n       * @param {string} name Event name to listen on.\r\n       * @param {function(event, args...)} listener Function to call when the event is emitted.\r\n       * @returns {function()} Returns a deregistration function for this listener.\r\n       */\r\n      $on: function(name, listener) {\r\n        var namedListeners = this.$$listeners[name];\r\n        if (!namedListeners) {\r\n          this.$$listeners[name] = namedListeners = [];\r\n        }\r\n        namedListeners.push(listener);\r\n\r\n        return function() {\r\n          namedListeners[indexOf(namedListeners, listener)] = null;\r\n        };\r\n      },\r\n\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$emit\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Dispatches an event `name` upwards through the scope hierarchy notifying the\r\n       * registered {@link ng.$rootScope.Scope#$on} listeners.\r\n       *\r\n       * The event life cycle starts at the scope on which `$emit` was called. All\r\n       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.\r\n       * Afterwards, the event traverses upwards toward the root scope and calls all registered\r\n       * listeners along the way. The event will stop propagating if one of the listeners cancels it.\r\n       *\r\n       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed\r\n       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.\r\n       *\r\n       * @param {string} name Event name to emit.\r\n       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.\r\n       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}\r\n       */\r\n      $emit: function(name, args) {\r\n        var empty = [],\r\n            namedListeners,\r\n            scope = this,\r\n            stopPropagation = false,\r\n            event = {\r\n              name: name,\r\n              targetScope: scope,\r\n              stopPropagation: function() {stopPropagation = true;},\r\n              preventDefault: function() {\r\n                event.defaultPrevented = true;\r\n              },\r\n              defaultPrevented: false\r\n            },\r\n            listenerArgs = concat([event], arguments, 1),\r\n            i, length;\r\n\r\n        do {\r\n          namedListeners = scope.$$listeners[name] || empty;\r\n          event.currentScope = scope;\r\n          for (i=0, length=namedListeners.length; i<length; i++) {\r\n\r\n            // if listeners were deregistered, defragment the array\r\n            if (!namedListeners[i]) {\r\n              namedListeners.splice(i, 1);\r\n              i--;\r\n              length--;\r\n              continue;\r\n            }\r\n            try {\r\n              namedListeners[i].apply(null, listenerArgs);\r\n              if (stopPropagation) return event;\r\n            } catch (e) {\r\n              $exceptionHandler(e);\r\n            }\r\n          }\r\n          //traverse upwards\r\n          scope = scope.$parent;\r\n        } while (scope);\r\n\r\n        return event;\r\n      },\r\n\r\n\r\n      /**\r\n       * @ngdoc function\r\n       * @name ng.$rootScope.Scope#$broadcast\r\n       * @methodOf ng.$rootScope.Scope\r\n       * @function\r\n       *\r\n       * @description\r\n       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the\r\n       * registered {@link ng.$rootScope.Scope#$on} listeners.\r\n       *\r\n       * The event life cycle starts at the scope on which `$broadcast` was called. All\r\n       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.\r\n       * Afterwards, the event propagates to all direct and indirect scopes of the current scope and\r\n       * calls all registered listeners along the way. The event cannot be canceled.\r\n       *\r\n       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed\r\n       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.\r\n       *\r\n       * @param {string} name Event name to broadcast.\r\n       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.\r\n       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}\r\n       */\r\n      $broadcast: function(name, args) {\r\n        var target = this,\r\n            current = target,\r\n            next = target,\r\n            event = {\r\n              name: name,\r\n              targetScope: target,\r\n              preventDefault: function() {\r\n                event.defaultPrevented = true;\r\n              },\r\n              defaultPrevented: false\r\n            },\r\n            listenerArgs = concat([event], arguments, 1),\r\n            listeners, i, length;\r\n\r\n        //down while you can, then up and next sibling or up and next sibling until back at root\r\n        do {\r\n          current = next;\r\n          event.currentScope = current;\r\n          listeners = current.$$listeners[name] || [];\r\n          for (i=0, length = listeners.length; i<length; i++) {\r\n            // if listeners were deregistered, defragment the array\r\n            if (!listeners[i]) {\r\n              listeners.splice(i, 1);\r\n              i--;\r\n              length--;\r\n              continue;\r\n            }\r\n\r\n            try {\r\n              listeners[i].apply(null, listenerArgs);\r\n            } catch(e) {\r\n              $exceptionHandler(e);\r\n            }\r\n          }\r\n\r\n          // Insanity Warning: scope depth-first traversal\r\n          // yes, this code is a bit crazy, but it works and we have tests to prove it!\r\n          // this piece should be kept in sync with the traversal in $digest\r\n          if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {\r\n            while(current !== target && !(next = current.$$nextSibling)) {\r\n              current = current.$parent;\r\n            }\r\n          }\r\n        } while ((current = next));\r\n\r\n        return event;\r\n      }\r\n    };\r\n\r\n    var $rootScope = new Scope();\r\n\r\n    return $rootScope;\r\n\r\n\r\n    function beginPhase(phase) {\r\n      if ($rootScope.$$phase) {\r\n        throw Error($rootScope.$$phase + ' already in progress');\r\n      }\r\n\r\n      $rootScope.$$phase = phase;\r\n    }\r\n\r\n    function clearPhase() {\r\n      $rootScope.$$phase = null;\r\n    }\r\n\r\n    function compileToFn(exp, name) {\r\n      var fn = $parse(exp);\r\n      assertArgFn(fn, name);\r\n      return fn;\r\n    }\r\n\r\n    /**\r\n     * function used as an initial value for watchers.\r\n     * because it's unique we can easily tell it apart from other values\r\n     */\r\n    function initWatchVal() {}\r\n  }];\r\n}\r\n\r\n/**\r\n * !!! This is an undocumented \"private\" service !!!\r\n *\r\n * @name ng.$sniffer\r\n * @requires $window\r\n * @requires $document\r\n *\r\n * @property {boolean} history Does the browser support html5 history api ?\r\n * @property {boolean} hashchange Does the browser support hashchange event ?\r\n * @property {boolean} transitions Does the browser support CSS transition events ?\r\n * @property {boolean} animations Does the browser support CSS animation events ?\r\n *\r\n * @description\r\n * This is very simple implementation of testing browser's features.\r\n */\r\nfunction $SnifferProvider() {\r\n  this.$get = ['$window', '$document', function($window, $document) {\r\n    var eventSupport = {},\r\n        android = int((/android (\\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),\r\n        document = $document[0] || {},\r\n        vendorPrefix,\r\n        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,\r\n        bodyStyle = document.body && document.body.style,\r\n        transitions = false,\r\n        animations = false,\r\n        match;\r\n\r\n    if (bodyStyle) {\r\n      for(var prop in bodyStyle) {\r\n        if(match = vendorRegex.exec(prop)) {\r\n          vendorPrefix = match[0];\r\n          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);\r\n          break;\r\n        }\r\n      }\r\n      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));\r\n      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));\r\n    }\r\n\r\n\r\n    return {\r\n      // Android has history.pushState, but it does not update location correctly\r\n      // so let's not use the history API at all.\r\n      // http://code.google.com/p/android/issues/detail?id=17471\r\n      // https://github.com/angular/angular.js/issues/904\r\n      history: !!($window.history && $window.history.pushState && !(android < 4)),\r\n      hashchange: 'onhashchange' in $window &&\r\n                  // IE8 compatible mode lies\r\n                  (!document.documentMode || document.documentMode > 7),\r\n      hasEvent: function(event) {\r\n        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have\r\n        // it. In particular the event is not fired when backspace or delete key are pressed or\r\n        // when cut operation is performed.\r\n        if (event == 'input' && msie == 9) return false;\r\n\r\n        if (isUndefined(eventSupport[event])) {\r\n          var divElm = document.createElement('div');\r\n          eventSupport[event] = 'on' + event in divElm;\r\n        }\r\n\r\n        return eventSupport[event];\r\n      },\r\n      csp: document.securityPolicy ? document.securityPolicy.isActive : false,\r\n      vendorPrefix: vendorPrefix,\r\n      transitions : transitions,\r\n      animations : animations\r\n    };\r\n  }];\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$window\r\n *\r\n * @description\r\n * A reference to the browser's `window` object. While `window`\r\n * is globally available in JavaScript, it causes testability problems, because\r\n * it is a global variable. In angular we always refer to it through the\r\n * `$window` service, so it may be overridden, removed or mocked for testing.\r\n *\r\n * All expressions are evaluated with respect to current scope so they don't\r\n * suffer from window globality.\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n       <script>\r\n         function Ctrl($scope, $window) {\r\n           $scope.$window = $window;\r\n           $scope.greeting = 'Hello, World!';\r\n         }\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n         <input type=\"text\" ng-model=\"greeting\" />\r\n         <button ng-click=\"$window.alert(greeting)\">ALERT</button>\r\n       </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n      it('should display the greeting in the input box', function() {\r\n       input('greeting').enter('Hello, E2E Tests');\r\n       // If we click the button it will block the test runner\r\n       // element(':button').click();\r\n      });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\nfunction $WindowProvider(){\r\n  this.$get = valueFn(window);\r\n}\r\n\r\n/**\r\n * Parse headers into key value object\r\n *\r\n * @param {string} headers Raw headers as a string\r\n * @returns {Object} Parsed headers as key value object\r\n */\r\nfunction parseHeaders(headers) {\r\n  var parsed = {}, key, val, i;\r\n\r\n  if (!headers) return parsed;\r\n\r\n  forEach(headers.split('\\n'), function(line) {\r\n    i = line.indexOf(':');\r\n    key = lowercase(trim(line.substr(0, i)));\r\n    val = trim(line.substr(i + 1));\r\n\r\n    if (key) {\r\n      if (parsed[key]) {\r\n        parsed[key] += ', ' + val;\r\n      } else {\r\n        parsed[key] = val;\r\n      }\r\n    }\r\n  });\r\n\r\n  return parsed;\r\n}\r\n\r\n\r\nvar IS_SAME_DOMAIN_URL_MATCH = /^(([^:]+):)?\\/\\/(\\w+:{0,1}\\w*@)?([\\w\\.-]*)?(:([0-9]+))?(.*)$/;\r\n\r\n\r\n/**\r\n * Parse a request and location URL and determine whether this is a same-domain request.\r\n *\r\n * @param {string} requestUrl The url of the request.\r\n * @param {string} locationUrl The current browser location url.\r\n * @returns {boolean} Whether the request is for the same domain.\r\n */\r\nfunction isSameDomain(requestUrl, locationUrl) {\r\n  var match = IS_SAME_DOMAIN_URL_MATCH.exec(requestUrl);\r\n  // if requestUrl is relative, the regex does not match.\r\n  if (match == null) return true;\r\n\r\n  var domain1 = {\r\n      protocol: match[2],\r\n      host: match[4],\r\n      port: int(match[6]) || DEFAULT_PORTS[match[2]] || null,\r\n      // IE8 sets unmatched groups to '' instead of undefined.\r\n      relativeProtocol: match[2] === undefined || match[2] === ''\r\n    };\r\n\r\n  match = SERVER_MATCH.exec(locationUrl);\r\n  var domain2 = {\r\n      protocol: match[1],\r\n      host: match[3],\r\n      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null\r\n    };\r\n\r\n  return (domain1.protocol == domain2.protocol || domain1.relativeProtocol) &&\r\n         domain1.host == domain2.host &&\r\n         (domain1.port == domain2.port || (domain1.relativeProtocol &&\r\n             domain2.port == DEFAULT_PORTS[domain2.protocol]));\r\n}\r\n\r\n\r\n/**\r\n * Returns a function that provides access to parsed headers.\r\n *\r\n * Headers are lazy parsed when first requested.\r\n * @see parseHeaders\r\n *\r\n * @param {(string|Object)} headers Headers to provide access to.\r\n * @returns {function(string=)} Returns a getter function which if called with:\r\n *\r\n *   - if called with single an argument returns a single header value or null\r\n *   - if called with no arguments returns an object containing all headers.\r\n */\r\nfunction headersGetter(headers) {\r\n  var headersObj = isObject(headers) ? headers : undefined;\r\n\r\n  return function(name) {\r\n    if (!headersObj) headersObj =  parseHeaders(headers);\r\n\r\n    if (name) {\r\n      return headersObj[lowercase(name)] || null;\r\n    }\r\n\r\n    return headersObj;\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Chain all given functions\r\n *\r\n * This function is used for both request and response transforming\r\n *\r\n * @param {*} data Data to transform.\r\n * @param {function(string=)} headers Http headers getter fn.\r\n * @param {(function|Array.<function>)} fns Function or an array of functions.\r\n * @returns {*} Transformed data.\r\n */\r\nfunction transformData(data, headers, fns) {\r\n  if (isFunction(fns))\r\n    return fns(data, headers);\r\n\r\n  forEach(fns, function(fn) {\r\n    data = fn(data, headers);\r\n  });\r\n\r\n  return data;\r\n}\r\n\r\n\r\nfunction isSuccess(status) {\r\n  return 200 <= status && status < 300;\r\n}\r\n\r\n\r\nfunction $HttpProvider() {\r\n  var JSON_START = /^\\s*(\\[|\\{[^\\{])/,\r\n      JSON_END = /[\\}\\]]\\s*$/,\r\n      PROTECTION_PREFIX = /^\\)\\]\\}',?\\n/,\r\n      CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': 'application/json;charset=utf-8'};\r\n\r\n  var defaults = this.defaults = {\r\n    // transform incoming response data\r\n    transformResponse: [function(data) {\r\n      if (isString(data)) {\r\n        // strip json vulnerability protection prefix\r\n        data = data.replace(PROTECTION_PREFIX, '');\r\n        if (JSON_START.test(data) && JSON_END.test(data))\r\n          data = fromJson(data, true);\r\n      }\r\n      return data;\r\n    }],\r\n\r\n    // transform outgoing request data\r\n    transformRequest: [function(d) {\r\n      return isObject(d) && !isFile(d) ? toJson(d) : d;\r\n    }],\r\n\r\n    // default headers\r\n    headers: {\r\n      common: {\r\n        'Accept': 'application/json, text/plain, */*'\r\n      },\r\n      post:   CONTENT_TYPE_APPLICATION_JSON,\r\n      put:    CONTENT_TYPE_APPLICATION_JSON,\r\n      patch:  CONTENT_TYPE_APPLICATION_JSON\r\n    },\r\n\r\n    xsrfCookieName: 'XSRF-TOKEN',\r\n    xsrfHeaderName: 'X-XSRF-TOKEN'\r\n  };\r\n\r\n  /**\r\n   * Are order by request. I.E. they are applied in the same order as\r\n   * array on request, but revers order on response.\r\n   */\r\n  var interceptorFactories = this.interceptors = [];\r\n  /**\r\n   * For historical reasons, response interceptors ordered by the order in which\r\n   * they are applied to response. (This is in revers to interceptorFactories)\r\n   */\r\n  var responseInterceptorFactories = this.responseInterceptors = [];\r\n\r\n  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',\r\n      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {\r\n\r\n    var defaultCache = $cacheFactory('$http');\r\n\r\n    /**\r\n     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.\r\n     * The reversal is needed so that we can build up the interception chain around the\r\n     * server request.\r\n     */\r\n    var reversedInterceptors = [];\r\n\r\n    forEach(interceptorFactories, function(interceptorFactory) {\r\n      reversedInterceptors.unshift(isString(interceptorFactory)\r\n          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));\r\n    });\r\n\r\n    forEach(responseInterceptorFactories, function(interceptorFactory, index) {\r\n      var responseFn = isString(interceptorFactory)\r\n          ? $injector.get(interceptorFactory)\r\n          : $injector.invoke(interceptorFactory);\r\n\r\n      /**\r\n       * Response interceptors go before \"around\" interceptors (no real reason, just\r\n       * had to pick one.) But they are already revesed, so we can't use unshift, hence\r\n       * the splice.\r\n       */\r\n      reversedInterceptors.splice(index, 0, {\r\n        response: function(response) {\r\n          return responseFn($q.when(response));\r\n        },\r\n        responseError: function(response) {\r\n          return responseFn($q.reject(response));\r\n        }\r\n      });\r\n    });\r\n\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ng.$http\r\n     * @requires $httpBackend\r\n     * @requires $browser\r\n     * @requires $cacheFactory\r\n     * @requires $rootScope\r\n     * @requires $q\r\n     * @requires $injector\r\n     *\r\n     * @description\r\n     * The `$http` service is a core Angular service that facilitates communication with the remote\r\n     * HTTP servers via the browser's {@link https://developer.mozilla.org/en/xmlhttprequest\r\n     * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.\r\n     *\r\n     * For unit testing applications that use `$http` service, see\r\n     * {@link ngMock.$httpBackend $httpBackend mock}.\r\n     *\r\n     * For a higher level of abstraction, please check out the {@link ngResource.$resource\r\n     * $resource} service.\r\n     *\r\n     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by\r\n     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage\r\n     * it is important to familiarize yourself with these APIs and the guarantees they provide.\r\n     *\r\n     *\r\n     * # General usage\r\n     * The `$http` service is a function which takes a single argument  a configuration object \r\n     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}\r\n     * with two $http specific methods: `success` and `error`.\r\n     *\r\n     * <pre>\r\n     *   $http({method: 'GET', url: '/someUrl'}).\r\n     *     success(function(data, status, headers, config) {\r\n     *       // this callback will be called asynchronously\r\n     *       // when the response is available\r\n     *     }).\r\n     *     error(function(data, status, headers, config) {\r\n     *       // called asynchronously if an error occurs\r\n     *       // or server returns response with an error status.\r\n     *     });\r\n     * </pre>\r\n     *\r\n     * Since the returned value of calling the $http function is a `promise`, you can also use\r\n     * the `then` method to register callbacks, and these callbacks will receive a single argument \r\n     * an object representing the response. See the API signature and type info below for more\r\n     * details.\r\n     *\r\n     * A response status code between 200 and 299 is considered a success status and\r\n     * will result in the success callback being called. Note that if the response is a redirect,\r\n     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be\r\n     * called for such responses.\r\n     *\r\n     * # Shortcut methods\r\n     *\r\n     * Since all invocations of the $http service require passing in an HTTP method and URL, and\r\n     * POST/PUT requests require request data to be provided as well, shortcut methods\r\n     * were created:\r\n     *\r\n     * <pre>\r\n     *   $http.get('/someUrl').success(successCallback);\r\n     *   $http.post('/someUrl', data).success(successCallback);\r\n     * </pre>\r\n     *\r\n     * Complete list of shortcut methods:\r\n     *\r\n     * - {@link ng.$http#get $http.get}\r\n     * - {@link ng.$http#head $http.head}\r\n     * - {@link ng.$http#post $http.post}\r\n     * - {@link ng.$http#put $http.put}\r\n     * - {@link ng.$http#delete $http.delete}\r\n     * - {@link ng.$http#jsonp $http.jsonp}\r\n     *\r\n     *\r\n     * # Setting HTTP Headers\r\n     *\r\n     * The $http service will automatically add certain HTTP headers to all requests. These defaults\r\n     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration\r\n     * object, which currently contains this default configuration:\r\n     *\r\n     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):\r\n     *   - `Accept: application/json, text/plain, * / *`\r\n     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)\r\n     *   - `Content-Type: application/json`\r\n     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)\r\n     *   - `Content-Type: application/json`\r\n     *\r\n     * To add or overwrite these defaults, simply add or remove a property from these configuration\r\n     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object\r\n     * with the lowercased HTTP method name as the key, e.g.\r\n     * `$httpProvider.defaults.headers.get['My-Header']='value'`.\r\n     *\r\n     * Additionally, the defaults can be set at runtime via the `$http.defaults` object in the same\r\n     * fashion.\r\n     *\r\n     *\r\n     * # Transforming Requests and Responses\r\n     *\r\n     * Both requests and responses can be transformed using transform functions. By default, Angular\r\n     * applies these transformations:\r\n     *\r\n     * Request transformations:\r\n     *\r\n     * - If the `data` property of the request configuration object contains an object, serialize it into\r\n     *   JSON format.\r\n     *\r\n     * Response transformations:\r\n     *\r\n     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).\r\n     *  - If JSON response is detected, deserialize it using a JSON parser.\r\n     *\r\n     * To globally augment or override the default transforms, modify the `$httpProvider.defaults.transformRequest` and\r\n     * `$httpProvider.defaults.transformResponse` properties. These properties are by default an\r\n     * array of transform functions, which allows you to `push` or `unshift` a new transformation function into the\r\n     * transformation chain. You can also decide to completely override any default transformations by assigning your\r\n     * transformation functions to these properties directly without the array wrapper.\r\n     *\r\n     * Similarly, to locally override the request/response transforms, augment the `transformRequest` and/or\r\n     * `transformResponse` properties of the configuration object passed into `$http`.\r\n     *\r\n     *\r\n     * # Caching\r\n     *\r\n     * To enable caching, set the configuration property `cache` to `true`. When the cache is\r\n     * enabled, `$http` stores the response from the server in local cache. Next time the\r\n     * response is served from the cache without sending a request to the server.\r\n     *\r\n     * Note that even if the response is served from cache, delivery of the data is asynchronous in\r\n     * the same way that real requests are.\r\n     *\r\n     * If there are multiple GET requests for the same URL that should be cached using the same\r\n     * cache, but the cache is not populated yet, only one request to the server will be made and\r\n     * the remaining requests will be fulfilled using the response from the first request.\r\n     *\r\n     * A custom default cache built with $cacheFactory can be provided in $http.defaults.cache.\r\n     * To skip it, set configuration property `cache` to `false`.\r\n     *\r\n     *\r\n     * # Interceptors\r\n     *\r\n     * Before you start creating interceptors, be sure to understand the\r\n     * {@link ng.$q $q and deferred/promise APIs}.\r\n     *\r\n     * For purposes of global error handling, authentication, or any kind of synchronous or\r\n     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be\r\n     * able to intercept requests before they are handed to the server and\r\n     * responses before they are handed over to the application code that\r\n     * initiated these requests. The interceptors leverage the {@link ng.$q\r\n     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.\r\n     *\r\n     * The interceptors are service factories that are registered with the `$httpProvider` by\r\n     * adding them to the `$httpProvider.interceptors` array. The factory is called and\r\n     * injected with dependencies (if specified) and returns the interceptor.\r\n     *\r\n     * There are two kinds of interceptors (and two kinds of rejection interceptors):\r\n     *\r\n     *   * `request`: interceptors get called with http `config` object. The function is free to modify\r\n     *     the `config` or create a new one. The function needs to return the `config` directly or as a\r\n     *     promise.\r\n     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or resolved\r\n     *      with a rejection.\r\n     *   * `response`: interceptors get called with http `response` object. The function is free to modify\r\n     *     the `response` or create a new one. The function needs to return the `response` directly or as a\r\n     *     promise.\r\n     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or resolved\r\n     *      with a rejection.\r\n     *\r\n     *\r\n     * <pre>\r\n     *   // register the interceptor as a service\r\n     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {\r\n     *     return {\r\n     *       // optional method\r\n     *       'request': function(config) {\r\n     *         // do something on success\r\n     *         return config || $q.when(config);\r\n     *       },\r\n     *\r\n     *       // optional method\r\n     *      'requestError': function(rejection) {\r\n     *         // do something on error\r\n     *         if (canRecover(rejection)) {\r\n     *           return responseOrNewPromise\r\n     *         }\r\n     *         return $q.reject(rejection);\r\n     *       },\r\n     *\r\n     *\r\n     *\r\n     *       // optional method\r\n     *       'response': function(response) {\r\n     *         // do something on success\r\n     *         return response || $q.when(response);\r\n     *       },\r\n     *\r\n     *       // optional method\r\n     *      'responseError': function(rejection) {\r\n     *         // do something on error\r\n     *         if (canRecover(rejection)) {\r\n     *           return responseOrNewPromise\r\n     *         }\r\n     *         return $q.reject(rejection);\r\n     *       };\r\n     *     }\r\n     *   });\r\n     *\r\n     *   $httpProvider.interceptors.push('myHttpInterceptor');\r\n     *\r\n     *\r\n     *   // register the interceptor via an anonymous factory\r\n     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {\r\n     *     return {\r\n     *      'request': function(config) {\r\n     *          // same as above\r\n     *       },\r\n     *       'response': function(response) {\r\n     *          // same as above\r\n     *       }\r\n     *   });\r\n     * </pre>\r\n     *\r\n     * # Response interceptors (DEPRECATED)\r\n     *\r\n     * Before you start creating interceptors, be sure to understand the\r\n     * {@link ng.$q $q and deferred/promise APIs}.\r\n     *\r\n     * For purposes of global error handling, authentication or any kind of synchronous or\r\n     * asynchronous preprocessing of received responses, it is desirable to be able to intercept\r\n     * responses for http requests before they are handed over to the application code that\r\n     * initiated these requests. The response interceptors leverage the {@link ng.$q\r\n     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.\r\n     *\r\n     * The interceptors are service factories that are registered with the $httpProvider by\r\n     * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and\r\n     * injected with dependencies (if specified) and returns the interceptor   a function that\r\n     * takes a {@link ng.$q promise} and returns the original or a new promise.\r\n     *\r\n     * <pre>\r\n     *   // register the interceptor as a service\r\n     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {\r\n     *     return function(promise) {\r\n     *       return promise.then(function(response) {\r\n     *         // do something on success\r\n     *       }, function(response) {\r\n     *         // do something on error\r\n     *         if (canRecover(response)) {\r\n     *           return responseOrNewPromise\r\n     *         }\r\n     *         return $q.reject(response);\r\n     *       });\r\n     *     }\r\n     *   });\r\n     *\r\n     *   $httpProvider.responseInterceptors.push('myHttpInterceptor');\r\n     *\r\n     *\r\n     *   // register the interceptor via an anonymous factory\r\n     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {\r\n     *     return function(promise) {\r\n     *       // same as above\r\n     *     }\r\n     *   });\r\n     * </pre>\r\n     *\r\n     *\r\n     * # Security Considerations\r\n     *\r\n     * When designing web applications, consider security threats from:\r\n     *\r\n     * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\r\n     *   JSON vulnerability}\r\n     * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}\r\n     *\r\n     * Both server and the client must cooperate in order to eliminate these threats. Angular comes\r\n     * pre-configured with strategies that address these issues, but for this to work backend server\r\n     * cooperation is required.\r\n     *\r\n     * ## JSON Vulnerability Protection\r\n     *\r\n     * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\r\n     * JSON vulnerability} allows third party website to turn your JSON resource URL into\r\n     * {@link http://en.wikipedia.org/wiki/JSONP JSONP} request under some conditions. To\r\n     * counter this your server can prefix all JSON requests with following string `\")]}',\\n\"`.\r\n     * Angular will automatically strip the prefix before processing it as JSON.\r\n     *\r\n     * For example if your server needs to return:\r\n     * <pre>\r\n     * ['one','two']\r\n     * </pre>\r\n     *\r\n     * which is vulnerable to attack, your server can return:\r\n     * <pre>\r\n     * )]}',\r\n     * ['one','two']\r\n     * </pre>\r\n     *\r\n     * Angular will strip the prefix, before processing the JSON.\r\n     *\r\n     *\r\n     * ## Cross Site Request Forgery (XSRF) Protection\r\n     *\r\n     * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which\r\n     * an unauthorized site can gain your user's private data. Angular provides a mechanism\r\n     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie\r\n     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only\r\n     * JavaScript that runs on your domain could read the cookie, your server can be assured that\r\n     * the XHR came from JavaScript running on your domain. The header will not be set for\r\n     * cross-domain requests.\r\n     *\r\n     * To take advantage of this, your server needs to set a token in a JavaScript readable session\r\n     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the\r\n     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure\r\n     * that only JavaScript running on your domain could have sent the request. The token must be\r\n     * unique for each user and must be verifiable by the server (to prevent the JavaScript from making\r\n     * up its own tokens). We recommend that the token is a digest of your site's authentication\r\n     * cookie with a {@link https://en.wikipedia.org/wiki/Salt_(cryptography) salt} for added security.\r\n     *\r\n     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName\r\n     * properties of either $httpProvider.defaults, or the per-request config object.\r\n     *\r\n     *\r\n     * @param {object} config Object describing the request to be made and how it should be\r\n     *    processed. The object has following properties:\r\n     *\r\n     *    - **method**  `{string}`  HTTP method (e.g. 'GET', 'POST', etc)\r\n     *    - **url**  `{string}`  Absolute or relative URL of the resource that is being requested.\r\n     *    - **params**  `{Object.<string|Object>}`  Map of strings or objects which will be turned to\r\n     *      `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified.\r\n     *    - **data**  `{string|Object}`  Data to be sent as the request message data.\r\n     *    - **headers**  `{Object}`  Map of strings representing HTTP headers to send to the server.\r\n     *    - **xsrfHeaderName**  `{string}`  Name of HTTP header to populate with the XSRF token.\r\n     *    - **xsrfCookieName**  `{string}`  Name of cookie containing the XSRF token.\r\n     *    - **transformRequest**  `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` \r\n     *      transform function or an array of such functions. The transform function takes the http\r\n     *      request body and headers and returns its transformed (typically serialized) version.\r\n     *    - **transformResponse**  `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` \r\n     *      transform function or an array of such functions. The transform function takes the http\r\n     *      response body and headers and returns its transformed (typically deserialized) version.\r\n     *    - **cache**  `{boolean|Cache}`  If true, a default $http cache will be used to cache the\r\n     *      GET request, otherwise if a cache instance built with\r\n     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\r\n     *      caching.\r\n     *    - **timeout**  `{number|Promise}`  timeout in milliseconds, or {@link ng.$q promise}\r\n     *      that should abort the request when resolved.\r\n     *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the\r\n     *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5\r\n     *      requests with credentials} for more information.\r\n     *    - **responseType** - `{string}` - see {@link\r\n     *      https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.\r\n     *\r\n     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the\r\n     *   standard `then` method and two http specific methods: `success` and `error`. The `then`\r\n     *   method takes two arguments a success and an error callback which will be called with a\r\n     *   response object. The `success` and `error` methods take a single argument - a function that\r\n     *   will be called when the request succeeds or fails respectively. The arguments passed into\r\n     *   these functions are destructured representation of the response object passed into the\r\n     *   `then` method. The response object has these properties:\r\n     *\r\n     *   - **data**  `{string|Object}`  The response body transformed with the transform functions.\r\n     *   - **status**  `{number}`  HTTP status code of the response.\r\n     *   - **headers**  `{function([headerName])}`  Header getter function.\r\n     *   - **config**  `{Object}`  The configuration object that was used to generate the request.\r\n     *\r\n     * @property {Array.<Object>} pendingRequests Array of config objects for currently pending\r\n     *   requests. This is primarily meant to be used for debugging purposes.\r\n     *\r\n     *\r\n     * @example\r\n      <example>\r\n        <file name=\"index.html\">\r\n          <div ng-controller=\"FetchCtrl\">\r\n            <select ng-model=\"method\">\r\n              <option>GET</option>\r\n              <option>JSONP</option>\r\n            </select>\r\n            <input type=\"text\" ng-model=\"url\" size=\"80\"/>\r\n            <button ng-click=\"fetch()\">fetch</button><br>\r\n            <button ng-click=\"updateModel('GET', 'http-hello.html')\">Sample GET</button>\r\n            <button ng-click=\"updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')\">Sample JSONP</button>\r\n            <button ng-click=\"updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')\">Invalid JSONP</button>\r\n            <pre>http status code: {{status}}</pre>\r\n            <pre>http response data: {{data}}</pre>\r\n          </div>\r\n        </file>\r\n        <file name=\"script.js\">\r\n          function FetchCtrl($scope, $http, $templateCache) {\r\n            $scope.method = 'GET';\r\n            $scope.url = 'http-hello.html';\r\n\r\n            $scope.fetch = function() {\r\n              $scope.code = null;\r\n              $scope.response = null;\r\n\r\n              $http({method: $scope.method, url: $scope.url, cache: $templateCache}).\r\n                success(function(data, status) {\r\n                  $scope.status = status;\r\n                  $scope.data = data;\r\n                }).\r\n                error(function(data, status) {\r\n                  $scope.data = data || \"Request failed\";\r\n                  $scope.status = status;\r\n              });\r\n            };\r\n\r\n            $scope.updateModel = function(method, url) {\r\n              $scope.method = method;\r\n              $scope.url = url;\r\n            };\r\n          }\r\n        </file>\r\n        <file name=\"http-hello.html\">\r\n          Hello, $http!\r\n        </file>\r\n        <file name=\"scenario.js\">\r\n          it('should make an xhr GET request', function() {\r\n            element(':button:contains(\"Sample GET\")').click();\r\n            element(':button:contains(\"fetch\")').click();\r\n            expect(binding('status')).toBe('200');\r\n            expect(binding('data')).toMatch(/Hello, \\$http!/);\r\n          });\r\n\r\n          it('should make a JSONP request to angularjs.org', function() {\r\n            element(':button:contains(\"Sample JSONP\")').click();\r\n            element(':button:contains(\"fetch\")').click();\r\n            expect(binding('status')).toBe('200');\r\n            expect(binding('data')).toMatch(/Super Hero!/);\r\n          });\r\n\r\n          it('should make JSONP request to invalid URL and invoke the error handler',\r\n              function() {\r\n            element(':button:contains(\"Invalid JSONP\")').click();\r\n            element(':button:contains(\"fetch\")').click();\r\n            expect(binding('status')).toBe('0');\r\n            expect(binding('data')).toBe('Request failed');\r\n          });\r\n        </file>\r\n      </example>\r\n     */\r\n    function $http(requestConfig) {\r\n      var config = {\r\n        transformRequest: defaults.transformRequest,\r\n        transformResponse: defaults.transformResponse\r\n      };\r\n      var headers = {};\r\n\r\n      extend(config, requestConfig);\r\n      config.headers = headers;\r\n      config.method = uppercase(config.method);\r\n\r\n      extend(headers,\r\n          defaults.headers.common,\r\n          defaults.headers[lowercase(config.method)],\r\n          requestConfig.headers);\r\n\r\n      var xsrfValue = isSameDomain(config.url, $browser.url())\r\n          ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]\r\n          : undefined;\r\n      if (xsrfValue) {\r\n        headers[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;\r\n      }\r\n\r\n\r\n      var serverRequest = function(config) {\r\n        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);\r\n\r\n        // strip content-type if data is undefined\r\n        if (isUndefined(config.data)) {\r\n          delete headers['Content-Type'];\r\n        }\r\n\r\n        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {\r\n          config.withCredentials = defaults.withCredentials;\r\n        }\r\n\r\n        // send request\r\n        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);\r\n      };\r\n\r\n      var chain = [serverRequest, undefined];\r\n      var promise = $q.when(config);\r\n\r\n      // apply interceptors\r\n      forEach(reversedInterceptors, function(interceptor) {\r\n        if (interceptor.request || interceptor.requestError) {\r\n          chain.unshift(interceptor.request, interceptor.requestError);\r\n        }\r\n        if (interceptor.response || interceptor.responseError) {\r\n          chain.push(interceptor.response, interceptor.responseError);\r\n        }\r\n      });\r\n\r\n      while(chain.length) {\r\n        var thenFn = chain.shift();\r\n        var rejectFn = chain.shift();\r\n\r\n        promise = promise.then(thenFn, rejectFn);\r\n      }\r\n\r\n      promise.success = function(fn) {\r\n        promise.then(function(response) {\r\n          fn(response.data, response.status, response.headers, config);\r\n        });\r\n        return promise;\r\n      };\r\n\r\n      promise.error = function(fn) {\r\n        promise.then(null, function(response) {\r\n          fn(response.data, response.status, response.headers, config);\r\n        });\r\n        return promise;\r\n      };\r\n\r\n      return promise;\r\n\r\n      function transformResponse(response) {\r\n        // make a copy since the response must be cacheable\r\n        var resp = extend({}, response, {\r\n          data: transformData(response.data, response.headers, config.transformResponse)\r\n        });\r\n        return (isSuccess(response.status))\r\n          ? resp\r\n          : $q.reject(resp);\r\n      }\r\n    }\r\n\r\n    $http.pendingRequests = [];\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ng.$http#get\r\n     * @methodOf ng.$http\r\n     *\r\n     * @description\r\n     * Shortcut method to perform `GET` request.\r\n     *\r\n     * @param {string} url Relative or absolute URL specifying the destination of the request\r\n     * @param {Object=} config Optional configuration object\r\n     * @returns {HttpPromise} Future object\r\n     */\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ng.$http#delete\r\n     * @methodOf ng.$http\r\n     *\r\n     * @description\r\n     * Shortcut method to perform `DELETE` request.\r\n     *\r\n     * @param {string} url Relative or absolute URL specifying the destination of the request\r\n     * @param {Object=} config Optional configuration object\r\n     * @returns {HttpPromise} Future object\r\n     */\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ng.$http#head\r\n     * @methodOf ng.$http\r\n     *\r\n     * @description\r\n     * Shortcut method to perform `HEAD` request.\r\n     *\r\n     * @param {string} url Relative or absolute URL specifying the destination of the request\r\n     * @param {Object=} config Optional configuration object\r\n     * @returns {HttpPromise} Future object\r\n     */\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ng.$http#jsonp\r\n     * @methodOf ng.$http\r\n     *\r\n     * @description\r\n     * Shortcut method to perform `JSONP` request.\r\n     *\r\n     * @param {string} url Relative or absolute URL specifying the destination of the request.\r\n     *                     Should contain `JSON_CALLBACK` string.\r\n     * @param {Object=} config Optional configuration object\r\n     * @returns {HttpPromise} Future object\r\n     */\r\n    createShortMethods('get', 'delete', 'head', 'jsonp');\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ng.$http#post\r\n     * @methodOf ng.$http\r\n     *\r\n     * @description\r\n     * Shortcut method to perform `POST` request.\r\n     *\r\n     * @param {string} url Relative or absolute URL specifying the destination of the request\r\n     * @param {*} data Request content\r\n     * @param {Object=} config Optional configuration object\r\n     * @returns {HttpPromise} Future object\r\n     */\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ng.$http#put\r\n     * @methodOf ng.$http\r\n     *\r\n     * @description\r\n     * Shortcut method to perform `PUT` request.\r\n     *\r\n     * @param {string} url Relative or absolute URL specifying the destination of the request\r\n     * @param {*} data Request content\r\n     * @param {Object=} config Optional configuration object\r\n     * @returns {HttpPromise} Future object\r\n     */\r\n    createShortMethodsWithData('post', 'put');\r\n\r\n        /**\r\n         * @ngdoc property\r\n         * @name ng.$http#defaults\r\n         * @propertyOf ng.$http\r\n         *\r\n         * @description\r\n         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of\r\n         * default headers, withCredentials as well as request and response transformations.\r\n         *\r\n         * See \"Setting HTTP Headers\" and \"Transforming Requests and Responses\" sections above.\r\n         */\r\n    $http.defaults = defaults;\r\n\r\n\r\n    return $http;\r\n\r\n\r\n    function createShortMethods(names) {\r\n      forEach(arguments, function(name) {\r\n        $http[name] = function(url, config) {\r\n          return $http(extend(config || {}, {\r\n            method: name,\r\n            url: url\r\n          }));\r\n        };\r\n      });\r\n    }\r\n\r\n\r\n    function createShortMethodsWithData(name) {\r\n      forEach(arguments, function(name) {\r\n        $http[name] = function(url, data, config) {\r\n          return $http(extend(config || {}, {\r\n            method: name,\r\n            url: url,\r\n            data: data\r\n          }));\r\n        };\r\n      });\r\n    }\r\n\r\n\r\n    /**\r\n     * Makes the request.\r\n     *\r\n     * !!! ACCESSES CLOSURE VARS:\r\n     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests\r\n     */\r\n    function sendReq(config, reqData, reqHeaders) {\r\n      var deferred = $q.defer(),\r\n          promise = deferred.promise,\r\n          cache,\r\n          cachedResp,\r\n          url = buildUrl(config.url, config.params);\r\n\r\n      $http.pendingRequests.push(config);\r\n      promise.then(removePendingReq, removePendingReq);\r\n\r\n\r\n      if ((config.cache || defaults.cache) && config.cache !== false && config.method == 'GET') {\r\n        cache = isObject(config.cache) ? config.cache\r\n              : isObject(defaults.cache) ? defaults.cache\r\n              : defaultCache;\r\n      }\r\n\r\n      if (cache) {\r\n        cachedResp = cache.get(url);\r\n        if (cachedResp) {\r\n          if (cachedResp.then) {\r\n            // cached request has already been sent, but there is no response yet\r\n            cachedResp.then(removePendingReq, removePendingReq);\r\n            return cachedResp;\r\n          } else {\r\n            // serving from cache\r\n            if (isArray(cachedResp)) {\r\n              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));\r\n            } else {\r\n              resolvePromise(cachedResp, 200, {});\r\n            }\r\n          }\r\n        } else {\r\n          // put the promise for the non-transformed response into cache as a placeholder\r\n          cache.put(url, promise);\r\n        }\r\n      }\r\n\r\n      // if we won't have the response in cache, send the request to the backend\r\n      if (!cachedResp) {\r\n        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,\r\n            config.withCredentials, config.responseType);\r\n      }\r\n\r\n      return promise;\r\n\r\n\r\n      /**\r\n       * Callback registered to $httpBackend():\r\n       *  - caches the response if desired\r\n       *  - resolves the raw $http promise\r\n       *  - calls $apply\r\n       */\r\n      function done(status, response, headersString) {\r\n        if (cache) {\r\n          if (isSuccess(status)) {\r\n            cache.put(url, [status, response, parseHeaders(headersString)]);\r\n          } else {\r\n            // remove promise from the cache\r\n            cache.remove(url);\r\n          }\r\n        }\r\n\r\n        resolvePromise(response, status, headersString);\r\n        if (!$rootScope.$$phase) $rootScope.$apply();\r\n      }\r\n\r\n\r\n      /**\r\n       * Resolves the raw $http promise.\r\n       */\r\n      function resolvePromise(response, status, headers) {\r\n        // normalize internal statuses to 0\r\n        status = Math.max(status, 0);\r\n\r\n        (isSuccess(status) ? deferred.resolve : deferred.reject)({\r\n          data: response,\r\n          status: status,\r\n          headers: headersGetter(headers),\r\n          config: config\r\n        });\r\n      }\r\n\r\n\r\n      function removePendingReq() {\r\n        var idx = indexOf($http.pendingRequests, config);\r\n        if (idx !== -1) $http.pendingRequests.splice(idx, 1);\r\n      }\r\n    }\r\n\r\n\r\n    function buildUrl(url, params) {\r\n          if (!params) return url;\r\n          var parts = [];\r\n          forEachSorted(params, function(value, key) {\r\n            if (value == null || value == undefined) return;\r\n            if (!isArray(value)) value = [value];\r\n\r\n            forEach(value, function(v) {\r\n              if (isObject(v)) {\r\n                v = toJson(v);\r\n              }\r\n              parts.push(encodeUriQuery(key) + '=' +\r\n                         encodeUriQuery(v));\r\n            });\r\n          });\r\n          return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');\r\n        }\r\n\r\n\r\n  }];\r\n}\r\n\r\nvar XHR = window.XMLHttpRequest || function() {\r\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP.6.0\"); } catch (e1) {}\r\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP.3.0\"); } catch (e2) {}\r\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP\"); } catch (e3) {}\r\n  throw new Error(\"This browser does not support XMLHttpRequest.\");\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$httpBackend\r\n * @requires $browser\r\n * @requires $window\r\n * @requires $document\r\n *\r\n * @description\r\n * HTTP backend used by the {@link ng.$http service} that delegates to\r\n * XMLHttpRequest object or JSONP and deals with browser incompatibilities.\r\n *\r\n * You should never need to use this service directly, instead use the higher-level abstractions:\r\n * {@link ng.$http $http} or {@link ngResource.$resource $resource}.\r\n *\r\n * During testing this implementation is swapped with {@link ngMock.$httpBackend mock\r\n * $httpBackend} which can be trained with responses.\r\n */\r\nfunction $HttpBackendProvider() {\r\n  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {\r\n    return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,\r\n        $document[0], $window.location.protocol.replace(':', ''));\r\n  }];\r\n}\r\n\r\nfunction createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {\r\n  // TODO(vojta): fix the signature\r\n  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {\r\n    var status;\r\n    $browser.$$incOutstandingRequestCount();\r\n    url = url || $browser.url();\r\n\r\n    if (lowercase(method) == 'jsonp') {\r\n      var callbackId = '_' + (callbacks.counter++).toString(36);\r\n      callbacks[callbackId] = function(data) {\r\n        callbacks[callbackId].data = data;\r\n      };\r\n\r\n      var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),\r\n          function() {\r\n        if (callbacks[callbackId].data) {\r\n          completeRequest(callback, 200, callbacks[callbackId].data);\r\n        } else {\r\n          completeRequest(callback, status || -2);\r\n        }\r\n        delete callbacks[callbackId];\r\n      });\r\n    } else {\r\n      var xhr = new XHR();\r\n      xhr.open(method, url, true);\r\n      forEach(headers, function(value, key) {\r\n        if (value) xhr.setRequestHeader(key, value);\r\n      });\r\n\r\n      // In IE6 and 7, this might be called synchronously when xhr.send below is called and the\r\n      // response is in the cache. the promise api will ensure that to the app code the api is\r\n      // always async\r\n      xhr.onreadystatechange = function() {\r\n        if (xhr.readyState == 4) {\r\n          var responseHeaders = xhr.getAllResponseHeaders();\r\n\r\n          // TODO(vojta): remove once Firefox 21 gets released.\r\n          // begin: workaround to overcome Firefox CORS http response headers bug\r\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735\r\n          // Firefox already patched in nightly. Should land in Firefox 21.\r\n\r\n          // CORS \"simple response headers\" http://www.w3.org/TR/cors/\r\n          var value,\r\n              simpleHeaders = [\"Cache-Control\", \"Content-Language\", \"Content-Type\",\r\n                                  \"Expires\", \"Last-Modified\", \"Pragma\"];\r\n          if (!responseHeaders) {\r\n            responseHeaders = \"\";\r\n            forEach(simpleHeaders, function (header) {\r\n              var value = xhr.getResponseHeader(header);\r\n              if (value) {\r\n                  responseHeaders += header + \": \" + value + \"\\n\";\r\n              }\r\n            });\r\n          }\r\n          // end of the workaround.\r\n\r\n          // responseText is the old-school way of retrieving response (supported by IE8 & 9)\r\n          // response and responseType properties were introduced in XHR Level2 spec (supported by IE10)\r\n          completeRequest(callback,\r\n              status || xhr.status,\r\n              (xhr.responseType ? xhr.response : xhr.responseText),\r\n              responseHeaders);\r\n        }\r\n      };\r\n\r\n      if (withCredentials) {\r\n        xhr.withCredentials = true;\r\n      }\r\n\r\n      if (responseType) {\r\n        xhr.responseType = responseType;\r\n      }\r\n\r\n      xhr.send(post || '');\r\n    }\r\n\r\n    if (timeout > 0) {\r\n      var timeoutId = $browserDefer(timeoutRequest, timeout);\r\n    } else if (timeout && timeout.then) {\r\n      timeout.then(timeoutRequest);\r\n    }\r\n\r\n\r\n    function timeoutRequest() {\r\n      status = -1;\r\n      jsonpDone && jsonpDone();\r\n      xhr && xhr.abort();\r\n    }\r\n\r\n    function completeRequest(callback, status, response, headersString) {\r\n      // URL_MATCH is defined in src/service/location.js\r\n      var protocol = (url.match(SERVER_MATCH) || ['', locationProtocol])[1];\r\n\r\n      // cancel timeout and subsequent timeout promise resolution\r\n      timeoutId && $browserDefer.cancel(timeoutId);\r\n      jsonpDone = xhr = null;\r\n\r\n      // fix status code for file protocol (it's always 0)\r\n      status = (protocol == 'file') ? (response ? 200 : 404) : status;\r\n\r\n      // normalize IE bug (http://bugs.jquery.com/ticket/1450)\r\n      status = status == 1223 ? 204 : status;\r\n\r\n      callback(status, response, headersString);\r\n      $browser.$$completeOutstandingRequest(noop);\r\n    }\r\n  };\r\n\r\n  function jsonpReq(url, done) {\r\n    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:\r\n    // - fetches local scripts via XHR and evals them\r\n    // - adds and immediately removes script elements from the document\r\n    var script = rawDocument.createElement('script'),\r\n        doneWrapper = function() {\r\n          rawDocument.body.removeChild(script);\r\n          if (done) done();\r\n        };\r\n\r\n    script.type = 'text/javascript';\r\n    script.src = url;\r\n\r\n    if (msie) {\r\n      script.onreadystatechange = function() {\r\n        if (/loaded|complete/.test(script.readyState)) doneWrapper();\r\n      };\r\n    } else {\r\n      script.onload = script.onerror = doneWrapper;\r\n    }\r\n\r\n    rawDocument.body.appendChild(script);\r\n    return doneWrapper;\r\n  }\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$locale\r\n *\r\n * @description\r\n * $locale service provides localization rules for various Angular components. As of right now the\r\n * only public api is:\r\n *\r\n * * `id`  `{string}`  locale id formatted as `languageId-countryId` (e.g. `en-us`)\r\n */\r\nfunction $LocaleProvider(){\r\n  this.$get = function() {\r\n    return {\r\n      id: 'en-us',\r\n\r\n      NUMBER_FORMATS: {\r\n        DECIMAL_SEP: '.',\r\n        GROUP_SEP: ',',\r\n        PATTERNS: [\r\n          { // Decimal Pattern\r\n            minInt: 1,\r\n            minFrac: 0,\r\n            maxFrac: 3,\r\n            posPre: '',\r\n            posSuf: '',\r\n            negPre: '-',\r\n            negSuf: '',\r\n            gSize: 3,\r\n            lgSize: 3\r\n          },{ //Currency Pattern\r\n            minInt: 1,\r\n            minFrac: 2,\r\n            maxFrac: 2,\r\n            posPre: '\\u00A4',\r\n            posSuf: '',\r\n            negPre: '(\\u00A4',\r\n            negSuf: ')',\r\n            gSize: 3,\r\n            lgSize: 3\r\n          }\r\n        ],\r\n        CURRENCY_SYM: '$'\r\n      },\r\n\r\n      DATETIME_FORMATS: {\r\n        MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'\r\n                .split(','),\r\n        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),\r\n        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),\r\n        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),\r\n        AMPMS: ['AM','PM'],\r\n        medium: 'MMM d, y h:mm:ss a',\r\n        short: 'M/d/yy h:mm a',\r\n        fullDate: 'EEEE, MMMM d, y',\r\n        longDate: 'MMMM d, y',\r\n        mediumDate: 'MMM d, y',\r\n        shortDate: 'M/d/yy',\r\n        mediumTime: 'h:mm:ss a',\r\n        shortTime: 'h:mm a'\r\n      },\r\n\r\n      pluralCat: function(num) {\r\n        if (num === 1) {\r\n          return 'one';\r\n        }\r\n        return 'other';\r\n      }\r\n    };\r\n  };\r\n}\r\n\r\nfunction $TimeoutProvider() {\r\n  this.$get = ['$rootScope', '$browser', '$q', '$exceptionHandler',\r\n       function($rootScope,   $browser,   $q,   $exceptionHandler) {\r\n    var deferreds = {};\r\n\r\n\r\n     /**\r\n      * @ngdoc function\r\n      * @name ng.$timeout\r\n      * @requires $browser\r\n      *\r\n      * @description\r\n      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch\r\n      * block and delegates any exceptions to\r\n      * {@link ng.$exceptionHandler $exceptionHandler} service.\r\n      *\r\n      * The return value of registering a timeout function is a promise, which will be resolved when\r\n      * the timeout is reached and the timeout function is executed.\r\n      *\r\n      * To cancel a timeout request, call `$timeout.cancel(promise)`.\r\n      *\r\n      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to\r\n      * synchronously flush the queue of deferred functions.\r\n      *\r\n      * @param {function()} fn A function, whose execution should be delayed.\r\n      * @param {number=} [delay=0] Delay in milliseconds.\r\n      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise\r\n      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.\r\n      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this\r\n      *   promise will be resolved with is the return value of the `fn` function.\r\n      */\r\n    function timeout(fn, delay, invokeApply) {\r\n      var deferred = $q.defer(),\r\n          promise = deferred.promise,\r\n          skipApply = (isDefined(invokeApply) && !invokeApply),\r\n          timeoutId, cleanup;\r\n\r\n      timeoutId = $browser.defer(function() {\r\n        try {\r\n          deferred.resolve(fn());\r\n        } catch(e) {\r\n          deferred.reject(e);\r\n          $exceptionHandler(e);\r\n        }\r\n\r\n        if (!skipApply) $rootScope.$apply();\r\n      }, delay);\r\n\r\n      cleanup = function() {\r\n        delete deferreds[promise.$$timeoutId];\r\n      };\r\n\r\n      promise.$$timeoutId = timeoutId;\r\n      deferreds[timeoutId] = deferred;\r\n      promise.then(cleanup, cleanup);\r\n\r\n      return promise;\r\n    }\r\n\r\n\r\n     /**\r\n      * @ngdoc function\r\n      * @name ng.$timeout#cancel\r\n      * @methodOf ng.$timeout\r\n      *\r\n      * @description\r\n      * Cancels a task associated with the `promise`. As a result of this, the promise will be\r\n      * resolved with a rejection.\r\n      *\r\n      * @param {Promise=} promise Promise returned by the `$timeout` function.\r\n      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully\r\n      *   canceled.\r\n      */\r\n    timeout.cancel = function(promise) {\r\n      if (promise && promise.$$timeoutId in deferreds) {\r\n        deferreds[promise.$$timeoutId].reject('canceled');\r\n        return $browser.defer.cancel(promise.$$timeoutId);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    return timeout;\r\n  }];\r\n}\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.$filterProvider\r\n * @description\r\n *\r\n * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To\r\n * achieve this a filter definition consists of a factory function which is annotated with dependencies and is\r\n * responsible for creating a filter function.\r\n *\r\n * <pre>\r\n *   // Filter registration\r\n *   function MyModule($provide, $filterProvider) {\r\n *     // create a service to demonstrate injection (not always needed)\r\n *     $provide.value('greet', function(name){\r\n *       return 'Hello ' + name + '!';\r\n *     });\r\n *\r\n *     // register a filter factory which uses the\r\n *     // greet service to demonstrate DI.\r\n *     $filterProvider.register('greet', function(greet){\r\n *       // return the filter function which uses the greet service\r\n *       // to generate salutation\r\n *       return function(text) {\r\n *         // filters need to be forgiving so check input validity\r\n *         return text && greet(text) || text;\r\n *       };\r\n *     });\r\n *   }\r\n * </pre>\r\n *\r\n * The filter function is registered with the `$injector` under the filter name suffixe with `Filter`.\r\n * <pre>\r\n *   it('should be the same instance', inject(\r\n *     function($filterProvider) {\r\n *       $filterProvider.register('reverse', function(){\r\n *         return ...;\r\n *       });\r\n *     },\r\n *     function($filter, reverseFilter) {\r\n *       expect($filter('reverse')).toBe(reverseFilter);\r\n *     });\r\n * </pre>\r\n *\r\n *\r\n * For more information about how angular filters work, and how to create your own filters, see\r\n * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer\r\n * Guide.\r\n */\r\n/**\r\n * @ngdoc method\r\n * @name ng.$filterProvider#register\r\n * @methodOf ng.$filterProvider\r\n * @description\r\n * Register filter factory function.\r\n *\r\n * @param {String} name Name of the filter.\r\n * @param {function} fn The filter factory function which is injectable.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.$filter\r\n * @function\r\n * @description\r\n * Filters are used for formatting data displayed to the user.\r\n *\r\n * The general syntax in templates is as follows:\r\n *\r\n *         {{ expression [| filter_name[:parameter_value] ... ] }}\r\n *\r\n * @param {String} name Name of the filter function to retrieve\r\n * @return {Function} the filter function\r\n */\r\n$FilterProvider.$inject = ['$provide'];\r\nfunction $FilterProvider($provide) {\r\n  var suffix = 'Filter';\r\n\r\n  function register(name, factory) {\r\n    return $provide.factory(name + suffix, factory);\r\n  }\r\n  this.register = register;\r\n\r\n  this.$get = ['$injector', function($injector) {\r\n    return function(name) {\r\n      return $injector.get(name + suffix);\r\n    }\r\n  }];\r\n\r\n  ////////////////////////////////////////\r\n\r\n  register('currency', currencyFilter);\r\n  register('date', dateFilter);\r\n  register('filter', filterFilter);\r\n  register('json', jsonFilter);\r\n  register('limitTo', limitToFilter);\r\n  register('lowercase', lowercaseFilter);\r\n  register('number', numberFilter);\r\n  register('orderBy', orderByFilter);\r\n  register('uppercase', uppercaseFilter);\r\n}\r\n\r\n/**\r\n * @ngdoc filter\r\n * @name ng.filter:filter\r\n * @function\r\n *\r\n * @description\r\n * Selects a subset of items from `array` and returns it as a new array.\r\n *\r\n * Note: This function is used to augment the `Array` type in Angular expressions. See\r\n * {@link ng.$filter} for more information about Angular arrays.\r\n *\r\n * @param {Array} array The source array.\r\n * @param {string|Object|function()} expression The predicate to be used for selecting items from\r\n *   `array`.\r\n *\r\n *   Can be one of:\r\n *\r\n *   - `string`: Predicate that results in a substring match using the value of `expression`\r\n *     string. All strings or objects with string properties in `array` that contain this string\r\n *     will be returned. The predicate can be negated by prefixing the string with `!`.\r\n *\r\n *   - `Object`: A pattern object can be used to filter specific properties on objects contained\r\n *     by `array`. For example `{name:\"M\", phone:\"1\"}` predicate will return an array of items\r\n *     which have property `name` containing \"M\" and property `phone` containing \"1\". A special\r\n *     property name `$` can be used (as in `{$:\"text\"}`) to accept a match against any\r\n *     property of the object. That's equivalent to the simple substring match with a `string`\r\n *     as described above.\r\n *\r\n *   - `function`: A predicate function can be used to write arbitrary filters. The function is\r\n *     called for each element of `array`. The final result is an array of those elements that\r\n *     the predicate returned true for.\r\n *\r\n * @param {function(expected, actual)|true|undefined} comparator Comparator which is used in\r\n *     determining if the expected value (from the filter expression) and actual value (from\r\n *     the object in the array) should be considered a match.\r\n *\r\n *   Can be one of:\r\n *\r\n *     - `function(expected, actual)`:\r\n *       The function will be given the object value and the predicate value to compare and\r\n *       should return true if the item should be included in filtered result.\r\n *\r\n *     - `true`: A shorthand for `function(expected, actual) { return angular.equals(expected, actual)}`.\r\n *       this is essentially strict comparison of expected and actual.\r\n *\r\n *     - `false|undefined`: A short hand for a function which will look for a substring match in case\r\n *       insensitive way.\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n       <div ng-init=\"friends = [{name:'John', phone:'555-1276'},\r\n                                {name:'Mary', phone:'800-BIG-MARY'},\r\n                                {name:'Mike', phone:'555-4321'},\r\n                                {name:'Adam', phone:'555-5678'},\r\n                                {name:'Julie', phone:'555-8765'},\r\n                                {name:'Juliette', phone:'555-5678'}]\"></div>\r\n\r\n       Search: <input ng-model=\"searchText\">\r\n       <table id=\"searchTextResults\">\r\n         <tr><th>Name</th><th>Phone</th></tr>\r\n         <tr ng-repeat=\"friend in friends | filter:searchText\">\r\n           <td>{{friend.name}}</td>\r\n           <td>{{friend.phone}}</td>\r\n         </tr>\r\n       </table>\r\n       <hr>\r\n       Any: <input ng-model=\"search.$\"> <br>\r\n       Name only <input ng-model=\"search.name\"><br>\r\n       Phone only <input ng-model=\"search.phone\"><br>\r\n       Equality <input type=\"checkbox\" ng-model=\"strict\"><br>\r\n       <table id=\"searchObjResults\">\r\n         <tr><th>Name</th><th>Phone</th></tr>\r\n         <tr ng-repeat=\"friend in friends | filter:search:strict\">\r\n           <td>{{friend.name}}</td>\r\n           <td>{{friend.phone}}</td>\r\n         </tr>\r\n       </table>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should search across all fields when filtering with a string', function() {\r\n         input('searchText').enter('m');\r\n         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).\r\n           toEqual(['Mary', 'Mike', 'Adam']);\r\n\r\n         input('searchText').enter('76');\r\n         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).\r\n           toEqual(['John', 'Julie']);\r\n       });\r\n\r\n       it('should search in specific fields when filtering with a predicate object', function() {\r\n         input('search.$').enter('i');\r\n         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).\r\n           toEqual(['Mary', 'Mike', 'Julie', 'Juliette']);\r\n       });\r\n       it('should use a equal comparison when comparator is true', function() {\r\n         input('search.name').enter('Julie');\r\n         input('strict').check();\r\n         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).\r\n           toEqual(['Julie']);\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\nfunction filterFilter() {\r\n  return function(array, expression, comperator) {\r\n    if (!isArray(array)) return array;\r\n    var predicates = [];\r\n    predicates.check = function(value) {\r\n      for (var j = 0; j < predicates.length; j++) {\r\n        if(!predicates[j](value)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    switch(typeof comperator) {\r\n      case \"function\":\r\n        break;\r\n      case \"boolean\":\r\n        if(comperator == true) {\r\n          comperator = function(obj, text) {\r\n            return angular.equals(obj, text);\r\n          }\r\n          break;\r\n        }\r\n      default:\r\n        comperator = function(obj, text) {\r\n          text = (''+text).toLowerCase();\r\n          return (''+obj).toLowerCase().indexOf(text) > -1\r\n        };\r\n    }\r\n    var search = function(obj, text){\r\n      if (typeof text == 'string' && text.charAt(0) === '!') {\r\n        return !search(obj, text.substr(1));\r\n      }\r\n      switch (typeof obj) {\r\n        case \"boolean\":\r\n        case \"number\":\r\n        case \"string\":\r\n          return comperator(obj, text);\r\n        case \"object\":\r\n          switch (typeof text) {\r\n            case \"object\":\r\n              return comperator(obj, text);\r\n              break;\r\n            default:\r\n              for ( var objKey in obj) {\r\n                if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {\r\n                  return true;\r\n                }\r\n              }\r\n              break;\r\n          }\r\n          return false;\r\n        case \"array\":\r\n          for ( var i = 0; i < obj.length; i++) {\r\n            if (search(obj[i], text)) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        default:\r\n          return false;\r\n      }\r\n    };\r\n    switch (typeof expression) {\r\n      case \"boolean\":\r\n      case \"number\":\r\n      case \"string\":\r\n        expression = {$:expression};\r\n      case \"object\":\r\n        for (var key in expression) {\r\n          if (key == '$') {\r\n            (function() {\r\n              if (!expression[key]) return;\r\n              var path = key\r\n              predicates.push(function(value) {\r\n                return search(value, expression[path]);\r\n              });\r\n            })();\r\n          } else {\r\n            (function() {\r\n              if (!expression[key]) return;\r\n              var path = key;\r\n              predicates.push(function(value) {\r\n                return search(getter(value,path), expression[path]);\r\n              });\r\n            })();\r\n          }\r\n        }\r\n        break;\r\n      case 'function':\r\n        predicates.push(expression);\r\n        break;\r\n      default:\r\n        return array;\r\n    }\r\n    var filtered = [];\r\n    for ( var j = 0; j < array.length; j++) {\r\n      var value = array[j];\r\n      if (predicates.check(value)) {\r\n        filtered.push(value);\r\n      }\r\n    }\r\n    return filtered;\r\n  }\r\n}\r\n\r\n/**\r\n * @ngdoc filter\r\n * @name ng.filter:currency\r\n * @function\r\n *\r\n * @description\r\n * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default\r\n * symbol for current locale is used.\r\n *\r\n * @param {number} amount Input to filter.\r\n * @param {string=} symbol Currency symbol or identifier to be displayed.\r\n * @returns {string} Formatted number.\r\n *\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.amount = 1234.56;\r\n         }\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n         <input type=\"number\" ng-model=\"amount\"> <br>\r\n         default currency symbol ($): {{amount | currency}}<br>\r\n         custom currency identifier (USD$): {{amount | currency:\"USD$\"}}\r\n       </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should init with 1234.56', function() {\r\n         expect(binding('amount | currency')).toBe('$1,234.56');\r\n         expect(binding('amount | currency:\"USD$\"')).toBe('USD$1,234.56');\r\n       });\r\n       it('should update', function() {\r\n         input('amount').enter('-1234');\r\n         expect(binding('amount | currency')).toBe('($1,234.00)');\r\n         expect(binding('amount | currency:\"USD$\"')).toBe('(USD$1,234.00)');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\ncurrencyFilter.$inject = ['$locale'];\r\nfunction currencyFilter($locale) {\r\n  var formats = $locale.NUMBER_FORMATS;\r\n  return function(amount, currencySymbol){\r\n    if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;\r\n    return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).\r\n                replace(/\\u00A4/g, currencySymbol);\r\n  };\r\n}\r\n\r\n/**\r\n * @ngdoc filter\r\n * @name ng.filter:number\r\n * @function\r\n *\r\n * @description\r\n * Formats a number as text.\r\n *\r\n * If the input is not a number an empty string is returned.\r\n *\r\n * @param {number|string} number Number to format.\r\n * @param {(number|string)=} [fractionSize=2] Number of decimal places to round the number to.\r\n * @returns {string} Number rounded to decimalPlaces and places a , after each third digit.\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.val = 1234.56789;\r\n         }\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n         Enter number: <input ng-model='val'><br>\r\n         Default formatting: {{val | number}}<br>\r\n         No fractions: {{val | number:0}}<br>\r\n         Negative number: {{-val | number:4}}\r\n       </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should format numbers', function() {\r\n         expect(binding('val | number')).toBe('1,234.568');\r\n         expect(binding('val | number:0')).toBe('1,235');\r\n         expect(binding('-val | number:4')).toBe('-1,234.5679');\r\n       });\r\n\r\n       it('should update', function() {\r\n         input('val').enter('3374.333');\r\n         expect(binding('val | number')).toBe('3,374.333');\r\n         expect(binding('val | number:0')).toBe('3,374');\r\n         expect(binding('-val | number:4')).toBe('-3,374.3330');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\n\r\n\r\nnumberFilter.$inject = ['$locale'];\r\nfunction numberFilter($locale) {\r\n  var formats = $locale.NUMBER_FORMATS;\r\n  return function(number, fractionSize) {\r\n    return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,\r\n      fractionSize);\r\n  };\r\n}\r\n\r\nvar DECIMAL_SEP = '.';\r\nfunction formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {\r\n  if (isNaN(number) || !isFinite(number)) return '';\r\n\r\n  var isNegative = number < 0;\r\n  number = Math.abs(number);\r\n  var numStr = number + '',\r\n      formatedText = '',\r\n      parts = [];\r\n\r\n  var hasExponent = false;\r\n  if (numStr.indexOf('e') !== -1) {\r\n    var match = numStr.match(/([\\d\\.]+)e(-?)(\\d+)/);\r\n    if (match && match[2] == '-' && match[3] > fractionSize + 1) {\r\n      numStr = '0';\r\n    } else {\r\n      formatedText = numStr;\r\n      hasExponent = true;\r\n    }\r\n  }\r\n\r\n  if (!hasExponent) {\r\n    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;\r\n\r\n    // determine fractionSize if it is not specified\r\n    if (isUndefined(fractionSize)) {\r\n      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);\r\n    }\r\n\r\n    var pow = Math.pow(10, fractionSize);\r\n    number = Math.round(number * pow) / pow;\r\n    var fraction = ('' + number).split(DECIMAL_SEP);\r\n    var whole = fraction[0];\r\n    fraction = fraction[1] || '';\r\n\r\n    var pos = 0,\r\n        lgroup = pattern.lgSize,\r\n        group = pattern.gSize;\r\n\r\n    if (whole.length >= (lgroup + group)) {\r\n      pos = whole.length - lgroup;\r\n      for (var i = 0; i < pos; i++) {\r\n        if ((pos - i)%group === 0 && i !== 0) {\r\n          formatedText += groupSep;\r\n        }\r\n        formatedText += whole.charAt(i);\r\n      }\r\n    }\r\n\r\n    for (i = pos; i < whole.length; i++) {\r\n      if ((whole.length - i)%lgroup === 0 && i !== 0) {\r\n        formatedText += groupSep;\r\n      }\r\n      formatedText += whole.charAt(i);\r\n    }\r\n\r\n    // format fraction part.\r\n    while(fraction.length < fractionSize) {\r\n      fraction += '0';\r\n    }\r\n\r\n    if (fractionSize && fractionSize !== \"0\") formatedText += decimalSep + fraction.substr(0, fractionSize);\r\n  }\r\n\r\n  parts.push(isNegative ? pattern.negPre : pattern.posPre);\r\n  parts.push(formatedText);\r\n  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);\r\n  return parts.join('');\r\n}\r\n\r\nfunction padNumber(num, digits, trim) {\r\n  var neg = '';\r\n  if (num < 0) {\r\n    neg =  '-';\r\n    num = -num;\r\n  }\r\n  num = '' + num;\r\n  while(num.length < digits) num = '0' + num;\r\n  if (trim)\r\n    num = num.substr(num.length - digits);\r\n  return neg + num;\r\n}\r\n\r\n\r\nfunction dateGetter(name, size, offset, trim) {\r\n  offset = offset || 0;\r\n  return function(date) {\r\n    var value = date['get' + name]();\r\n    if (offset > 0 || value > -offset)\r\n      value += offset;\r\n    if (value === 0 && offset == -12 ) value = 12;\r\n    return padNumber(value, size, trim);\r\n  };\r\n}\r\n\r\nfunction dateStrGetter(name, shortForm) {\r\n  return function(date, formats) {\r\n    var value = date['get' + name]();\r\n    var get = uppercase(shortForm ? ('SHORT' + name) : name);\r\n\r\n    return formats[get][value];\r\n  };\r\n}\r\n\r\nfunction timeZoneGetter(date) {\r\n  var zone = -1 * date.getTimezoneOffset();\r\n  var paddedZone = (zone >= 0) ? \"+\" : \"\";\r\n\r\n  paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +\r\n                padNumber(Math.abs(zone % 60), 2);\r\n\r\n  return paddedZone;\r\n}\r\n\r\nfunction ampmGetter(date, formats) {\r\n  return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];\r\n}\r\n\r\nvar DATE_FORMATS = {\r\n  yyyy: dateGetter('FullYear', 4),\r\n    yy: dateGetter('FullYear', 2, 0, true),\r\n     y: dateGetter('FullYear', 1),\r\n  MMMM: dateStrGetter('Month'),\r\n   MMM: dateStrGetter('Month', true),\r\n    MM: dateGetter('Month', 2, 1),\r\n     M: dateGetter('Month', 1, 1),\r\n    dd: dateGetter('Date', 2),\r\n     d: dateGetter('Date', 1),\r\n    HH: dateGetter('Hours', 2),\r\n     H: dateGetter('Hours', 1),\r\n    hh: dateGetter('Hours', 2, -12),\r\n     h: dateGetter('Hours', 1, -12),\r\n    mm: dateGetter('Minutes', 2),\r\n     m: dateGetter('Minutes', 1),\r\n    ss: dateGetter('Seconds', 2),\r\n     s: dateGetter('Seconds', 1),\r\n     // while ISO 8601 requires fractions to be prefixed with `.` or `,` \r\n     // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions\r\n   sss: dateGetter('Milliseconds', 3),\r\n  EEEE: dateStrGetter('Day'),\r\n   EEE: dateStrGetter('Day', true),\r\n     a: ampmGetter,\r\n     Z: timeZoneGetter\r\n};\r\n\r\nvar DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,\r\n    NUMBER_STRING = /^\\d+$/;\r\n\r\n/**\r\n * @ngdoc filter\r\n * @name ng.filter:date\r\n * @function\r\n *\r\n * @description\r\n *   Formats `date` to a string based on the requested `format`.\r\n *\r\n *   `format` string can be composed of the following elements:\r\n *\r\n *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)\r\n *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)\r\n *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)\r\n *   * `'MMMM'`: Month in year (January-December)\r\n *   * `'MMM'`: Month in year (Jan-Dec)\r\n *   * `'MM'`: Month in year, padded (01-12)\r\n *   * `'M'`: Month in year (1-12)\r\n *   * `'dd'`: Day in month, padded (01-31)\r\n *   * `'d'`: Day in month (1-31)\r\n *   * `'EEEE'`: Day in Week,(Sunday-Saturday)\r\n *   * `'EEE'`: Day in Week, (Sun-Sat)\r\n *   * `'HH'`: Hour in day, padded (00-23)\r\n *   * `'H'`: Hour in day (0-23)\r\n *   * `'hh'`: Hour in am/pm, padded (01-12)\r\n *   * `'h'`: Hour in am/pm, (1-12)\r\n *   * `'mm'`: Minute in hour, padded (00-59)\r\n *   * `'m'`: Minute in hour (0-59)\r\n *   * `'ss'`: Second in minute, padded (00-59)\r\n *   * `'s'`: Second in minute (0-59)\r\n *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)\r\n *   * `'a'`: am/pm marker\r\n *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)\r\n *\r\n *   `format` string can also be one of the following predefined\r\n *   {@link guide/i18n localizable formats}:\r\n *\r\n *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale\r\n *     (e.g. Sep 3, 2010 12:05:08 pm)\r\n *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)\r\n *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale\r\n *     (e.g. Friday, September 3, 2010)\r\n *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010\r\n *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)\r\n *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)\r\n *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)\r\n *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)\r\n *\r\n *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.\r\n *   `\"h 'in the morning'\"`). In order to output single quote, use two single quotes in a sequence\r\n *   (e.g. `\"h o''clock\"`).\r\n *\r\n * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or\r\n *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its\r\n *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is\r\n *    specified in the string input, the time is considered to be in the local timezone.\r\n * @param {string=} format Formatting rules (see Description). If not specified,\r\n *    `mediumDate` is used.\r\n * @returns {string} Formatted string or the input if input is not recognized as date/millis.\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:\r\n           {{1288323623006 | date:'medium'}}<br>\r\n       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:\r\n          {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>\r\n       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:\r\n          {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should format date', function() {\r\n         expect(binding(\"1288323623006 | date:'medium'\")).\r\n            toMatch(/Oct 2\\d, 2010 \\d{1,2}:\\d{2}:\\d{2} (AM|PM)/);\r\n         expect(binding(\"1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'\")).\r\n            toMatch(/2010\\-10\\-2\\d \\d{2}:\\d{2}:\\d{2} (\\-|\\+)?\\d{4}/);\r\n         expect(binding(\"'1288323623006' | date:'MM/dd/yyyy @ h:mma'\")).\r\n            toMatch(/10\\/2\\d\\/2010 @ \\d{1,2}:\\d{2}(AM|PM)/);\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\ndateFilter.$inject = ['$locale'];\r\nfunction dateFilter($locale) {\r\n\r\n\r\n  var R_ISO8601_STR = /^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;\r\n                     // 1        2       3         4          5          6          7          8  9     10      11\r\n  function jsonStringToDate(string) {\r\n    var match;\r\n    if (match = string.match(R_ISO8601_STR)) {\r\n      var date = new Date(0),\r\n          tzHour = 0,\r\n          tzMin  = 0,\r\n          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,\r\n          timeSetter = match[8] ? date.setUTCHours : date.setHours;\r\n\r\n      if (match[9]) {\r\n        tzHour = int(match[9] + match[10]);\r\n        tzMin = int(match[9] + match[11]);\r\n      }\r\n      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));\r\n      var h = int(match[4]||0) - tzHour;\r\n      var m = int(match[5]||0) - tzMin\r\n      var s = int(match[6]||0);\r\n      var ms = Math.round(parseFloat('0.' + (match[7]||0)) * 1000);\r\n      timeSetter.call(date, h, m, s, ms);\r\n      return date;\r\n    }\r\n    return string;\r\n  }\r\n\r\n\r\n  return function(date, format) {\r\n    var text = '',\r\n        parts = [],\r\n        fn, match;\r\n\r\n    format = format || 'mediumDate';\r\n    format = $locale.DATETIME_FORMATS[format] || format;\r\n    if (isString(date)) {\r\n      if (NUMBER_STRING.test(date)) {\r\n        date = int(date);\r\n      } else {\r\n        date = jsonStringToDate(date);\r\n      }\r\n    }\r\n\r\n    if (isNumber(date)) {\r\n      date = new Date(date);\r\n    }\r\n\r\n    if (!isDate(date)) {\r\n      return date;\r\n    }\r\n\r\n    while(format) {\r\n      match = DATE_FORMATS_SPLIT.exec(format);\r\n      if (match) {\r\n        parts = concat(parts, match, 1);\r\n        format = parts.pop();\r\n      } else {\r\n        parts.push(format);\r\n        format = null;\r\n      }\r\n    }\r\n\r\n    forEach(parts, function(value){\r\n      fn = DATE_FORMATS[value];\r\n      text += fn ? fn(date, $locale.DATETIME_FORMATS)\r\n                 : value.replace(/(^'|'$)/g, '').replace(/''/g, \"'\");\r\n    });\r\n\r\n    return text;\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc filter\r\n * @name ng.filter:json\r\n * @function\r\n *\r\n * @description\r\n *   Allows you to convert a JavaScript object into JSON string.\r\n *\r\n *   This filter is mostly useful for debugging. When using the double curly {{value}} notation\r\n *   the binding is automatically converted to JSON.\r\n *\r\n * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.\r\n * @returns {string} JSON string.\r\n *\r\n *\r\n * @example:\r\n   <doc:example>\r\n     <doc:source>\r\n       <pre>{{ {'name':'value'} | json }}</pre>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should jsonify filtered objects', function() {\r\n         expect(binding(\"{'name':'value'}\")).toMatch(/\\{\\n  \"name\": ?\"value\"\\n}/);\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n *\r\n */\r\nfunction jsonFilter() {\r\n  return function(object) {\r\n    return toJson(object, true);\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc filter\r\n * @name ng.filter:lowercase\r\n * @function\r\n * @description\r\n * Converts string to lowercase.\r\n * @see angular.lowercase\r\n */\r\nvar lowercaseFilter = valueFn(lowercase);\r\n\r\n\r\n/**\r\n * @ngdoc filter\r\n * @name ng.filter:uppercase\r\n * @function\r\n * @description\r\n * Converts string to uppercase.\r\n * @see angular.uppercase\r\n */\r\nvar uppercaseFilter = valueFn(uppercase);\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.filter:limitTo\r\n * @function\r\n *\r\n * @description\r\n * Creates a new array or string containing only a specified number of elements. The elements\r\n * are taken from either the beginning or the end of the source array or string, as specified by\r\n * the value and sign (positive or negative) of `limit`.\r\n *\r\n * Note: This function is used to augment the `Array` type in Angular expressions. See\r\n * {@link ng.$filter} for more information about Angular arrays.\r\n *\r\n * @param {Array|string} input Source array or string to be limited.\r\n * @param {string|number} limit The length of the returned array or string. If the `limit` number \r\n *     is positive, `limit` number of items from the beginning of the source array/string are copied.\r\n *     If the number is negative, `limit` number  of items from the end of the source array/string \r\n *     are copied. The `limit` will be trimmed if it exceeds `array.length`\r\n * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array\r\n *     had less than `limit` elements.\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.numbers = [1,2,3,4,5,6,7,8,9];\r\n           $scope.letters = \"abcdefghi\";\r\n           $scope.numLimit = 3;\r\n           $scope.letterLimit = 3;\r\n         }\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n         Limit {{numbers}} to: <input type=\"integer\" ng-model=\"numLimit\">\r\n         <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>\r\n         Limit {{letters}} to: <input type=\"integer\" ng-model=\"letterLimit\">\r\n         <p>Output letters: {{ letters | limitTo:letterLimit }}</p>\r\n       </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should limit the number array to first three items', function() {\r\n         expect(element('.doc-example-live input[ng-model=numLimit]').val()).toBe('3');\r\n         expect(element('.doc-example-live input[ng-model=letterLimit]').val()).toBe('3');\r\n         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3]');\r\n         expect(binding('letters | limitTo:letterLimit')).toEqual('abc');\r\n       });\r\n\r\n       it('should update the output when -3 is entered', function() {\r\n         input('numLimit').enter(-3);\r\n         input('letterLimit').enter(-3);\r\n         expect(binding('numbers | limitTo:numLimit')).toEqual('[7,8,9]');\r\n         expect(binding('letters | limitTo:letterLimit')).toEqual('ghi');\r\n       });\r\n\r\n       it('should not exceed the maximum size of input array', function() {\r\n         input('numLimit').enter(100);\r\n         input('letterLimit').enter(100);\r\n         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3,4,5,6,7,8,9]');\r\n         expect(binding('letters | limitTo:letterLimit')).toEqual('abcdefghi');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\nfunction limitToFilter(){\r\n  return function(input, limit) {\r\n    if (!isArray(input) && !isString(input)) return input;\r\n    \r\n    limit = int(limit);\r\n\r\n    if (isString(input)) {\r\n      //NaN check on limit\r\n      if (limit) {\r\n        return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);\r\n      } else {\r\n        return \"\";\r\n      }\r\n    }\r\n\r\n    var out = [],\r\n      i, n;\r\n\r\n    // if abs(limit) exceeds maximum length, trim it\r\n    if (limit > input.length)\r\n      limit = input.length;\r\n    else if (limit < -input.length)\r\n      limit = -input.length;\r\n\r\n    if (limit > 0) {\r\n      i = 0;\r\n      n = limit;\r\n    } else {\r\n      i = input.length + limit;\r\n      n = input.length;\r\n    }\r\n\r\n    for (; i<n; i++) {\r\n      out.push(input[i]);\r\n    }\r\n\r\n    return out;\r\n  }\r\n}\r\n\r\n/**\r\n * @ngdoc function\r\n * @name ng.filter:orderBy\r\n * @function\r\n *\r\n * @description\r\n * Orders a specified `array` by the `expression` predicate.\r\n *\r\n * Note: this function is used to augment the `Array` type in Angular expressions. See\r\n * {@link ng.$filter} for more information about Angular arrays.\r\n *\r\n * @param {Array} array The array to sort.\r\n * @param {function(*)|string|Array.<(function(*)|string)>} expression A predicate to be\r\n *    used by the comparator to determine the order of elements.\r\n *\r\n *    Can be one of:\r\n *\r\n *    - `function`: Getter function. The result of this function will be sorted using the\r\n *      `<`, `=`, `>` operator.\r\n *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'\r\n *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control\r\n *      ascending or descending sort order (for example, +name or -name).\r\n *    - `Array`: An array of function or string predicates. The first predicate in the array\r\n *      is used for sorting, but when two items are equivalent, the next predicate is used.\r\n *\r\n * @param {boolean=} reverse Reverse the order the array.\r\n * @returns {Array} Sorted copy of the source array.\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.friends =\r\n               [{name:'John', phone:'555-1212', age:10},\r\n                {name:'Mary', phone:'555-9876', age:19},\r\n                {name:'Mike', phone:'555-4321', age:21},\r\n                {name:'Adam', phone:'555-5678', age:35},\r\n                {name:'Julie', phone:'555-8765', age:29}]\r\n           $scope.predicate = '-age';\r\n         }\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>\r\n         <hr/>\r\n         [ <a href=\"\" ng-click=\"predicate=''\">unsorted</a> ]\r\n         <table class=\"friend\">\r\n           <tr>\r\n             <th><a href=\"\" ng-click=\"predicate = 'name'; reverse=false\">Name</a>\r\n                 (<a href ng-click=\"predicate = '-name'; reverse=false\">^</a>)</th>\r\n             <th><a href=\"\" ng-click=\"predicate = 'phone'; reverse=!reverse\">Phone Number</a></th>\r\n             <th><a href=\"\" ng-click=\"predicate = 'age'; reverse=!reverse\">Age</a></th>\r\n           </tr>\r\n           <tr ng-repeat=\"friend in friends | orderBy:predicate:reverse\">\r\n             <td>{{friend.name}}</td>\r\n             <td>{{friend.phone}}</td>\r\n             <td>{{friend.age}}</td>\r\n           </tr>\r\n         </table>\r\n       </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should be reverse ordered by aged', function() {\r\n         expect(binding('predicate')).toBe('-age');\r\n         expect(repeater('table.friend', 'friend in friends').column('friend.age')).\r\n           toEqual(['35', '29', '21', '19', '10']);\r\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\r\n           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);\r\n       });\r\n\r\n       it('should reorder the table when user selects different predicate', function() {\r\n         element('.doc-example-live a:contains(\"Name\")').click();\r\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\r\n           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);\r\n         expect(repeater('table.friend', 'friend in friends').column('friend.age')).\r\n           toEqual(['35', '10', '29', '19', '21']);\r\n\r\n         element('.doc-example-live a:contains(\"Phone\")').click();\r\n         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).\r\n           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);\r\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\r\n           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\norderByFilter.$inject = ['$parse'];\r\nfunction orderByFilter($parse){\r\n  return function(array, sortPredicate, reverseOrder) {\r\n    if (!isArray(array)) return array;\r\n    if (!sortPredicate) return array;\r\n    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];\r\n    sortPredicate = map(sortPredicate, function(predicate){\r\n      var descending = false, get = predicate || identity;\r\n      if (isString(predicate)) {\r\n        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {\r\n          descending = predicate.charAt(0) == '-';\r\n          predicate = predicate.substring(1);\r\n        }\r\n        get = $parse(predicate);\r\n      }\r\n      return reverseComparator(function(a,b){\r\n        return compare(get(a),get(b));\r\n      }, descending);\r\n    });\r\n    var arrayCopy = [];\r\n    for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }\r\n    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));\r\n\r\n    function comparator(o1, o2){\r\n      for ( var i = 0; i < sortPredicate.length; i++) {\r\n        var comp = sortPredicate[i](o1, o2);\r\n        if (comp !== 0) return comp;\r\n      }\r\n      return 0;\r\n    }\r\n    function reverseComparator(comp, descending) {\r\n      return toBoolean(descending)\r\n          ? function(a,b){return comp(b,a);}\r\n          : comp;\r\n    }\r\n    function compare(v1, v2){\r\n      var t1 = typeof v1;\r\n      var t2 = typeof v2;\r\n      if (t1 == t2) {\r\n        if (t1 == \"string\") v1 = v1.toLowerCase();\r\n        if (t1 == \"string\") v2 = v2.toLowerCase();\r\n        if (v1 === v2) return 0;\r\n        return v1 < v2 ? -1 : 1;\r\n      } else {\r\n        return t1 < t2 ? -1 : 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction ngDirective(directive) {\r\n  if (isFunction(directive)) {\r\n    directive = {\r\n      link: directive\r\n    }\r\n  }\r\n  directive.restrict = directive.restrict || 'AC';\r\n  return valueFn(directive);\r\n}\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:a\r\n * @restrict E\r\n *\r\n * @description\r\n * Modifies the default behavior of html A tag, so that the default action is prevented when href\r\n * attribute is empty.\r\n *\r\n * The reasoning for this change is to allow easy creation of action links with `ngClick` directive\r\n * without changing the location or causing page reloads, e.g.:\r\n * `<a href=\"\" ng-click=\"model.$save()\">Save</a>`\r\n */\r\nvar htmlAnchorDirective = valueFn({\r\n  restrict: 'E',\r\n  compile: function(element, attr) {\r\n\r\n    if (msie <= 8) {\r\n\r\n      // turn <a href ng-click=\"..\">link</a> into a stylable link in IE\r\n      // but only if it doesn't have name attribute, in which case it's an anchor\r\n      if (!attr.href && !attr.name) {\r\n        attr.$set('href', '');\r\n      }\r\n\r\n      // add a comment node to anchors to workaround IE bug that causes element content to be reset\r\n      // to new attribute content if attribute is updated with value containing @ and element also\r\n      // contains value with @\r\n      // see issue #1949\r\n      element.append(document.createComment('IE fix'));\r\n    }\r\n\r\n    return function(scope, element) {\r\n      element.bind('click', function(event){\r\n        // if we have no href url, then don't navigate anywhere.\r\n        if (!element.attr('href')) {\r\n          event.preventDefault();\r\n        }\r\n      });\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngHref\r\n * @restrict A\r\n *\r\n * @description\r\n * Using Angular markup like {{hash}} in an href attribute makes\r\n * the page open to a wrong URL, if the user clicks that link before\r\n * angular has a chance to replace the {{hash}} with actual URL, the\r\n * link will be broken and will most likely return a 404 error.\r\n * The `ngHref` directive solves this problem.\r\n *\r\n * The buggy way to write it:\r\n * <pre>\r\n * <a href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\r\n * </pre>\r\n *\r\n * The correct way to write it:\r\n * <pre>\r\n * <a ng-href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\r\n * </pre>\r\n *\r\n * @element A\r\n * @param {template} ngHref any string which can contain `{{}}` markup.\r\n *\r\n * @example\r\n * This example uses `link` variable inside `href` attribute:\r\n    <doc:example>\r\n      <doc:source>\r\n        <input ng-model=\"value\" /><br />\r\n        <a id=\"link-1\" href ng-click=\"value = 1\">link 1</a> (link, don't reload)<br />\r\n        <a id=\"link-2\" href=\"\" ng-click=\"value = 2\">link 2</a> (link, don't reload)<br />\r\n        <a id=\"link-3\" ng-href=\"/{{'123'}}\">link 3</a> (link, reload!)<br />\r\n        <a id=\"link-4\" href=\"\" name=\"xx\" ng-click=\"value = 4\">anchor</a> (link, don't reload)<br />\r\n        <a id=\"link-5\" name=\"xxx\" ng-click=\"value = 5\">anchor</a> (no link)<br />\r\n        <a id=\"link-6\" ng-href=\"{{value}}\">link</a> (link, change location)\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should execute ng-click but not reload when href without value', function() {\r\n          element('#link-1').click();\r\n          expect(input('value').val()).toEqual('1');\r\n          expect(element('#link-1').attr('href')).toBe(\"\");\r\n        });\r\n\r\n        it('should execute ng-click but not reload when href empty string', function() {\r\n          element('#link-2').click();\r\n          expect(input('value').val()).toEqual('2');\r\n          expect(element('#link-2').attr('href')).toBe(\"\");\r\n        });\r\n\r\n        it('should execute ng-click and change url when ng-href specified', function() {\r\n          expect(element('#link-3').attr('href')).toBe(\"/123\");\r\n\r\n          element('#link-3').click();\r\n          expect(browser().window().path()).toEqual('/123');\r\n        });\r\n\r\n        it('should execute ng-click but not reload when href empty string and name specified', function() {\r\n          element('#link-4').click();\r\n          expect(input('value').val()).toEqual('4');\r\n          expect(element('#link-4').attr('href')).toBe('');\r\n        });\r\n\r\n        it('should execute ng-click but not reload when no href but name specified', function() {\r\n          element('#link-5').click();\r\n          expect(input('value').val()).toEqual('5');\r\n          expect(element('#link-5').attr('href')).toBe(undefined);\r\n        });\r\n\r\n        it('should only change url when only ng-href', function() {\r\n          input('value').enter('6');\r\n          expect(element('#link-6').attr('href')).toBe('6');\r\n\r\n          element('#link-6').click();\r\n          expect(browser().location().url()).toEqual('/6');\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n */\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngSrc\r\n * @restrict A\r\n *\r\n * @description\r\n * Using Angular markup like `{{hash}}` in a `src` attribute doesn't\r\n * work right: The browser will fetch from the URL with the literal\r\n * text `{{hash}}` until Angular replaces the expression inside\r\n * `{{hash}}`. The `ngSrc` directive solves this problem.\r\n *\r\n * The buggy way to write it:\r\n * <pre>\r\n * <img src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\r\n * </pre>\r\n *\r\n * The correct way to write it:\r\n * <pre>\r\n * <img ng-src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\r\n * </pre>\r\n *\r\n * @element IMG\r\n * @param {template} ngSrc any string which can contain `{{}}` markup.\r\n */\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngSrcset\r\n * @restrict A\r\n *\r\n * @description\r\n * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't\r\n * work right: The browser will fetch from the URL with the literal\r\n * text `{{hash}}` until Angular replaces the expression inside\r\n * `{{hash}}`. The `ngSrcset` directive solves this problem.\r\n *\r\n * The buggy way to write it:\r\n * <pre>\r\n * <img srcset=\"http://www.gravatar.com/avatar/{{hash}} 2x\"/>\r\n * </pre>\r\n *\r\n * The correct way to write it:\r\n * <pre>\r\n * <img ng-srcset=\"http://www.gravatar.com/avatar/{{hash}} 2x\"/>\r\n * </pre>\r\n *\r\n * @element IMG\r\n * @param {template} ngSrcset any string which can contain `{{}}` markup.\r\n */\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngDisabled\r\n * @restrict A\r\n *\r\n * @description\r\n *\r\n * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:\r\n * <pre>\r\n * <div ng-init=\"scope = { isDisabled: false }\">\r\n *  <button disabled=\"{{scope.isDisabled}}\">Disabled</button>\r\n * </div>\r\n * </pre>\r\n *\r\n * The HTML specs do not require browsers to preserve the special attributes such as disabled.\r\n * (The presence of them means true and absence means false)\r\n * This prevents the angular compiler from correctly retrieving the binding expression.\r\n * To solve this problem, we introduce the `ngDisabled` directive.\r\n *\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n        Click me to toggle: <input type=\"checkbox\" ng-model=\"checked\"><br/>\r\n        <button ng-model=\"button\" ng-disabled=\"checked\">Button</button>\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should toggle button', function() {\r\n          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();\r\n          input('checked').check();\r\n          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n *\r\n * @element INPUT\r\n * @param {expression} ngDisabled Angular expression that will be evaluated.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngChecked\r\n * @restrict A\r\n *\r\n * @description\r\n * The HTML specs do not require browsers to preserve the special attributes such as checked.\r\n * (The presence of them means true and absence means false)\r\n * This prevents the angular compiler from correctly retrieving the binding expression.\r\n * To solve this problem, we introduce the `ngChecked` directive.\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n        Check me to check both: <input type=\"checkbox\" ng-model=\"master\"><br/>\r\n        <input id=\"checkSlave\" type=\"checkbox\" ng-checked=\"master\">\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should check both checkBoxes', function() {\r\n          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();\r\n          input('master').check();\r\n          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n *\r\n * @element INPUT\r\n * @param {expression} ngChecked Angular expression that will be evaluated.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngMultiple\r\n * @restrict A\r\n *\r\n * @description\r\n * The HTML specs do not require browsers to preserve the special attributes such as multiple.\r\n * (The presence of them means true and absence means false)\r\n * This prevents the angular compiler from correctly retrieving the binding expression.\r\n * To solve this problem, we introduce the `ngMultiple` directive.\r\n *\r\n * @example\r\n     <doc:example>\r\n       <doc:source>\r\n         Check me check multiple: <input type=\"checkbox\" ng-model=\"checked\"><br/>\r\n         <select id=\"select\" ng-multiple=\"checked\">\r\n           <option>Misko</option>\r\n           <option>Igor</option>\r\n           <option>Vojta</option>\r\n           <option>Di</option>\r\n         </select>\r\n       </doc:source>\r\n       <doc:scenario>\r\n         it('should toggle multiple', function() {\r\n           expect(element('.doc-example-live #select').prop('multiple')).toBeFalsy();\r\n           input('checked').check();\r\n           expect(element('.doc-example-live #select').prop('multiple')).toBeTruthy();\r\n         });\r\n       </doc:scenario>\r\n     </doc:example>\r\n *\r\n * @element SELECT\r\n * @param {expression} ngMultiple Angular expression that will be evaluated.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngReadonly\r\n * @restrict A\r\n *\r\n * @description\r\n * The HTML specs do not require browsers to preserve the special attributes such as readonly.\r\n * (The presence of them means true and absence means false)\r\n * This prevents the angular compiler from correctly retrieving the binding expression.\r\n * To solve this problem, we introduce the `ngReadonly` directive.\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n        Check me to make text readonly: <input type=\"checkbox\" ng-model=\"checked\"><br/>\r\n        <input type=\"text\" ng-readonly=\"checked\" value=\"I'm Angular\"/>\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should toggle readonly attr', function() {\r\n          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();\r\n          input('checked').check();\r\n          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n *\r\n * @element INPUT\r\n * @param {string} expression Angular expression that will be evaluated.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngSelected\r\n * @restrict A\r\n *\r\n * @description\r\n * The HTML specs do not require browsers to preserve the special attributes such as selected.\r\n * (The presence of them means true and absence means false)\r\n * This prevents the angular compiler from correctly retrieving the binding expression.\r\n * To solve this problem, we introduced the `ngSelected` directive.\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n        Check me to select: <input type=\"checkbox\" ng-model=\"selected\"><br/>\r\n        <select>\r\n          <option>Hello!</option>\r\n          <option id=\"greet\" ng-selected=\"selected\">Greetings!</option>\r\n        </select>\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should select Greetings!', function() {\r\n          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();\r\n          input('selected').check();\r\n          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n *\r\n * @element OPTION\r\n * @param {string} expression Angular expression that will be evaluated.\r\n */\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngOpen\r\n * @restrict A\r\n *\r\n * @description\r\n * The HTML specs do not require browsers to preserve the special attributes such as open.\r\n * (The presence of them means true and absence means false)\r\n * This prevents the angular compiler from correctly retrieving the binding expression.\r\n * To solve this problem, we introduce the `ngOpen` directive.\r\n *\r\n * @example\r\n     <doc:example>\r\n       <doc:source>\r\n         Check me check multiple: <input type=\"checkbox\" ng-model=\"open\"><br/>\r\n         <details id=\"details\" ng-open=\"open\">\r\n            <summary>Show/Hide me</summary>\r\n         </details>\r\n       </doc:source>\r\n       <doc:scenario>\r\n         it('should toggle open', function() {\r\n           expect(element('#details').prop('open')).toBeFalsy();\r\n           input('open').check();\r\n           expect(element('#details').prop('open')).toBeTruthy();\r\n         });\r\n       </doc:scenario>\r\n     </doc:example>\r\n *\r\n * @element DETAILS\r\n * @param {string} expression Angular expression that will be evaluated.\r\n */\r\n\r\nvar ngAttributeAliasDirectives = {};\r\n\r\n\r\n// boolean attrs are evaluated\r\nforEach(BOOLEAN_ATTR, function(propName, attrName) {\r\n  var normalized = directiveNormalize('ng-' + attrName);\r\n  ngAttributeAliasDirectives[normalized] = function() {\r\n    return {\r\n      priority: 100,\r\n      compile: function() {\r\n        return function(scope, element, attr) {\r\n          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {\r\n            attr.$set(attrName, !!value);\r\n          });\r\n        };\r\n      }\r\n    };\r\n  };\r\n});\r\n\r\n\r\n// ng-src, ng-srcset, ng-href are interpolated\r\nforEach(['src', 'srcset', 'href'], function(attrName) {\r\n  var normalized = directiveNormalize('ng-' + attrName);\r\n  ngAttributeAliasDirectives[normalized] = function() {\r\n    return {\r\n      priority: 99, // it needs to run after the attributes are interpolated\r\n      link: function(scope, element, attr) {\r\n        attr.$observe(normalized, function(value) {\r\n          if (!value)\r\n             return;\r\n\r\n          attr.$set(attrName, value);\r\n\r\n          // on IE, if \"ng:src\" directive declaration is used and \"src\" attribute doesn't exist\r\n          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need\r\n          // to set the property as well to achieve the desired effect.\r\n          // we use attr[attrName] value since $set can sanitize the url.\r\n          if (msie) element.prop(attrName, attr[attrName]);\r\n        });\r\n      }\r\n    };\r\n  };\r\n});\r\n\r\nvar nullFormCtrl = {\r\n  $addControl: noop,\r\n  $removeControl: noop,\r\n  $setValidity: noop,\r\n  $setDirty: noop,\r\n  $setPristine: noop\r\n};\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.directive:form.FormController\r\n *\r\n * @property {boolean} $pristine True if user has not interacted with the form yet.\r\n * @property {boolean} $dirty True if user has already interacted with the form.\r\n * @property {boolean} $valid True if all of the containing forms and controls are valid.\r\n * @property {boolean} $invalid True if at least one containing control or form is invalid.\r\n *\r\n * @property {Object} $error Is an object hash, containing references to all invalid controls or\r\n *  forms, where:\r\n *\r\n *  - keys are validation tokens (error names)  such as `required`, `url` or `email`),\r\n *  - values are arrays of controls or forms that are invalid with given error.\r\n *\r\n * @description\r\n * `FormController` keeps track of all its controls and nested forms as well as state of them,\r\n * such as being valid/invalid or dirty/pristine.\r\n *\r\n * Each {@link ng.directive:form form} directive creates an instance\r\n * of `FormController`.\r\n *\r\n */\r\n//asks for $scope to fool the BC controller module\r\nFormController.$inject = ['$element', '$attrs', '$scope'];\r\nfunction FormController(element, attrs) {\r\n  var form = this,\r\n      parentForm = element.parent().controller('form') || nullFormCtrl,\r\n      invalidCount = 0, // used to easily determine if we are valid\r\n      errors = form.$error = {},\r\n      controls = [];\r\n\r\n  // init state\r\n  form.$name = attrs.name;\r\n  form.$dirty = false;\r\n  form.$pristine = true;\r\n  form.$valid = true;\r\n  form.$invalid = false;\r\n\r\n  parentForm.$addControl(form);\r\n\r\n  // Setup initial state of the control\r\n  element.addClass(PRISTINE_CLASS);\r\n  toggleValidCss(true);\r\n\r\n  // convenience method for easy toggling of classes\r\n  function toggleValidCss(isValid, validationErrorKey) {\r\n    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';\r\n    element.\r\n      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).\r\n      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);\r\n  }\r\n\r\n  form.$addControl = function(control) {\r\n    controls.push(control);\r\n\r\n    if (control.$name && !form.hasOwnProperty(control.$name)) {\r\n      form[control.$name] = control;\r\n    }\r\n  };\r\n\r\n  form.$removeControl = function(control) {\r\n    if (control.$name && form[control.$name] === control) {\r\n      delete form[control.$name];\r\n    }\r\n    forEach(errors, function(queue, validationToken) {\r\n      form.$setValidity(validationToken, true, control);\r\n    });\r\n\r\n    arrayRemove(controls, control);\r\n  };\r\n\r\n  form.$setValidity = function(validationToken, isValid, control) {\r\n    var queue = errors[validationToken];\r\n\r\n    if (isValid) {\r\n      if (queue) {\r\n        arrayRemove(queue, control);\r\n        if (!queue.length) {\r\n          invalidCount--;\r\n          if (!invalidCount) {\r\n            toggleValidCss(isValid);\r\n            form.$valid = true;\r\n            form.$invalid = false;\r\n          }\r\n          errors[validationToken] = false;\r\n          toggleValidCss(true, validationToken);\r\n          parentForm.$setValidity(validationToken, true, form);\r\n        }\r\n      }\r\n\r\n    } else {\r\n      if (!invalidCount) {\r\n        toggleValidCss(isValid);\r\n      }\r\n      if (queue) {\r\n        if (includes(queue, control)) return;\r\n      } else {\r\n        errors[validationToken] = queue = [];\r\n        invalidCount++;\r\n        toggleValidCss(false, validationToken);\r\n        parentForm.$setValidity(validationToken, false, form);\r\n      }\r\n      queue.push(control);\r\n\r\n      form.$valid = false;\r\n      form.$invalid = true;\r\n    }\r\n  };\r\n\r\n  form.$setDirty = function() {\r\n    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);\r\n    form.$dirty = true;\r\n    form.$pristine = false;\r\n    parentForm.$setDirty();\r\n  };\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.directive:form.FormController#$setPristine\r\n   * @methodOf ng.directive:form.FormController\r\n   *\r\n   * @description\r\n   * Sets the form to its pristine state.\r\n   *\r\n   * This method can be called to remove the 'ng-dirty' class and set the form to its pristine\r\n   * state (ng-pristine class). This method will also propagate to all the controls contained\r\n   * in this form.\r\n   *\r\n   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after\r\n   * saving or resetting it.\r\n   */\r\n  form.$setPristine = function () {\r\n    element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);\r\n    form.$dirty = false;\r\n    form.$pristine = true;\r\n    forEach(controls, function(control) {\r\n      control.$setPristine();\r\n    });\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngForm\r\n * @restrict EAC\r\n *\r\n * @description\r\n * Nestable alias of {@link ng.directive:form `form`} directive. HTML\r\n * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a\r\n * sub-group of controls needs to be determined.\r\n *\r\n * @param {string=} name|ngForm Name of the form. If specified, the form controller will be published into\r\n *                       related scope, under this name.\r\n *\r\n */\r\n\r\n /**\r\n * @ngdoc directive\r\n * @name ng.directive:form\r\n * @restrict E\r\n *\r\n * @description\r\n * Directive that instantiates\r\n * {@link ng.directive:form.FormController FormController}.\r\n *\r\n * If `name` attribute is specified, the form controller is published onto the current scope under\r\n * this name.\r\n *\r\n * # Alias: {@link ng.directive:ngForm `ngForm`}\r\n *\r\n * In angular forms can be nested. This means that the outer form is valid when all of the child\r\n * forms are valid as well. However browsers do not allow nesting of `<form>` elements, for this\r\n * reason angular provides {@link ng.directive:ngForm `ngForm`} alias\r\n * which behaves identical to `<form>` but allows form nesting.\r\n *\r\n *\r\n * # CSS classes\r\n *  - `ng-valid` Is set if the form is valid.\r\n *  - `ng-invalid` Is set if the form is invalid.\r\n *  - `ng-pristine` Is set if the form is pristine.\r\n *  - `ng-dirty` Is set if the form is dirty.\r\n *\r\n *\r\n * # Submitting a form and preventing default action\r\n *\r\n * Since the role of forms in client-side Angular applications is different than in classical\r\n * roundtrip apps, it is desirable for the browser not to translate the form submission into a full\r\n * page reload that sends the data to the server. Instead some javascript logic should be triggered\r\n * to handle the form submission in application specific way.\r\n *\r\n * For this reason, Angular prevents the default action (form submission to the server) unless the\r\n * `<form>` element has an `action` attribute specified.\r\n *\r\n * You can use one of the following two ways to specify what javascript method should be called when\r\n * a form is submitted:\r\n *\r\n * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element\r\n * - {@link ng.directive:ngClick ngClick} directive on the first\r\n  *  button or input field of type submit (input[type=submit])\r\n *\r\n * To prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This\r\n * is because of the following form submission rules coming from the html spec:\r\n *\r\n * - If a form has only one input field then hitting enter in this field triggers form submit\r\n * (`ngSubmit`)\r\n * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter\r\n * doesn't trigger submit\r\n * - if a form has one or more input fields and one or more buttons or input[type=submit] then\r\n * hitting enter in any of the input fields will trigger the click handler on the *first* button or\r\n * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)\r\n *\r\n * @param {string=} name Name of the form. If specified, the form controller will be published into\r\n *                       related scope, under this name.\r\n *\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.userType = 'guest';\r\n         }\r\n       </script>\r\n       <form name=\"myForm\" ng-controller=\"Ctrl\">\r\n         userType: <input name=\"input\" ng-model=\"userType\" required>\r\n         <span class=\"error\" ng-show=\"myForm.input.$error.required\">Required!</span><br>\r\n         <tt>userType = {{userType}}</tt><br>\r\n         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>\r\n         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>\r\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>\r\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>\r\n        </form>\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should initialize to model', function() {\r\n         expect(binding('userType')).toEqual('guest');\r\n         expect(binding('myForm.input.$valid')).toEqual('true');\r\n        });\r\n\r\n        it('should be invalid if empty', function() {\r\n         input('userType').enter('');\r\n         expect(binding('userType')).toEqual('');\r\n         expect(binding('myForm.input.$valid')).toEqual('false');\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n */\r\nvar formDirectiveFactory = function(isNgForm) {\r\n  return ['$timeout', function($timeout) {\r\n    var formDirective = {\r\n      name: 'form',\r\n      restrict: 'E',\r\n      controller: FormController,\r\n      compile: function() {\r\n        return {\r\n          pre: function(scope, formElement, attr, controller) {\r\n            if (!attr.action) {\r\n              // we can't use jq events because if a form is destroyed during submission the default\r\n              // action is not prevented. see #1238\r\n              //\r\n              // IE 9 is not affected because it doesn't fire a submit event and try to do a full\r\n              // page reload if the form was destroyed by submission of the form via a click handler\r\n              // on a button in the form. Looks like an IE9 specific bug.\r\n              var preventDefaultListener = function(event) {\r\n                event.preventDefault\r\n                  ? event.preventDefault()\r\n                  : event.returnValue = false; // IE\r\n              };\r\n\r\n              addEventListenerFn(formElement[0], 'submit', preventDefaultListener);\r\n\r\n              // unregister the preventDefault listener so that we don't not leak memory but in a\r\n              // way that will achieve the prevention of the default action.\r\n              formElement.bind('$destroy', function() {\r\n                $timeout(function() {\r\n                  removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);\r\n                }, 0, false);\r\n              });\r\n            }\r\n\r\n            var parentFormCtrl = formElement.parent().controller('form'),\r\n                alias = attr.name || attr.ngForm;\r\n\r\n            if (alias) {\r\n              scope[alias] = controller;\r\n            }\r\n            if (parentFormCtrl) {\r\n              formElement.bind('$destroy', function() {\r\n                parentFormCtrl.$removeControl(controller);\r\n                if (alias) {\r\n                  scope[alias] = undefined;\r\n                }\r\n                extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards\r\n              });\r\n            }\r\n          }\r\n        };\r\n      }\r\n    };\r\n\r\n    return isNgForm ? extend(copy(formDirective), {restrict: 'EAC'}) : formDirective;\r\n  }];\r\n};\r\n\r\nvar formDirective = formDirectiveFactory();\r\nvar ngFormDirective = formDirectiveFactory(true);\r\n\r\nvar URL_REGEXP = /^(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/;\r\nvar EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$/;\r\nvar NUMBER_REGEXP = /^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))\\s*$/;\r\n\r\nvar inputType = {\r\n\r\n  /**\r\n   * @ngdoc inputType\r\n   * @name ng.directive:input.text\r\n   *\r\n   * @description\r\n   * Standard HTML text input with angular data binding.\r\n   *\r\n   * @param {string} ngModel Assignable angular expression to data-bind to.\r\n   * @param {string=} name Property name of the form under which the control is published.\r\n   * @param {string=} required Adds `required` validation error key if the value is not entered.\r\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\r\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\r\n   *    `required` when you want to data-bind to the `required` attribute.\r\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\r\n   *    minlength.\r\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\r\n   *    maxlength.\r\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\r\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\r\n   *    patterns defined as scope expressions.\r\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\r\n   *    interaction with the input element.\r\n   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trimming the\r\n   *    input.\r\n   *\r\n   * @example\r\n      <doc:example>\r\n        <doc:source>\r\n         <script>\r\n           function Ctrl($scope) {\r\n             $scope.text = 'guest';\r\n             $scope.word = /^\\s*\\w*\\s*$/;\r\n           }\r\n         </script>\r\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\r\n           Single word: <input type=\"text\" name=\"input\" ng-model=\"text\"\r\n                               ng-pattern=\"word\" required ng-trim=\"false\">\r\n           <span class=\"error\" ng-show=\"myForm.input.$error.required\">\r\n             Required!</span>\r\n           <span class=\"error\" ng-show=\"myForm.input.$error.pattern\">\r\n             Single word only!</span>\r\n\r\n           <tt>text = {{text}}</tt><br/>\r\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\r\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\r\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\r\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\r\n          </form>\r\n        </doc:source>\r\n        <doc:scenario>\r\n          it('should initialize to model', function() {\r\n            expect(binding('text')).toEqual('guest');\r\n            expect(binding('myForm.input.$valid')).toEqual('true');\r\n          });\r\n\r\n          it('should be invalid if empty', function() {\r\n            input('text').enter('');\r\n            expect(binding('text')).toEqual('');\r\n            expect(binding('myForm.input.$valid')).toEqual('false');\r\n          });\r\n\r\n          it('should be invalid if multi word', function() {\r\n            input('text').enter('hello world');\r\n            expect(binding('myForm.input.$valid')).toEqual('false');\r\n          });\r\n\r\n          it('should not be trimmed', function() {\r\n            input('text').enter('untrimmed ');\r\n            expect(binding('text')).toEqual('untrimmed ');\r\n            expect(binding('myForm.input.$valid')).toEqual('true');\r\n          });\r\n        </doc:scenario>\r\n      </doc:example>\r\n   */\r\n  'text': textInputType,\r\n\r\n\r\n  /**\r\n   * @ngdoc inputType\r\n   * @name ng.directive:input.number\r\n   *\r\n   * @description\r\n   * Text input with number validation and transformation. Sets the `number` validation\r\n   * error if not a valid number.\r\n   *\r\n   * @param {string} ngModel Assignable angular expression to data-bind to.\r\n   * @param {string=} name Property name of the form under which the control is published.\r\n   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.\r\n   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.\r\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\r\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\r\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\r\n   *    `required` when you want to data-bind to the `required` attribute.\r\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\r\n   *    minlength.\r\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\r\n   *    maxlength.\r\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\r\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\r\n   *    patterns defined as scope expressions.\r\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\r\n   *    interaction with the input element.\r\n   *\r\n   * @example\r\n      <doc:example>\r\n        <doc:source>\r\n         <script>\r\n           function Ctrl($scope) {\r\n             $scope.value = 12;\r\n           }\r\n         </script>\r\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\r\n           Number: <input type=\"number\" name=\"input\" ng-model=\"value\"\r\n                          min=\"0\" max=\"99\" required>\r\n           <span class=\"error\" ng-show=\"myForm.list.$error.required\">\r\n             Required!</span>\r\n           <span class=\"error\" ng-show=\"myForm.list.$error.number\">\r\n             Not valid number!</span>\r\n           <tt>value = {{value}}</tt><br/>\r\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\r\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\r\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\r\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\r\n          </form>\r\n        </doc:source>\r\n        <doc:scenario>\r\n          it('should initialize to model', function() {\r\n           expect(binding('value')).toEqual('12');\r\n           expect(binding('myForm.input.$valid')).toEqual('true');\r\n          });\r\n\r\n          it('should be invalid if empty', function() {\r\n           input('value').enter('');\r\n           expect(binding('value')).toEqual('');\r\n           expect(binding('myForm.input.$valid')).toEqual('false');\r\n          });\r\n\r\n          it('should be invalid if over max', function() {\r\n           input('value').enter('123');\r\n           expect(binding('value')).toEqual('');\r\n           expect(binding('myForm.input.$valid')).toEqual('false');\r\n          });\r\n        </doc:scenario>\r\n      </doc:example>\r\n   */\r\n  'number': numberInputType,\r\n\r\n\r\n  /**\r\n   * @ngdoc inputType\r\n   * @name ng.directive:input.url\r\n   *\r\n   * @description\r\n   * Text input with URL validation. Sets the `url` validation error key if the content is not a\r\n   * valid URL.\r\n   *\r\n   * @param {string} ngModel Assignable angular expression to data-bind to.\r\n   * @param {string=} name Property name of the form under which the control is published.\r\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\r\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\r\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\r\n   *    `required` when you want to data-bind to the `required` attribute.\r\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\r\n   *    minlength.\r\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\r\n   *    maxlength.\r\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\r\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\r\n   *    patterns defined as scope expressions.\r\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\r\n   *    interaction with the input element.\r\n   *\r\n   * @example\r\n      <doc:example>\r\n        <doc:source>\r\n         <script>\r\n           function Ctrl($scope) {\r\n             $scope.text = 'http://google.com';\r\n           }\r\n         </script>\r\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\r\n           URL: <input type=\"url\" name=\"input\" ng-model=\"text\" required>\r\n           <span class=\"error\" ng-show=\"myForm.input.$error.required\">\r\n             Required!</span>\r\n           <span class=\"error\" ng-show=\"myForm.input.$error.url\">\r\n             Not valid url!</span>\r\n           <tt>text = {{text}}</tt><br/>\r\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\r\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\r\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\r\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\r\n           <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>\r\n          </form>\r\n        </doc:source>\r\n        <doc:scenario>\r\n          it('should initialize to model', function() {\r\n            expect(binding('text')).toEqual('http://google.com');\r\n            expect(binding('myForm.input.$valid')).toEqual('true');\r\n          });\r\n\r\n          it('should be invalid if empty', function() {\r\n            input('text').enter('');\r\n            expect(binding('text')).toEqual('');\r\n            expect(binding('myForm.input.$valid')).toEqual('false');\r\n          });\r\n\r\n          it('should be invalid if not url', function() {\r\n            input('text').enter('xxx');\r\n            expect(binding('myForm.input.$valid')).toEqual('false');\r\n          });\r\n        </doc:scenario>\r\n      </doc:example>\r\n   */\r\n  'url': urlInputType,\r\n\r\n\r\n  /**\r\n   * @ngdoc inputType\r\n   * @name ng.directive:input.email\r\n   *\r\n   * @description\r\n   * Text input with email validation. Sets the `email` validation error key if not a valid email\r\n   * address.\r\n   *\r\n   * @param {string} ngModel Assignable angular expression to data-bind to.\r\n   * @param {string=} name Property name of the form under which the control is published.\r\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\r\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\r\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\r\n   *    `required` when you want to data-bind to the `required` attribute.\r\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\r\n   *    minlength.\r\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\r\n   *    maxlength.\r\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\r\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\r\n   *    patterns defined as scope expressions.\r\n   *\r\n   * @example\r\n      <doc:example>\r\n        <doc:source>\r\n         <script>\r\n           function Ctrl($scope) {\r\n             $scope.text = 'me@example.com';\r\n           }\r\n         </script>\r\n           <form name=\"myForm\" ng-controller=\"Ctrl\">\r\n             Email: <input type=\"email\" name=\"input\" ng-model=\"text\" required>\r\n             <span class=\"error\" ng-show=\"myForm.input.$error.required\">\r\n               Required!</span>\r\n             <span class=\"error\" ng-show=\"myForm.input.$error.email\">\r\n               Not valid email!</span>\r\n             <tt>text = {{text}}</tt><br/>\r\n             <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\r\n             <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\r\n             <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\r\n             <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\r\n             <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>\r\n           </form>\r\n        </doc:source>\r\n        <doc:scenario>\r\n          it('should initialize to model', function() {\r\n            expect(binding('text')).toEqual('me@example.com');\r\n            expect(binding('myForm.input.$valid')).toEqual('true');\r\n          });\r\n\r\n          it('should be invalid if empty', function() {\r\n            input('text').enter('');\r\n            expect(binding('text')).toEqual('');\r\n            expect(binding('myForm.input.$valid')).toEqual('false');\r\n          });\r\n\r\n          it('should be invalid if not email', function() {\r\n            input('text').enter('xxx');\r\n            expect(binding('myForm.input.$valid')).toEqual('false');\r\n          });\r\n        </doc:scenario>\r\n      </doc:example>\r\n   */\r\n  'email': emailInputType,\r\n\r\n\r\n  /**\r\n   * @ngdoc inputType\r\n   * @name ng.directive:input.radio\r\n   *\r\n   * @description\r\n   * HTML radio button.\r\n   *\r\n   * @param {string} ngModel Assignable angular expression to data-bind to.\r\n   * @param {string} value The value to which the expression should be set when selected.\r\n   * @param {string=} name Property name of the form under which the control is published.\r\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\r\n   *    interaction with the input element.\r\n   *\r\n   * @example\r\n      <doc:example>\r\n        <doc:source>\r\n         <script>\r\n           function Ctrl($scope) {\r\n             $scope.color = 'blue';\r\n           }\r\n         </script>\r\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\r\n           <input type=\"radio\" ng-model=\"color\" value=\"red\">  Red <br/>\r\n           <input type=\"radio\" ng-model=\"color\" value=\"green\"> Green <br/>\r\n           <input type=\"radio\" ng-model=\"color\" value=\"blue\"> Blue <br/>\r\n           <tt>color = {{color}}</tt><br/>\r\n          </form>\r\n        </doc:source>\r\n        <doc:scenario>\r\n          it('should change state', function() {\r\n            expect(binding('color')).toEqual('blue');\r\n\r\n            input('color').select('red');\r\n            expect(binding('color')).toEqual('red');\r\n          });\r\n        </doc:scenario>\r\n      </doc:example>\r\n   */\r\n  'radio': radioInputType,\r\n\r\n\r\n  /**\r\n   * @ngdoc inputType\r\n   * @name ng.directive:input.checkbox\r\n   *\r\n   * @description\r\n   * HTML checkbox.\r\n   *\r\n   * @param {string} ngModel Assignable angular expression to data-bind to.\r\n   * @param {string=} name Property name of the form under which the control is published.\r\n   * @param {string=} ngTrueValue The value to which the expression should be set when selected.\r\n   * @param {string=} ngFalseValue The value to which the expression should be set when not selected.\r\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\r\n   *    interaction with the input element.\r\n   *\r\n   * @example\r\n      <doc:example>\r\n        <doc:source>\r\n         <script>\r\n           function Ctrl($scope) {\r\n             $scope.value1 = true;\r\n             $scope.value2 = 'YES'\r\n           }\r\n         </script>\r\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\r\n           Value1: <input type=\"checkbox\" ng-model=\"value1\"> <br/>\r\n           Value2: <input type=\"checkbox\" ng-model=\"value2\"\r\n                          ng-true-value=\"YES\" ng-false-value=\"NO\"> <br/>\r\n           <tt>value1 = {{value1}}</tt><br/>\r\n           <tt>value2 = {{value2}}</tt><br/>\r\n          </form>\r\n        </doc:source>\r\n        <doc:scenario>\r\n          it('should change state', function() {\r\n            expect(binding('value1')).toEqual('true');\r\n            expect(binding('value2')).toEqual('YES');\r\n\r\n            input('value1').check();\r\n            input('value2').check();\r\n            expect(binding('value1')).toEqual('false');\r\n            expect(binding('value2')).toEqual('NO');\r\n          });\r\n        </doc:scenario>\r\n      </doc:example>\r\n   */\r\n  'checkbox': checkboxInputType,\r\n\r\n  'hidden': noop,\r\n  'button': noop,\r\n  'submit': noop,\r\n  'reset': noop\r\n};\r\n\r\n\r\nfunction isEmpty(value) {\r\n  return isUndefined(value) || value === '' || value === null || value !== value;\r\n}\r\n\r\n\r\nfunction textInputType(scope, element, attr, ctrl, $sniffer, $browser) {\r\n\r\n  var listener = function() {\r\n    var value = element.val();\r\n\r\n    // By default we will trim the value\r\n    // If the attribute ng-trim exists we will avoid trimming\r\n    // e.g. <input ng-model=\"foo\" ng-trim=\"false\">\r\n    if (toBoolean(attr.ngTrim || 'T')) {\r\n      value = trim(value);\r\n    }\r\n\r\n    if (ctrl.$viewValue !== value) {\r\n      scope.$apply(function() {\r\n        ctrl.$setViewValue(value);\r\n      });\r\n    }\r\n  };\r\n\r\n  // if the browser does support \"input\" event, we are fine - except on IE9 which doesn't fire the\r\n  // input event on backspace, delete or cut\r\n  if ($sniffer.hasEvent('input')) {\r\n    element.bind('input', listener);\r\n  } else {\r\n    var timeout;\r\n\r\n    var deferListener = function() {\r\n      if (!timeout) {\r\n        timeout = $browser.defer(function() {\r\n          listener();\r\n          timeout = null;\r\n        });\r\n      }\r\n    };\r\n\r\n    element.bind('keydown', function(event) {\r\n      var key = event.keyCode;\r\n\r\n      // ignore\r\n      //    command            modifiers                   arrows\r\n      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;\r\n\r\n      deferListener();\r\n    });\r\n\r\n    // if user paste into input using mouse, we need \"change\" event to catch it\r\n    element.bind('change', listener);\r\n\r\n    // if user modifies input value using context menu in IE, we need \"paste\" and \"cut\" events to catch it\r\n    if ($sniffer.hasEvent('paste')) {\r\n      element.bind('paste cut', deferListener);\r\n    }\r\n  }\r\n\r\n\r\n  ctrl.$render = function() {\r\n    element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);\r\n  };\r\n\r\n  // pattern validator\r\n  var pattern = attr.ngPattern,\r\n      patternValidator,\r\n      match;\r\n\r\n  var validate = function(regexp, value) {\r\n    if (isEmpty(value) || regexp.test(value)) {\r\n      ctrl.$setValidity('pattern', true);\r\n      return value;\r\n    } else {\r\n      ctrl.$setValidity('pattern', false);\r\n      return undefined;\r\n    }\r\n  };\r\n\r\n  if (pattern) {\r\n    match = pattern.match(/^\\/(.*)\\/([gim]*)$/);\r\n    if (match) {\r\n      pattern = new RegExp(match[1], match[2]);\r\n      patternValidator = function(value) {\r\n        return validate(pattern, value)\r\n      };\r\n    } else {\r\n      patternValidator = function(value) {\r\n        var patternObj = scope.$eval(pattern);\r\n\r\n        if (!patternObj || !patternObj.test) {\r\n          throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);\r\n        }\r\n        return validate(patternObj, value);\r\n      };\r\n    }\r\n\r\n    ctrl.$formatters.push(patternValidator);\r\n    ctrl.$parsers.push(patternValidator);\r\n  }\r\n\r\n  // min length validator\r\n  if (attr.ngMinlength) {\r\n    var minlength = int(attr.ngMinlength);\r\n    var minLengthValidator = function(value) {\r\n      if (!isEmpty(value) && value.length < minlength) {\r\n        ctrl.$setValidity('minlength', false);\r\n        return undefined;\r\n      } else {\r\n        ctrl.$setValidity('minlength', true);\r\n        return value;\r\n      }\r\n    };\r\n\r\n    ctrl.$parsers.push(minLengthValidator);\r\n    ctrl.$formatters.push(minLengthValidator);\r\n  }\r\n\r\n  // max length validator\r\n  if (attr.ngMaxlength) {\r\n    var maxlength = int(attr.ngMaxlength);\r\n    var maxLengthValidator = function(value) {\r\n      if (!isEmpty(value) && value.length > maxlength) {\r\n        ctrl.$setValidity('maxlength', false);\r\n        return undefined;\r\n      } else {\r\n        ctrl.$setValidity('maxlength', true);\r\n        return value;\r\n      }\r\n    };\r\n\r\n    ctrl.$parsers.push(maxLengthValidator);\r\n    ctrl.$formatters.push(maxLengthValidator);\r\n  }\r\n}\r\n\r\nfunction numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {\r\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\r\n\r\n  ctrl.$parsers.push(function(value) {\r\n    var empty = isEmpty(value);\r\n    if (empty || NUMBER_REGEXP.test(value)) {\r\n      ctrl.$setValidity('number', true);\r\n      return value === '' ? null : (empty ? value : parseFloat(value));\r\n    } else {\r\n      ctrl.$setValidity('number', false);\r\n      return undefined;\r\n    }\r\n  });\r\n\r\n  ctrl.$formatters.push(function(value) {\r\n    return isEmpty(value) ? '' : '' + value;\r\n  });\r\n\r\n  if (attr.min) {\r\n    var min = parseFloat(attr.min);\r\n    var minValidator = function(value) {\r\n      if (!isEmpty(value) && value < min) {\r\n        ctrl.$setValidity('min', false);\r\n        return undefined;\r\n      } else {\r\n        ctrl.$setValidity('min', true);\r\n        return value;\r\n      }\r\n    };\r\n\r\n    ctrl.$parsers.push(minValidator);\r\n    ctrl.$formatters.push(minValidator);\r\n  }\r\n\r\n  if (attr.max) {\r\n    var max = parseFloat(attr.max);\r\n    var maxValidator = function(value) {\r\n      if (!isEmpty(value) && value > max) {\r\n        ctrl.$setValidity('max', false);\r\n        return undefined;\r\n      } else {\r\n        ctrl.$setValidity('max', true);\r\n        return value;\r\n      }\r\n    };\r\n\r\n    ctrl.$parsers.push(maxValidator);\r\n    ctrl.$formatters.push(maxValidator);\r\n  }\r\n\r\n  ctrl.$formatters.push(function(value) {\r\n\r\n    if (isEmpty(value) || isNumber(value)) {\r\n      ctrl.$setValidity('number', true);\r\n      return value;\r\n    } else {\r\n      ctrl.$setValidity('number', false);\r\n      return undefined;\r\n    }\r\n  });\r\n}\r\n\r\nfunction urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {\r\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\r\n\r\n  var urlValidator = function(value) {\r\n    if (isEmpty(value) || URL_REGEXP.test(value)) {\r\n      ctrl.$setValidity('url', true);\r\n      return value;\r\n    } else {\r\n      ctrl.$setValidity('url', false);\r\n      return undefined;\r\n    }\r\n  };\r\n\r\n  ctrl.$formatters.push(urlValidator);\r\n  ctrl.$parsers.push(urlValidator);\r\n}\r\n\r\nfunction emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {\r\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\r\n\r\n  var emailValidator = function(value) {\r\n    if (isEmpty(value) || EMAIL_REGEXP.test(value)) {\r\n      ctrl.$setValidity('email', true);\r\n      return value;\r\n    } else {\r\n      ctrl.$setValidity('email', false);\r\n      return undefined;\r\n    }\r\n  };\r\n\r\n  ctrl.$formatters.push(emailValidator);\r\n  ctrl.$parsers.push(emailValidator);\r\n}\r\n\r\nfunction radioInputType(scope, element, attr, ctrl) {\r\n  // make the name unique, if not defined\r\n  if (isUndefined(attr.name)) {\r\n    element.attr('name', nextUid());\r\n  }\r\n\r\n  element.bind('click', function() {\r\n    if (element[0].checked) {\r\n      scope.$apply(function() {\r\n        ctrl.$setViewValue(attr.value);\r\n      });\r\n    }\r\n  });\r\n\r\n  ctrl.$render = function() {\r\n    var value = attr.value;\r\n    element[0].checked = (value == ctrl.$viewValue);\r\n  };\r\n\r\n  attr.$observe('value', ctrl.$render);\r\n}\r\n\r\nfunction checkboxInputType(scope, element, attr, ctrl) {\r\n  var trueValue = attr.ngTrueValue,\r\n      falseValue = attr.ngFalseValue;\r\n\r\n  if (!isString(trueValue)) trueValue = true;\r\n  if (!isString(falseValue)) falseValue = false;\r\n\r\n  element.bind('click', function() {\r\n    scope.$apply(function() {\r\n      ctrl.$setViewValue(element[0].checked);\r\n    });\r\n  });\r\n\r\n  ctrl.$render = function() {\r\n    element[0].checked = ctrl.$viewValue;\r\n  };\r\n\r\n  ctrl.$formatters.push(function(value) {\r\n    return value === trueValue;\r\n  });\r\n\r\n  ctrl.$parsers.push(function(value) {\r\n    return value ? trueValue : falseValue;\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:textarea\r\n * @restrict E\r\n *\r\n * @description\r\n * HTML textarea element control with angular data-binding. The data-binding and validation\r\n * properties of this element are exactly the same as those of the\r\n * {@link ng.directive:input input element}.\r\n *\r\n * @param {string} ngModel Assignable angular expression to data-bind to.\r\n * @param {string=} name Property name of the form under which the control is published.\r\n * @param {string=} required Sets `required` validation error key if the value is not entered.\r\n * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\r\n *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\r\n *    `required` when you want to data-bind to the `required` attribute.\r\n * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\r\n *    minlength.\r\n * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\r\n *    maxlength.\r\n * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\r\n *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\r\n *    patterns defined as scope expressions.\r\n * @param {string=} ngChange Angular expression to be executed when input changes due to user\r\n *    interaction with the input element.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:input\r\n * @restrict E\r\n *\r\n * @description\r\n * HTML input element control with angular data-binding. Input control follows HTML5 input types\r\n * and polyfills the HTML5 validation behavior for older browsers.\r\n *\r\n * @param {string} ngModel Assignable angular expression to data-bind to.\r\n * @param {string=} name Property name of the form under which the control is published.\r\n * @param {string=} required Sets `required` validation error key if the value is not entered.\r\n * @param {boolean=} ngRequired Sets `required` attribute if set to true\r\n * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\r\n *    minlength.\r\n * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\r\n *    maxlength.\r\n * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\r\n *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\r\n *    patterns defined as scope expressions.\r\n * @param {string=} ngChange Angular expression to be executed when input changes due to user\r\n *    interaction with the input element.\r\n *\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.user = {name: 'guest', last: 'visitor'};\r\n         }\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n         <form name=\"myForm\">\r\n           User name: <input type=\"text\" name=\"userName\" ng-model=\"user.name\" required>\r\n           <span class=\"error\" ng-show=\"myForm.userName.$error.required\">\r\n             Required!</span><br>\r\n           Last name: <input type=\"text\" name=\"lastName\" ng-model=\"user.last\"\r\n             ng-minlength=\"3\" ng-maxlength=\"10\">\r\n           <span class=\"error\" ng-show=\"myForm.lastName.$error.minlength\">\r\n             Too short!</span>\r\n           <span class=\"error\" ng-show=\"myForm.lastName.$error.maxlength\">\r\n             Too long!</span><br>\r\n         </form>\r\n         <hr>\r\n         <tt>user = {{user}}</tt><br/>\r\n         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>\r\n         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>\r\n         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>\r\n         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>\r\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>\r\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>\r\n         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>\r\n         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>\r\n       </div>\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should initialize to model', function() {\r\n          expect(binding('user')).toEqual('{\"name\":\"guest\",\"last\":\"visitor\"}');\r\n          expect(binding('myForm.userName.$valid')).toEqual('true');\r\n          expect(binding('myForm.$valid')).toEqual('true');\r\n        });\r\n\r\n        it('should be invalid if empty when required', function() {\r\n          input('user.name').enter('');\r\n          expect(binding('user')).toEqual('{\"last\":\"visitor\"}');\r\n          expect(binding('myForm.userName.$valid')).toEqual('false');\r\n          expect(binding('myForm.$valid')).toEqual('false');\r\n        });\r\n\r\n        it('should be valid if empty when min length is set', function() {\r\n          input('user.last').enter('');\r\n          expect(binding('user')).toEqual('{\"name\":\"guest\",\"last\":\"\"}');\r\n          expect(binding('myForm.lastName.$valid')).toEqual('true');\r\n          expect(binding('myForm.$valid')).toEqual('true');\r\n        });\r\n\r\n        it('should be invalid if less than required min length', function() {\r\n          input('user.last').enter('xx');\r\n          expect(binding('user')).toEqual('{\"name\":\"guest\"}');\r\n          expect(binding('myForm.lastName.$valid')).toEqual('false');\r\n          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);\r\n          expect(binding('myForm.$valid')).toEqual('false');\r\n        });\r\n\r\n        it('should be invalid if longer than max length', function() {\r\n          input('user.last').enter('some ridiculously long name');\r\n          expect(binding('user'))\r\n            .toEqual('{\"name\":\"guest\"}');\r\n          expect(binding('myForm.lastName.$valid')).toEqual('false');\r\n          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);\r\n          expect(binding('myForm.$valid')).toEqual('false');\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n */\r\nvar inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {\r\n  return {\r\n    restrict: 'E',\r\n    require: '?ngModel',\r\n    link: function(scope, element, attr, ctrl) {\r\n      if (ctrl) {\r\n        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,\r\n                                                            $browser);\r\n      }\r\n    }\r\n  };\r\n}];\r\n\r\nvar VALID_CLASS = 'ng-valid',\r\n    INVALID_CLASS = 'ng-invalid',\r\n    PRISTINE_CLASS = 'ng-pristine',\r\n    DIRTY_CLASS = 'ng-dirty';\r\n\r\n/**\r\n * @ngdoc object\r\n * @name ng.directive:ngModel.NgModelController\r\n *\r\n * @property {string} $viewValue Actual string value in the view.\r\n * @property {*} $modelValue The value in the model, that the control is bound to.\r\n * @property {Array.<Function>} $parsers Whenever the control reads value from the DOM, it executes\r\n *     all of these functions to sanitize / convert the value as well as validate.\r\n *\r\n * @property {Array.<Function>} $formatters Whenever the model value changes, it executes all of\r\n *     these functions to convert the value as well as validate.\r\n *\r\n * @property {Object} $error An object hash with all errors as keys.\r\n *\r\n * @property {boolean} $pristine True if user has not interacted with the control yet.\r\n * @property {boolean} $dirty True if user has already interacted with the control.\r\n * @property {boolean} $valid True if there is no error.\r\n * @property {boolean} $invalid True if at least one error on the control.\r\n *\r\n * @description\r\n *\r\n * `NgModelController` provides API for the `ng-model` directive. The controller contains\r\n * services for data-binding, validation, CSS update, value formatting and parsing. It\r\n * specifically does not contain any logic which deals with DOM rendering or listening to\r\n * DOM events. The `NgModelController` is meant to be extended by other directives where, the\r\n * directive provides DOM manipulation and the `NgModelController` provides the data-binding.\r\n *\r\n * This example shows how to use `NgModelController` with a custom control to achieve\r\n * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)\r\n * collaborate together to achieve the desired result.\r\n *\r\n * <example module=\"customControl\">\r\n    <file name=\"style.css\">\r\n      [contenteditable] {\r\n        border: 1px solid black;\r\n        background-color: white;\r\n        min-height: 20px;\r\n      }\r\n\r\n      .ng-invalid {\r\n        border: 1px solid red;\r\n      }\r\n\r\n    </file>\r\n    <file name=\"script.js\">\r\n      angular.module('customControl', []).\r\n        directive('contenteditable', function() {\r\n          return {\r\n            restrict: 'A', // only activate on element attribute\r\n            require: '?ngModel', // get a hold of NgModelController\r\n            link: function(scope, element, attrs, ngModel) {\r\n              if(!ngModel) return; // do nothing if no ng-model\r\n\r\n              // Specify how UI should be updated\r\n              ngModel.$render = function() {\r\n                element.html(ngModel.$viewValue || '');\r\n              };\r\n\r\n              // Listen for change events to enable binding\r\n              element.bind('blur keyup change', function() {\r\n                scope.$apply(read);\r\n              });\r\n              read(); // initialize\r\n\r\n              // Write data to the model\r\n              function read() {\r\n                ngModel.$setViewValue(element.html());\r\n              }\r\n            }\r\n          };\r\n        });\r\n    </file>\r\n    <file name=\"index.html\">\r\n      <form name=\"myForm\">\r\n       <div contenteditable\r\n            name=\"myWidget\" ng-model=\"userContent\"\r\n            required>Change me!</div>\r\n        <span ng-show=\"myForm.myWidget.$error.required\">Required!</span>\r\n       <hr>\r\n       <textarea ng-model=\"userContent\"></textarea>\r\n      </form>\r\n    </file>\r\n    <file name=\"scenario.js\">\r\n      it('should data-bind and become invalid', function() {\r\n        var contentEditable = element('[contenteditable]');\r\n\r\n        expect(contentEditable.text()).toEqual('Change me!');\r\n        input('userContent').enter('');\r\n        expect(contentEditable.text()).toEqual('');\r\n        expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);\r\n      });\r\n    </file>\r\n * </example>\r\n *\r\n */\r\nvar NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',\r\n    function($scope, $exceptionHandler, $attr, $element, $parse) {\r\n  this.$viewValue = Number.NaN;\r\n  this.$modelValue = Number.NaN;\r\n  this.$parsers = [];\r\n  this.$formatters = [];\r\n  this.$viewChangeListeners = [];\r\n  this.$pristine = true;\r\n  this.$dirty = false;\r\n  this.$valid = true;\r\n  this.$invalid = false;\r\n  this.$name = $attr.name;\r\n\r\n  var ngModelGet = $parse($attr.ngModel),\r\n      ngModelSet = ngModelGet.assign;\r\n\r\n  if (!ngModelSet) {\r\n    throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel +\r\n        ' (' + startingTag($element) + ')');\r\n  }\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.directive:ngModel.NgModelController#$render\r\n   * @methodOf ng.directive:ngModel.NgModelController\r\n   *\r\n   * @description\r\n   * Called when the view needs to be updated. It is expected that the user of the ng-model\r\n   * directive will implement this method.\r\n   */\r\n  this.$render = noop;\r\n\r\n  var parentForm = $element.inheritedData('$formController') || nullFormCtrl,\r\n      invalidCount = 0, // used to easily determine if we are valid\r\n      $error = this.$error = {}; // keep invalid keys here\r\n\r\n\r\n  // Setup initial state of the control\r\n  $element.addClass(PRISTINE_CLASS);\r\n  toggleValidCss(true);\r\n\r\n  // convenience method for easy toggling of classes\r\n  function toggleValidCss(isValid, validationErrorKey) {\r\n    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';\r\n    $element.\r\n      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).\r\n      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);\r\n  }\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.directive:ngModel.NgModelController#$setValidity\r\n   * @methodOf ng.directive:ngModel.NgModelController\r\n   *\r\n   * @description\r\n   * Change the validity state, and notifies the form when the control changes validity. (i.e. it\r\n   * does not notify form if given validator is already marked as invalid).\r\n   *\r\n   * This method should be called by validators - i.e. the parser or formatter functions.\r\n   *\r\n   * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign\r\n   *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.\r\n   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case\r\n   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`\r\n   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .\r\n   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).\r\n   */\r\n  this.$setValidity = function(validationErrorKey, isValid) {\r\n    if ($error[validationErrorKey] === !isValid) return;\r\n\r\n    if (isValid) {\r\n      if ($error[validationErrorKey]) invalidCount--;\r\n      if (!invalidCount) {\r\n        toggleValidCss(true);\r\n        this.$valid = true;\r\n        this.$invalid = false;\r\n      }\r\n    } else {\r\n      toggleValidCss(false);\r\n      this.$invalid = true;\r\n      this.$valid = false;\r\n      invalidCount++;\r\n    }\r\n\r\n    $error[validationErrorKey] = !isValid;\r\n    toggleValidCss(isValid, validationErrorKey);\r\n\r\n    parentForm.$setValidity(validationErrorKey, isValid, this);\r\n  };\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.directive:ngModel.NgModelController#$setPristine\r\n   * @methodOf ng.directive:ngModel.NgModelController\r\n   *\r\n   * @description\r\n   * Sets the control to its pristine state.\r\n   *\r\n   * This method can be called to remove the 'ng-dirty' class and set the control to its pristine\r\n   * state (ng-pristine class).\r\n   */\r\n  this.$setPristine = function () {\r\n    this.$dirty = false;\r\n    this.$pristine = true;\r\n    $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);\r\n  };\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name ng.directive:ngModel.NgModelController#$setViewValue\r\n   * @methodOf ng.directive:ngModel.NgModelController\r\n   *\r\n   * @description\r\n   * Read a value from view.\r\n   *\r\n   * This method should be called from within a DOM event handler.\r\n   * For example {@link ng.directive:input input} or\r\n   * {@link ng.directive:select select} directives call it.\r\n   *\r\n   * It internally calls all `parsers` and if resulted value is valid, updates the model and\r\n   * calls all registered change listeners.\r\n   *\r\n   * @param {string} value Value from the view.\r\n   */\r\n  this.$setViewValue = function(value) {\r\n    this.$viewValue = value;\r\n\r\n    // change to dirty\r\n    if (this.$pristine) {\r\n      this.$dirty = true;\r\n      this.$pristine = false;\r\n      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);\r\n      parentForm.$setDirty();\r\n    }\r\n\r\n    forEach(this.$parsers, function(fn) {\r\n      value = fn(value);\r\n    });\r\n\r\n    if (this.$modelValue !== value) {\r\n      this.$modelValue = value;\r\n      ngModelSet($scope, value);\r\n      forEach(this.$viewChangeListeners, function(listener) {\r\n        try {\r\n          listener();\r\n        } catch(e) {\r\n          $exceptionHandler(e);\r\n        }\r\n      })\r\n    }\r\n  };\r\n\r\n  // model -> value\r\n  var ctrl = this;\r\n\r\n  $scope.$watch(function ngModelWatch() {\r\n    var value = ngModelGet($scope);\r\n\r\n    // if scope model value and ngModel value are out of sync\r\n    if (ctrl.$modelValue !== value) {\r\n\r\n      var formatters = ctrl.$formatters,\r\n          idx = formatters.length;\r\n\r\n      ctrl.$modelValue = value;\r\n      while(idx--) {\r\n        value = formatters[idx](value);\r\n      }\r\n\r\n      if (ctrl.$viewValue !== value) {\r\n        ctrl.$viewValue = value;\r\n        ctrl.$render();\r\n      }\r\n    }\r\n  });\r\n}];\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngModel\r\n *\r\n * @element input\r\n *\r\n * @description\r\n * Is directive that tells Angular to do two-way data binding. It works together with `input`,\r\n * `select`, `textarea`. You can easily write your own directives to use `ngModel` as well.\r\n *\r\n * `ngModel` is responsible for:\r\n *\r\n * - binding the view into the model, which other directives such as `input`, `textarea` or `select`\r\n *   require,\r\n * - providing validation behavior (i.e. required, number, email, url),\r\n * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),\r\n * - setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),\r\n * - register the control with parent {@link ng.directive:form form}.\r\n *\r\n * For basic examples, how to use `ngModel`, see:\r\n *\r\n *  - {@link ng.directive:input input}\r\n *    - {@link ng.directive:input.text text}\r\n *    - {@link ng.directive:input.checkbox checkbox}\r\n *    - {@link ng.directive:input.radio radio}\r\n *    - {@link ng.directive:input.number number}\r\n *    - {@link ng.directive:input.email email}\r\n *    - {@link ng.directive:input.url url}\r\n *  - {@link ng.directive:select select}\r\n *  - {@link ng.directive:textarea textarea}\r\n *\r\n */\r\nvar ngModelDirective = function() {\r\n  return {\r\n    require: ['ngModel', '^?form'],\r\n    controller: NgModelController,\r\n    link: function(scope, element, attr, ctrls) {\r\n      // notify others, especially parent forms\r\n\r\n      var modelCtrl = ctrls[0],\r\n          formCtrl = ctrls[1] || nullFormCtrl;\r\n\r\n      formCtrl.$addControl(modelCtrl);\r\n\r\n      element.bind('$destroy', function() {\r\n        formCtrl.$removeControl(modelCtrl);\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngChange\r\n * @restrict E\r\n *\r\n * @description\r\n * Evaluate given expression when user changes the input.\r\n * The expression is not evaluated when the value change is coming from the model.\r\n *\r\n * Note, this directive requires `ngModel` to be present.\r\n *\r\n * @element input\r\n *\r\n * @example\r\n * <doc:example>\r\n *   <doc:source>\r\n *     <script>\r\n *       function Controller($scope) {\r\n *         $scope.counter = 0;\r\n *         $scope.change = function() {\r\n *           $scope.counter++;\r\n *         };\r\n *       }\r\n *     </script>\r\n *     <div ng-controller=\"Controller\">\r\n *       <input type=\"checkbox\" ng-model=\"confirmed\" ng-change=\"change()\" id=\"ng-change-example1\" />\r\n *       <input type=\"checkbox\" ng-model=\"confirmed\" id=\"ng-change-example2\" />\r\n *       <label for=\"ng-change-example2\">Confirmed</label><br />\r\n *       debug = {{confirmed}}<br />\r\n *       counter = {{counter}}\r\n *     </div>\r\n *   </doc:source>\r\n *   <doc:scenario>\r\n *     it('should evaluate the expression if changing from view', function() {\r\n *       expect(binding('counter')).toEqual('0');\r\n *       element('#ng-change-example1').click();\r\n *       expect(binding('counter')).toEqual('1');\r\n *       expect(binding('confirmed')).toEqual('true');\r\n *     });\r\n *\r\n *     it('should not evaluate the expression if changing from model', function() {\r\n *       element('#ng-change-example2').click();\r\n *       expect(binding('counter')).toEqual('0');\r\n *       expect(binding('confirmed')).toEqual('true');\r\n *     });\r\n *   </doc:scenario>\r\n * </doc:example>\r\n */\r\nvar ngChangeDirective = valueFn({\r\n  require: 'ngModel',\r\n  link: function(scope, element, attr, ctrl) {\r\n    ctrl.$viewChangeListeners.push(function() {\r\n      scope.$eval(attr.ngChange);\r\n    });\r\n  }\r\n});\r\n\r\n\r\nvar requiredDirective = function() {\r\n  return {\r\n    require: '?ngModel',\r\n    link: function(scope, elm, attr, ctrl) {\r\n      if (!ctrl) return;\r\n      attr.required = true; // force truthy in case we are on non input element\r\n\r\n      var validator = function(value) {\r\n        if (attr.required && (isEmpty(value) || value === false)) {\r\n          ctrl.$setValidity('required', false);\r\n          return;\r\n        } else {\r\n          ctrl.$setValidity('required', true);\r\n          return value;\r\n        }\r\n      };\r\n\r\n      ctrl.$formatters.push(validator);\r\n      ctrl.$parsers.unshift(validator);\r\n\r\n      attr.$observe('required', function() {\r\n        validator(ctrl.$viewValue);\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngList\r\n *\r\n * @description\r\n * Text input that converts between comma-separated string into an array of strings.\r\n *\r\n * @element input\r\n * @param {string=} ngList optional delimiter that should be used to split the value. If\r\n *   specified in form `/something/` then the value will be converted into a regular expression.\r\n *\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.names = ['igor', 'misko', 'vojta'];\r\n         }\r\n       </script>\r\n       <form name=\"myForm\" ng-controller=\"Ctrl\">\r\n         List: <input name=\"namesInput\" ng-model=\"names\" ng-list required>\r\n         <span class=\"error\" ng-show=\"myForm.list.$error.required\">\r\n           Required!</span>\r\n         <tt>names = {{names}}</tt><br/>\r\n         <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>\r\n         <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>\r\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\r\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\r\n        </form>\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should initialize to model', function() {\r\n          expect(binding('names')).toEqual('[\"igor\",\"misko\",\"vojta\"]');\r\n          expect(binding('myForm.namesInput.$valid')).toEqual('true');\r\n        });\r\n\r\n        it('should be invalid if empty', function() {\r\n          input('names').enter('');\r\n          expect(binding('names')).toEqual('[]');\r\n          expect(binding('myForm.namesInput.$valid')).toEqual('false');\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n */\r\nvar ngListDirective = function() {\r\n  return {\r\n    require: 'ngModel',\r\n    link: function(scope, element, attr, ctrl) {\r\n      var match = /\\/(.*)\\//.exec(attr.ngList),\r\n          separator = match && new RegExp(match[1]) || attr.ngList || ',';\r\n\r\n      var parse = function(viewValue) {\r\n        var list = [];\r\n\r\n        if (viewValue) {\r\n          forEach(viewValue.split(separator), function(value) {\r\n            if (value) list.push(trim(value));\r\n          });\r\n        }\r\n\r\n        return list;\r\n      };\r\n\r\n      ctrl.$parsers.push(parse);\r\n      ctrl.$formatters.push(function(value) {\r\n        if (isArray(value)) {\r\n          return value.join(', ');\r\n        }\r\n\r\n        return undefined;\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n\r\nvar CONSTANT_VALUE_REGEXP = /^(true|false|\\d+)$/;\r\n\r\nvar ngValueDirective = function() {\r\n  return {\r\n    priority: 100,\r\n    compile: function(tpl, tplAttr) {\r\n      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {\r\n        return function(scope, elm, attr) {\r\n          attr.$set('value', scope.$eval(attr.ngValue));\r\n        };\r\n      } else {\r\n        return function(scope, elm, attr) {\r\n          scope.$watch(attr.ngValue, function valueWatchAction(value) {\r\n            attr.$set('value', value, false);\r\n          });\r\n        };\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngBind\r\n *\r\n * @description\r\n * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element\r\n * with the value of a given expression, and to update the text content when the value of that\r\n * expression changes.\r\n *\r\n * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like\r\n * `{{ expression }}` which is similar but less verbose.\r\n *\r\n * One scenario in which the use of `ngBind` is preferred over `{{ expression }}` binding is when\r\n * it's desirable to put bindings into template that is momentarily displayed by the browser in its\r\n * raw state before Angular compiles it. Since `ngBind` is an element attribute, it makes the\r\n * bindings invisible to the user while the page is loading.\r\n *\r\n * An alternative solution to this problem would be using the\r\n * {@link ng.directive:ngCloak ngCloak} directive.\r\n *\r\n *\r\n * @element ANY\r\n * @param {expression} ngBind {@link guide/expression Expression} to evaluate.\r\n *\r\n * @example\r\n * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.\r\n   <doc:example>\r\n     <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.name = 'Whirled';\r\n         }\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n         Enter name: <input type=\"text\" ng-model=\"name\"><br>\r\n         Hello <span ng-bind=\"name\"></span>!\r\n       </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should check ng-bind', function() {\r\n         expect(using('.doc-example-live').binding('name')).toBe('Whirled');\r\n         using('.doc-example-live').input('name').enter('world');\r\n         expect(using('.doc-example-live').binding('name')).toBe('world');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\nvar ngBindDirective = ngDirective(function(scope, element, attr) {\r\n  element.addClass('ng-binding').data('$binding', attr.ngBind);\r\n  scope.$watch(attr.ngBind, function ngBindWatchAction(value) {\r\n    element.text(value == undefined ? '' : value);\r\n  });\r\n});\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngBindTemplate\r\n *\r\n * @description\r\n * The `ngBindTemplate` directive specifies that the element\r\n * text should be replaced with the template in ngBindTemplate.\r\n * Unlike ngBind the ngBindTemplate can contain multiple `{{` `}}`\r\n * expressions. (This is required since some HTML elements\r\n * can not have SPAN elements such as TITLE, or OPTION to name a few.)\r\n *\r\n * @element ANY\r\n * @param {string} ngBindTemplate template of form\r\n *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.\r\n *\r\n * @example\r\n * Try it here: enter text in text box and watch the greeting change.\r\n   <doc:example>\r\n     <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.salutation = 'Hello';\r\n           $scope.name = 'World';\r\n         }\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n        Salutation: <input type=\"text\" ng-model=\"salutation\"><br>\r\n        Name: <input type=\"text\" ng-model=\"name\"><br>\r\n        <pre ng-bind-template=\"{{salutation}} {{name}}!\"></pre>\r\n       </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should check ng-bind', function() {\r\n         expect(using('.doc-example-live').binding('salutation')).\r\n           toBe('Hello');\r\n         expect(using('.doc-example-live').binding('name')).\r\n           toBe('World');\r\n         using('.doc-example-live').input('salutation').enter('Greetings');\r\n         using('.doc-example-live').input('name').enter('user');\r\n         expect(using('.doc-example-live').binding('salutation')).\r\n           toBe('Greetings');\r\n         expect(using('.doc-example-live').binding('name')).\r\n           toBe('user');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\nvar ngBindTemplateDirective = ['$interpolate', function($interpolate) {\r\n  return function(scope, element, attr) {\r\n    // TODO: move this to scenario runner\r\n    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));\r\n    element.addClass('ng-binding').data('$binding', interpolateFn);\r\n    attr.$observe('ngBindTemplate', function(value) {\r\n      element.text(value);\r\n    });\r\n  }\r\n}];\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngBindHtmlUnsafe\r\n *\r\n * @description\r\n * Creates a binding that will innerHTML the result of evaluating the `expression` into the current\r\n * element. *The innerHTML-ed content will not be sanitized!* You should use this directive only if\r\n * {@link ngSanitize.directive:ngBindHtml ngBindHtml} directive is too\r\n * restrictive and when you absolutely trust the source of the content you are binding to.\r\n *\r\n * See {@link ngSanitize.$sanitize $sanitize} docs for examples.\r\n *\r\n * @element ANY\r\n * @param {expression} ngBindHtmlUnsafe {@link guide/expression Expression} to evaluate.\r\n */\r\nvar ngBindHtmlUnsafeDirective = [function() {\r\n  return function(scope, element, attr) {\r\n    element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);\r\n    scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {\r\n      element.html(value || '');\r\n    });\r\n  };\r\n}];\r\n\r\nfunction classDirective(name, selector) {\r\n  name = 'ngClass' + name;\r\n  return ngDirective(function(scope, element, attr) {\r\n    var oldVal = undefined;\r\n\r\n    scope.$watch(attr[name], ngClassWatchAction, true);\r\n\r\n    attr.$observe('class', function(value) {\r\n      var ngClass = scope.$eval(attr[name]);\r\n      ngClassWatchAction(ngClass, ngClass);\r\n    });\r\n\r\n\r\n    if (name !== 'ngClass') {\r\n      scope.$watch('$index', function($index, old$index) {\r\n        var mod = $index & 1;\r\n        if (mod !== old$index & 1) {\r\n          if (mod === selector) {\r\n            addClass(scope.$eval(attr[name]));\r\n          } else {\r\n            removeClass(scope.$eval(attr[name]));\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    function ngClassWatchAction(newVal) {\r\n      if (selector === true || scope.$index % 2 === selector) {\r\n        if (oldVal && !equals(newVal,oldVal)) {\r\n          removeClass(oldVal);\r\n        }\r\n        addClass(newVal);\r\n      }\r\n      oldVal = copy(newVal);\r\n    }\r\n\r\n\r\n    function removeClass(classVal) {\r\n      if (isObject(classVal) && !isArray(classVal)) {\r\n        classVal = map(classVal, function(v, k) { if (v) return k });\r\n      }\r\n      element.removeClass(isArray(classVal) ? classVal.join(' ') : classVal);\r\n    }\r\n\r\n\r\n    function addClass(classVal) {\r\n      if (isObject(classVal) && !isArray(classVal)) {\r\n        classVal = map(classVal, function(v, k) { if (v) return k });\r\n      }\r\n      if (classVal) {\r\n        element.addClass(isArray(classVal) ? classVal.join(' ') : classVal);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngClass\r\n *\r\n * @description\r\n * The `ngClass` allows you to set CSS class on HTML element dynamically by databinding an\r\n * expression that represents all classes to be added.\r\n *\r\n * The directive won't add duplicate classes if a particular class was already set.\r\n *\r\n * When the expression changes, the previously added classes are removed and only then the\r\n * new classes are added.\r\n *\r\n * @element ANY\r\n * @param {expression} ngClass {@link guide/expression Expression} to eval. The result\r\n *   of the evaluation can be a string representing space delimited class\r\n *   names, an array, or a map of class names to boolean values.\r\n *\r\n * @example\r\n   <example>\r\n     <file name=\"index.html\">\r\n      <input type=\"button\" value=\"set\" ng-click=\"myVar='my-class'\">\r\n      <input type=\"button\" value=\"clear\" ng-click=\"myVar=''\">\r\n      <br>\r\n      <span ng-class=\"myVar\">Sample Text</span>\r\n     </file>\r\n     <file name=\"style.css\">\r\n       .my-class {\r\n         color: red;\r\n       }\r\n     </file>\r\n     <file name=\"scenario.js\">\r\n       it('should check ng-class', function() {\r\n         expect(element('.doc-example-live span').prop('className')).not().\r\n           toMatch(/my-class/);\r\n\r\n         using('.doc-example-live').element(':button:first').click();\r\n\r\n         expect(element('.doc-example-live span').prop('className')).\r\n           toMatch(/my-class/);\r\n\r\n         using('.doc-example-live').element(':button:last').click();\r\n\r\n         expect(element('.doc-example-live span').prop('className')).not().\r\n           toMatch(/my-class/);\r\n       });\r\n     </file>\r\n   </example>\r\n */\r\nvar ngClassDirective = classDirective('', true);\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngClassOdd\r\n *\r\n * @description\r\n * The `ngClassOdd` and `ngClassEven` directives work exactly as\r\n * {@link ng.directive:ngClass ngClass}, except it works in\r\n * conjunction with `ngRepeat` and takes affect only on odd (even) rows.\r\n *\r\n * This directive can be applied only within a scope of an\r\n * {@link ng.directive:ngRepeat ngRepeat}.\r\n *\r\n * @element ANY\r\n * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result\r\n *   of the evaluation can be a string representing space delimited class names or an array.\r\n *\r\n * @example\r\n   <example>\r\n     <file name=\"index.html\">\r\n        <ol ng-init=\"names=['John', 'Mary', 'Cate', 'Suz']\">\r\n          <li ng-repeat=\"name in names\">\r\n           <span ng-class-odd=\"'odd'\" ng-class-even=\"'even'\">\r\n             {{name}}\r\n           </span>\r\n          </li>\r\n        </ol>\r\n     </file>\r\n     <file name=\"style.css\">\r\n       .odd {\r\n         color: red;\r\n       }\r\n       .even {\r\n         color: blue;\r\n       }\r\n     </file>\r\n     <file name=\"scenario.js\">\r\n       it('should check ng-class-odd and ng-class-even', function() {\r\n         expect(element('.doc-example-live li:first span').prop('className')).\r\n           toMatch(/odd/);\r\n         expect(element('.doc-example-live li:last span').prop('className')).\r\n           toMatch(/even/);\r\n       });\r\n     </file>\r\n   </example>\r\n */\r\nvar ngClassOddDirective = classDirective('Odd', 0);\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngClassEven\r\n *\r\n * @description\r\n * The `ngClassOdd` and `ngClassEven` directives work exactly as\r\n * {@link ng.directive:ngClass ngClass}, except it works in\r\n * conjunction with `ngRepeat` and takes affect only on odd (even) rows.\r\n *\r\n * This directive can be applied only within a scope of an\r\n * {@link ng.directive:ngRepeat ngRepeat}.\r\n *\r\n * @element ANY\r\n * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The\r\n *   result of the evaluation can be a string representing space delimited class names or an array.\r\n *\r\n * @example\r\n   <example>\r\n     <file name=\"index.html\">\r\n        <ol ng-init=\"names=['John', 'Mary', 'Cate', 'Suz']\">\r\n          <li ng-repeat=\"name in names\">\r\n           <span ng-class-odd=\"'odd'\" ng-class-even=\"'even'\">\r\n             {{name}} &nbsp; &nbsp; &nbsp;\r\n           </span>\r\n          </li>\r\n        </ol>\r\n     </file>\r\n     <file name=\"style.css\">\r\n       .odd {\r\n         color: red;\r\n       }\r\n       .even {\r\n         color: blue;\r\n       }\r\n     </file>\r\n     <file name=\"scenario.js\">\r\n       it('should check ng-class-odd and ng-class-even', function() {\r\n         expect(element('.doc-example-live li:first span').prop('className')).\r\n           toMatch(/odd/);\r\n         expect(element('.doc-example-live li:last span').prop('className')).\r\n           toMatch(/even/);\r\n       });\r\n     </file>\r\n   </example>\r\n */\r\nvar ngClassEvenDirective = classDirective('Even', 1);\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngCloak\r\n *\r\n * @description\r\n * The `ngCloak` directive is used to prevent the Angular html template from being briefly\r\n * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this\r\n * directive to avoid the undesirable flicker effect caused by the html template display.\r\n *\r\n * The directive can be applied to the `<body>` element, but typically a fine-grained application is\r\n * preferred in order to benefit from progressive rendering of the browser view.\r\n *\r\n * `ngCloak` works in cooperation with a css rule that is embedded within `angular.js` and\r\n *  `angular.min.js` files. Following is the css rule:\r\n *\r\n * <pre>\r\n * [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {\r\n *   display: none;\r\n * }\r\n * </pre>\r\n *\r\n * When this css rule is loaded by the browser, all html elements (including their children) that\r\n * are tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive\r\n * during the compilation of the template it deletes the `ngCloak` element attribute, which\r\n * makes the compiled element visible.\r\n *\r\n * For the best result, `angular.js` script must be loaded in the head section of the html file;\r\n * alternatively, the css rule (above) must be included in the external stylesheet of the\r\n * application.\r\n *\r\n * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they\r\n * cannot match the `[ng\\:cloak]` selector. To work around this limitation, you must add the css\r\n * class `ngCloak` in addition to `ngCloak` directive as shown in the example below.\r\n *\r\n * @element ANY\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n        <div id=\"template1\" ng-cloak>{{ 'hello' }}</div>\r\n        <div id=\"template2\" ng-cloak class=\"ng-cloak\">{{ 'hello IE7' }}</div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should remove the template directive and css class', function() {\r\n         expect(element('.doc-example-live #template1').attr('ng-cloak')).\r\n           not().toBeDefined();\r\n         expect(element('.doc-example-live #template2').attr('ng-cloak')).\r\n           not().toBeDefined();\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n *\r\n */\r\nvar ngCloakDirective = ngDirective({\r\n  compile: function(element, attr) {\r\n    attr.$set('ngCloak', undefined);\r\n    element.removeClass('ng-cloak');\r\n  }\r\n});\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngController\r\n *\r\n * @description\r\n * The `ngController` directive assigns behavior to a scope. This is a key aspect of how angular\r\n * supports the principles behind the Model-View-Controller design pattern.\r\n *\r\n * MVC components in angular:\r\n *\r\n * * Model  The Model is data in scope properties; scopes are attached to the DOM.\r\n * * View  The template (HTML with data bindings) is rendered into the View.\r\n * * Controller  The `ngController` directive specifies a Controller class; the class has\r\n *   methods that typically express the business logic behind the application.\r\n *\r\n * Note that an alternative way to define controllers is via the {@link ng.$route $route} service.\r\n *\r\n * @element ANY\r\n * @scope\r\n * @param {expression} ngController Name of a globally accessible constructor function or an\r\n *     {@link guide/expression expression} that on the current scope evaluates to a\r\n *     constructor function. The controller instance can further be published into the scope\r\n *     by adding `as localName` the controller name attribute.\r\n *\r\n * @example\r\n * Here is a simple form for editing user contact information. Adding, removing, clearing, and\r\n * greeting are methods declared on the controller (see source tab). These methods can\r\n * easily be called from the angular markup. Notice that the scope becomes the `this` for the\r\n * controller's instance. This allows for easy access to the view data from the controller. Also\r\n * notice that any changes to the data are automatically reflected in the View without the need\r\n * for a manual update. The example is included in two different declaration styles based on\r\n * your style preferences.\r\n   <doc:example>\r\n     <doc:source>\r\n      <script>\r\n        function SettingsController() {\r\n          this.name = \"John Smith\";\r\n          this.contacts = [\r\n            {type: 'phone', value: '408 555 1212'},\r\n            {type: 'email', value: 'john.smith@example.org'} ];\r\n          };\r\n\r\n        SettingsController.prototype.greet = function() {\r\n          alert(this.name);\r\n        };\r\n\r\n        SettingsController.prototype.addContact = function() {\r\n          this.contacts.push({type: 'email', value: 'yourname@example.org'});\r\n        };\r\n\r\n        SettingsController.prototype.removeContact = function(contactToRemove) {\r\n         var index = this.contacts.indexOf(contactToRemove);\r\n          this.contacts.splice(index, 1);\r\n        };\r\n\r\n        SettingsController.prototype.clearContact = function(contact) {\r\n          contact.type = 'phone';\r\n          contact.value = '';\r\n        };\r\n      </script>\r\n      <div ng-controller=\"SettingsController as settings\">\r\n        Name: <input type=\"text\" ng-model=\"settings.name\"/>\r\n        [ <a href=\"\" ng-click=\"settings.greet()\">greet</a> ]<br/>\r\n        Contact:\r\n        <ul>\r\n          <li ng-repeat=\"contact in settings.contacts\">\r\n            <select ng-model=\"contact.type\">\r\n               <option>phone</option>\r\n               <option>email</option>\r\n            </select>\r\n            <input type=\"text\" ng-model=\"contact.value\"/>\r\n            [ <a href=\"\" ng-click=\"settings.clearContact(contact)\">clear</a>\r\n            | <a href=\"\" ng-click=\"settings.removeContact(contact)\">X</a> ]\r\n          </li>\r\n          <li>[ <a href=\"\" ng-click=\"settings.addContact()\">add</a> ]</li>\r\n       </ul>\r\n      </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should check controller', function() {\r\n         expect(element('.doc-example-live div>:input').val()).toBe('John Smith');\r\n         expect(element('.doc-example-live li:nth-child(1) input').val())\r\n           .toBe('408 555 1212');\r\n         expect(element('.doc-example-live li:nth-child(2) input').val())\r\n           .toBe('john.smith@example.org');\r\n\r\n         element('.doc-example-live li:first a:contains(\"clear\")').click();\r\n         expect(element('.doc-example-live li:first input').val()).toBe('');\r\n\r\n         element('.doc-example-live li:last a:contains(\"add\")').click();\r\n         expect(element('.doc-example-live li:nth-child(3) input').val())\r\n           .toBe('yourname@example.org');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n\r\n\r\n\r\n    <doc:example>\r\n     <doc:source>\r\n      <script>\r\n        function SettingsController($scope) {\r\n          $scope.name = \"John Smith\";\r\n          $scope.contacts = [\r\n            {type:'phone', value:'408 555 1212'},\r\n            {type:'email', value:'john.smith@example.org'} ];\r\n\r\n          $scope.greet = function() {\r\n           alert(this.name);\r\n          };\r\n\r\n          $scope.addContact = function() {\r\n           this.contacts.push({type:'email', value:'yourname@example.org'});\r\n          };\r\n\r\n          $scope.removeContact = function(contactToRemove) {\r\n           var index = this.contacts.indexOf(contactToRemove);\r\n           this.contacts.splice(index, 1);\r\n          };\r\n\r\n          $scope.clearContact = function(contact) {\r\n           contact.type = 'phone';\r\n           contact.value = '';\r\n          };\r\n        }\r\n      </script>\r\n      <div ng-controller=\"SettingsController\">\r\n        Name: <input type=\"text\" ng-model=\"name\"/>\r\n        [ <a href=\"\" ng-click=\"greet()\">greet</a> ]<br/>\r\n        Contact:\r\n        <ul>\r\n          <li ng-repeat=\"contact in contacts\">\r\n            <select ng-model=\"contact.type\">\r\n               <option>phone</option>\r\n               <option>email</option>\r\n            </select>\r\n            <input type=\"text\" ng-model=\"contact.value\"/>\r\n            [ <a href=\"\" ng-click=\"clearContact(contact)\">clear</a>\r\n            | <a href=\"\" ng-click=\"removeContact(contact)\">X</a> ]\r\n          </li>\r\n          <li>[ <a href=\"\" ng-click=\"addContact()\">add</a> ]</li>\r\n       </ul>\r\n      </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should check controller', function() {\r\n         expect(element('.doc-example-live div>:input').val()).toBe('John Smith');\r\n         expect(element('.doc-example-live li:nth-child(1) input').val())\r\n           .toBe('408 555 1212');\r\n         expect(element('.doc-example-live li:nth-child(2) input').val())\r\n           .toBe('john.smith@example.org');\r\n\r\n         element('.doc-example-live li:first a:contains(\"clear\")').click();\r\n         expect(element('.doc-example-live li:first input').val()).toBe('');\r\n\r\n         element('.doc-example-live li:last a:contains(\"add\")').click();\r\n         expect(element('.doc-example-live li:nth-child(3) input').val())\r\n           .toBe('yourname@example.org');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n\r\n */\r\nvar ngControllerDirective = [function() {\r\n  return {\r\n    scope: true,\r\n    controller: '@'\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngCsp\r\n * @priority 1000\r\n *\r\n * @element html\r\n * @description\r\n * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.\r\n * \r\n * This is necessary when developing things like Google Chrome Extensions.\r\n * \r\n * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).\r\n * For us to be compatible, we just need to implement the \"getterFn\" in $parse without violating\r\n * any of these restrictions.\r\n * \r\n * AngularJS uses `Function(string)` generated functions as a speed optimization. By applying `ngCsp`\r\n * it is be possible to opt into the CSP compatible mode. When this mode is on AngularJS will\r\n * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will\r\n * be raised.\r\n * \r\n * In order to use this feature put `ngCsp` directive on the root element of the application.\r\n * \r\n * @example\r\n * This example shows how to apply the `ngCsp` directive to the `html` tag.\r\n   <pre>\r\n     <!doctype html>\r\n     <html ng-app ng-csp>\r\n     ...\r\n     ...\r\n     </html>\r\n   </pre>\r\n */\r\n\r\nvar ngCspDirective = ['$sniffer', function($sniffer) {\r\n  return {\r\n    priority: 1000,\r\n    compile: function() {\r\n      $sniffer.csp = true;\r\n    }\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngClick\r\n *\r\n * @description\r\n * The ngClick allows you to specify custom behavior when\r\n * element is clicked.\r\n *\r\n * @element ANY\r\n * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon\r\n * click. (Event object is available as `$event`)\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n      <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\r\n        Increment\r\n      </button>\r\n      count: {{count}}\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should check ng-click', function() {\r\n         expect(binding('count')).toBe('0');\r\n         element('.doc-example-live :button').click();\r\n         expect(binding('count')).toBe('1');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\n/*\r\n * A directive that allows creation of custom onclick handlers that are defined as angular\r\n * expressions and are compiled and executed within the current scope.\r\n *\r\n * Events that are handled via these handler are always configured not to propagate further.\r\n */\r\nvar ngEventDirectives = {};\r\nforEach(\r\n  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress'.split(' '),\r\n  function(name) {\r\n    var directiveName = directiveNormalize('ng-' + name);\r\n    ngEventDirectives[directiveName] = ['$parse', function($parse) {\r\n      return function(scope, element, attr) {\r\n        var fn = $parse(attr[directiveName]);\r\n        element.bind(lowercase(name), function(event) {\r\n          scope.$apply(function() {\r\n            fn(scope, {$event:event});\r\n          });\r\n        });\r\n      };\r\n    }];\r\n  }\r\n);\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngDblclick\r\n *\r\n * @description\r\n * The `ngDblclick` directive allows you to specify custom behavior on dblclick event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon\r\n * dblclick. (Event object is available as `$event`)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngMousedown\r\n *\r\n * @description\r\n * The ngMousedown directive allows you to specify custom behavior on mousedown event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon\r\n * mousedown. (Event object is available as `$event`)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngMouseup\r\n *\r\n * @description\r\n * Specify custom behavior on mouseup event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon\r\n * mouseup. (Event object is available as `$event`)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngMouseover\r\n *\r\n * @description\r\n * Specify custom behavior on mouseover event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon\r\n * mouseover. (Event object is available as `$event`)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngMouseenter\r\n *\r\n * @description\r\n * Specify custom behavior on mouseenter event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon\r\n * mouseenter. (Event object is available as `$event`)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngMouseleave\r\n *\r\n * @description\r\n * Specify custom behavior on mouseleave event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon\r\n * mouseleave. (Event object is available as `$event`)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngMousemove\r\n *\r\n * @description\r\n * Specify custom behavior on mousemove event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon\r\n * mousemove. (Event object is available as `$event`)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngKeydown\r\n *\r\n * @description\r\n * Specify custom behavior on keydown event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon\r\n * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngKeyup\r\n *\r\n * @description\r\n * Specify custom behavior on keyup event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon\r\n * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngKeypress\r\n *\r\n * @description\r\n * Specify custom behavior on keypress event.\r\n *\r\n * @element ANY\r\n * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon\r\n * keypress. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\r\n *\r\n * @example\r\n * See {@link ng.directive:ngClick ngClick}\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngSubmit\r\n *\r\n * @description\r\n * Enables binding angular expressions to onsubmit events.\r\n *\r\n * Additionally it prevents the default action (which for form means sending the request to the\r\n * server and reloading the current page).\r\n *\r\n * @element form\r\n * @param {expression} ngSubmit {@link guide/expression Expression} to eval.\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n      <script>\r\n        function Ctrl($scope) {\r\n          $scope.list = [];\r\n          $scope.text = 'hello';\r\n          $scope.submit = function() {\r\n            if (this.text) {\r\n              this.list.push(this.text);\r\n              this.text = '';\r\n            }\r\n          };\r\n        }\r\n      </script>\r\n      <form ng-submit=\"submit()\" ng-controller=\"Ctrl\">\r\n        Enter text and hit enter:\r\n        <input type=\"text\" ng-model=\"text\" name=\"text\" />\r\n        <input type=\"submit\" id=\"submit\" value=\"Submit\" />\r\n        <pre>list={{list}}</pre>\r\n      </form>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should check ng-submit', function() {\r\n         expect(binding('list')).toBe('[]');\r\n         element('.doc-example-live #submit').click();\r\n         expect(binding('list')).toBe('[\"hello\"]');\r\n         expect(input('text').val()).toBe('');\r\n       });\r\n       it('should ignore empty strings', function() {\r\n         expect(binding('list')).toBe('[]');\r\n         element('.doc-example-live #submit').click();\r\n         element('.doc-example-live #submit').click();\r\n         expect(binding('list')).toBe('[\"hello\"]');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\nvar ngSubmitDirective = ngDirective(function(scope, element, attrs) {\r\n  element.bind('submit', function() {\r\n    scope.$apply(attrs.ngSubmit);\r\n  });\r\n});\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngIf\r\n * @restrict A\r\n *\r\n * @description\r\n * The `ngIf` directive removes and recreates a portion of the DOM tree (HTML)\r\n * conditionally based on **\"falsy\"** and **\"truthy\"** values, respectively, evaluated within\r\n * an {expression}. In other words, if the expression assigned to **ngIf evaluates to a false\r\n * value** then **the element is removed from the DOM** and **if true** then **a clone of the\r\n * element is reinserted into the DOM**.\r\n *\r\n * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the\r\n * element in the DOM rather than changing its visibility via the `display` css property.  A common\r\n * case when this difference is significant is when using css selectors that rely on an element's\r\n * position within the DOM (HTML), such as the `:first-child` or `:last-child` pseudo-classes.\r\n *\r\n * Note that **when an element is removed using ngIf its scope is destroyed** and **a new scope\r\n * is created when the element is restored**.  The scope created within `ngIf` inherits from \r\n * its parent scope using\r\n * {@link https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance prototypal inheritance}.\r\n * An important implication of this is if `ngModel` is used within `ngIf` to bind to\r\n * a javascript primitive defined in the parent scope. In this case any modifications made to the\r\n * variable within the child scope will override (hide) the value in the parent scope.\r\n *\r\n * Also, `ngIf` recreates elements using their compiled state. An example scenario of this behavior\r\n * is if an element's class attribute is directly modified after it's compiled, using something like \r\n * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element\r\n * the added class will be lost because the original compiled state is used to regenerate the element.\r\n *\r\n * Additionally, you can provide animations via the ngAnimate attribute to animate the **enter**\r\n * and **leave** effects.\r\n *\r\n * @animations\r\n * enter - happens just after the ngIf contents change and a new DOM element is created and injected into the ngIf container\r\n * leave - happens just before the ngIf contents are removed from the DOM\r\n *\r\n * @element ANY\r\n * @scope\r\n * @param {expression} ngIf If the {@link guide/expression expression} is falsy then\r\n *     the element is removed from the DOM tree (HTML).\r\n *\r\n * @example\r\n  <example animations=\"true\">\r\n    <file name=\"index.html\">\r\n      Click me: <input type=\"checkbox\" ng-model=\"checked\" ng-init=\"checked=true\" /><br/>\r\n      Show when checked:\r\n      <span ng-if=\"checked\" ng-animate=\"'example'\">\r\n        I'm removed when the checkbox is unchecked.\r\n      </span>\r\n    </file>\r\n    <file name=\"animations.css\">\r\n      .example-leave, .example-enter {\r\n        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n      }\r\n\r\n      .example-enter {\r\n        opacity:0;\r\n      }\r\n      .example-enter.example-enter-active {\r\n        opacity:1;\r\n      }\r\n\r\n      .example-leave {\r\n        opacity:1;\r\n      }\r\n      .example-leave.example-leave-active {\r\n        opacity:0;\r\n      }\r\n    </file>\r\n  </example>\r\n */\r\nvar ngIfDirective = ['$animator', function($animator) {\r\n  return {\r\n    transclude: 'element',\r\n    priority: 1000,\r\n    terminal: true,\r\n    restrict: 'A',\r\n    compile: function (element, attr, transclude) {\r\n      return function ($scope, $element, $attr) {\r\n        var animate = $animator($scope, $attr);\r\n        var childElement, childScope;\r\n        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {\r\n          if (childElement) {\r\n            animate.leave(childElement);\r\n            childElement = undefined;\r\n          }\r\n          if (childScope) {\r\n            childScope.$destroy();\r\n            childScope = undefined;\r\n          }\r\n          if (toBoolean(value)) {\r\n            childScope = $scope.$new();\r\n            transclude(childScope, function (clone) {\r\n              childElement = clone;\r\n              animate.enter(clone, $element.parent(), $element);\r\n            });\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngInclude\r\n * @restrict ECA\r\n *\r\n * @description\r\n * Fetches, compiles and includes an external HTML fragment.\r\n *\r\n * Keep in mind that Same Origin Policy applies to included resources\r\n * (e.g. ngInclude won't work for cross-domain requests on all browsers and for\r\n *  file:// access on some browsers).\r\n *\r\n * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**\r\n * and **leave** effects.\r\n *\r\n * @animations\r\n * enter - happens just after the ngInclude contents change and a new DOM element is created and injected into the ngInclude container\r\n * leave - happens just after the ngInclude contents change and just before the former contents are removed from the DOM\r\n *\r\n * @scope\r\n *\r\n * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,\r\n *                 make sure you wrap it in quotes, e.g. `src=\"'myPartialTemplate.html'\"`.\r\n * @param {string=} onload Expression to evaluate when a new partial is loaded.\r\n *\r\n * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll\r\n *                  $anchorScroll} to scroll the viewport after the content is loaded.\r\n *\r\n *                  - If the attribute is not set, disable scrolling.\r\n *                  - If the attribute is set without value, enable scrolling.\r\n *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.\r\n *\r\n * @example\r\n  <example animations=\"true\">\r\n    <file name=\"index.html\">\r\n     <div ng-controller=\"Ctrl\">\r\n       <select ng-model=\"template\" ng-options=\"t.name for t in templates\">\r\n        <option value=\"\">(blank)</option>\r\n       </select>\r\n       url of the template: <tt>{{template.url}}</tt>\r\n       <hr/>\r\n       <div class=\"example-animate-container\"\r\n            ng-include=\"template.url\"\r\n            ng-animate=\"{enter: 'example-enter', leave: 'example-leave'}\"></div>\r\n     </div>\r\n    </file>\r\n    <file name=\"script.js\">\r\n      function Ctrl($scope) {\r\n        $scope.templates =\r\n          [ { name: 'template1.html', url: 'template1.html'}\r\n          , { name: 'template2.html', url: 'template2.html'} ];\r\n        $scope.template = $scope.templates[0];\r\n      }\r\n     </file>\r\n    <file name=\"template1.html\">\r\n      <div>Content of template1.html</div>\r\n    </file>\r\n    <file name=\"template2.html\">\r\n      <div>Content of template2.html</div>\r\n    </file>\r\n    <file name=\"animations.css\">\r\n      .example-leave,\r\n      .example-enter {\r\n        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n\r\n        position:absolute;\r\n        top:0;\r\n        left:0;\r\n        right:0;\r\n        bottom:0;\r\n      }\r\n\r\n      .example-animate-container > * {\r\n        display:block;\r\n        padding:10px;\r\n      }\r\n\r\n      .example-enter {\r\n        top:-50px;\r\n      }\r\n      .example-enter.example-enter-active {\r\n        top:0;\r\n      }\r\n\r\n      .example-leave {\r\n        top:0;\r\n      }\r\n      .example-leave.example-leave-active {\r\n        top:50px;\r\n      }\r\n    </file>\r\n    <file name=\"scenario.js\">\r\n      it('should load template1.html', function() {\r\n       expect(element('.doc-example-live [ng-include]').text()).\r\n         toMatch(/Content of template1.html/);\r\n      });\r\n      it('should load template2.html', function() {\r\n       select('template').option('1');\r\n       expect(element('.doc-example-live [ng-include]').text()).\r\n         toMatch(/Content of template2.html/);\r\n      });\r\n      it('should change to blank', function() {\r\n       select('template').option('');\r\n       expect(element('.doc-example-live [ng-include]').text()).toEqual('');\r\n      });\r\n    </file>\r\n  </example>\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc event\r\n * @name ng.directive:ngInclude#$includeContentRequested\r\n * @eventOf ng.directive:ngInclude\r\n * @eventType emit on the scope ngInclude was declared in\r\n * @description\r\n * Emitted every time the ngInclude content is requested.\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc event\r\n * @name ng.directive:ngInclude#$includeContentLoaded\r\n * @eventOf ng.directive:ngInclude\r\n * @eventType emit on the current ngInclude scope\r\n * @description\r\n * Emitted every time the ngInclude content is reloaded.\r\n */\r\nvar ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$compile', '$animator',\r\n                  function($http,   $templateCache,   $anchorScroll,   $compile,   $animator) {\r\n  return {\r\n    restrict: 'ECA',\r\n    terminal: true,\r\n    compile: function(element, attr) {\r\n      var srcExp = attr.ngInclude || attr.src,\r\n          onloadExp = attr.onload || '',\r\n          autoScrollExp = attr.autoscroll;\r\n\r\n      return function(scope, element, attr) {\r\n        var animate = $animator(scope, attr);\r\n        var changeCounter = 0,\r\n            childScope;\r\n\r\n        var clearContent = function() {\r\n          if (childScope) {\r\n            childScope.$destroy();\r\n            childScope = null;\r\n          }\r\n          animate.leave(element.contents(), element);\r\n        };\r\n\r\n        scope.$watch(srcExp, function ngIncludeWatchAction(src) {\r\n          var thisChangeId = ++changeCounter;\r\n\r\n          if (src) {\r\n            $http.get(src, {cache: $templateCache}).success(function(response) {\r\n              if (thisChangeId !== changeCounter) return;\r\n\r\n              if (childScope) childScope.$destroy();\r\n              childScope = scope.$new();\r\n              animate.leave(element.contents(), element);\r\n\r\n              var contents = jqLite('<div/>').html(response).contents();\r\n\r\n              animate.enter(contents, element);\r\n              $compile(contents)(childScope);\r\n\r\n              if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {\r\n                $anchorScroll();\r\n              }\r\n\r\n              childScope.$emit('$includeContentLoaded');\r\n              scope.$eval(onloadExp);\r\n            }).error(function() {\r\n              if (thisChangeId === changeCounter) clearContent();\r\n            });\r\n            scope.$emit('$includeContentRequested');\r\n          } else {\r\n            clearContent();\r\n          }\r\n        });\r\n      };\r\n    }\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngInit\r\n *\r\n * @description\r\n * The `ngInit` directive specifies initialization tasks to be executed\r\n *  before the template enters execution mode during bootstrap.\r\n *\r\n * @element ANY\r\n * @param {expression} ngInit {@link guide/expression Expression} to eval.\r\n *\r\n * @example\r\n   <doc:example>\r\n     <doc:source>\r\n    <div ng-init=\"greeting='Hello'; person='World'\">\r\n      {{greeting}} {{person}}!\r\n    </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n       it('should check greeting', function() {\r\n         expect(binding('greeting')).toBe('Hello');\r\n         expect(binding('person')).toBe('World');\r\n       });\r\n     </doc:scenario>\r\n   </doc:example>\r\n */\r\nvar ngInitDirective = ngDirective({\r\n  compile: function() {\r\n    return {\r\n      pre: function(scope, element, attrs) {\r\n        scope.$eval(attrs.ngInit);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngNonBindable\r\n * @priority 1000\r\n *\r\n * @description\r\n * Sometimes it is necessary to write code which looks like bindings but which should be left alone\r\n * by angular. Use `ngNonBindable` to make angular ignore a chunk of HTML.\r\n *\r\n * @element ANY\r\n *\r\n * @example\r\n * In this example there are two location where a simple binding (`{{}}`) is present, but the one\r\n * wrapped in `ngNonBindable` is left alone.\r\n *\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n        <div>Normal: {{1 + 2}}</div>\r\n        <div ng-non-bindable>Ignored: {{1 + 2}}</div>\r\n      </doc:source>\r\n      <doc:scenario>\r\n       it('should check ng-non-bindable', function() {\r\n         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');\r\n         expect(using('.doc-example-live').element('div:last').text()).\r\n           toMatch(/1 \\+ 2/);\r\n       });\r\n      </doc:scenario>\r\n    </doc:example>\r\n */\r\nvar ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngPluralize\r\n * @restrict EA\r\n *\r\n * @description\r\n * # Overview\r\n * `ngPluralize` is a directive that displays messages according to en-US localization rules.\r\n * These rules are bundled with angular.js and the rules can be overridden\r\n * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive\r\n * by specifying the mappings between\r\n * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\r\n * plural categories} and the strings to be displayed.\r\n *\r\n * # Plural categories and explicit number rules\r\n * There are two\r\n * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\r\n * plural categories} in Angular's default en-US locale: \"one\" and \"other\".\r\n *\r\n * While a plural category may match many numbers (for example, in en-US locale, \"other\" can match\r\n * any number that is not 1), an explicit number rule can only match one number. For example, the\r\n * explicit number rule for \"3\" matches the number 3. You will see the use of plural categories\r\n * and explicit number rules throughout later parts of this documentation.\r\n *\r\n * # Configuring ngPluralize\r\n * You configure ngPluralize by providing 2 attributes: `count` and `when`.\r\n * You can also provide an optional attribute, `offset`.\r\n *\r\n * The value of the `count` attribute can be either a string or an {@link guide/expression\r\n * Angular expression}; these are evaluated on the current scope for its bound value.\r\n *\r\n * The `when` attribute specifies the mappings between plural categories and the actual\r\n * string to be displayed. The value of the attribute should be a JSON object so that Angular\r\n * can interpret it correctly.\r\n *\r\n * The following example shows how to configure ngPluralize:\r\n *\r\n * <pre>\r\n * <ng-pluralize count=\"personCount\"\r\n                 when=\"{'0': 'Nobody is viewing.',\r\n *                      'one': '1 person is viewing.',\r\n *                      'other': '{} people are viewing.'}\">\r\n * </ng-pluralize>\r\n *</pre>\r\n *\r\n * In the example, `\"0: Nobody is viewing.\"` is an explicit number rule. If you did not\r\n * specify this rule, 0 would be matched to the \"other\" category and \"0 people are viewing\"\r\n * would be shown instead of \"Nobody is viewing\". You can specify an explicit number rule for\r\n * other numbers, for example 12, so that instead of showing \"12 people are viewing\", you can\r\n * show \"a dozen people are viewing\".\r\n *\r\n * You can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted\r\n * into pluralized strings. In the previous example, Angular will replace `{}` with\r\n * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder\r\n * for <span ng-non-bindable>{{numberExpression}}</span>.\r\n *\r\n * # Configuring ngPluralize with offset\r\n * The `offset` attribute allows further customization of pluralized text, which can result in\r\n * a better user experience. For example, instead of the message \"4 people are viewing this document\",\r\n * you might display \"John, Kate and 2 others are viewing this document\".\r\n * The offset attribute allows you to offset a number by any desired value.\r\n * Let's take a look at an example:\r\n *\r\n * <pre>\r\n * <ng-pluralize count=\"personCount\" offset=2\r\n *               when=\"{'0': 'Nobody is viewing.',\r\n *                      '1': '{{person1}} is viewing.',\r\n *                      '2': '{{person1}} and {{person2}} are viewing.',\r\n *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',\r\n *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\r\n * </ng-pluralize>\r\n * </pre>\r\n *\r\n * Notice that we are still using two plural categories(one, other), but we added\r\n * three explicit number rules 0, 1 and 2.\r\n * When one person, perhaps John, views the document, \"John is viewing\" will be shown.\r\n * When three people view the document, no explicit number rule is found, so\r\n * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.\r\n * In this case, plural category 'one' is matched and \"John, Marry and one other person are viewing\"\r\n * is shown.\r\n *\r\n * Note that when you specify offsets, you must provide explicit number rules for\r\n * numbers from 0 up to and including the offset. If you use an offset of 3, for example,\r\n * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for\r\n * plural categories \"one\" and \"other\".\r\n *\r\n * @param {string|expression} count The variable to be bounded to.\r\n * @param {string} when The mapping between plural category to its corresponding strings.\r\n * @param {number=} offset Offset to deduct from the total number.\r\n *\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n        <script>\r\n          function Ctrl($scope) {\r\n            $scope.person1 = 'Igor';\r\n            $scope.person2 = 'Misko';\r\n            $scope.personCount = 1;\r\n          }\r\n        </script>\r\n        <div ng-controller=\"Ctrl\">\r\n          Person 1:<input type=\"text\" ng-model=\"person1\" value=\"Igor\" /><br/>\r\n          Person 2:<input type=\"text\" ng-model=\"person2\" value=\"Misko\" /><br/>\r\n          Number of People:<input type=\"text\" ng-model=\"personCount\" value=\"1\" /><br/>\r\n\r\n          <!--- Example with simple pluralization rules for en locale --->\r\n          Without Offset:\r\n          <ng-pluralize count=\"personCount\"\r\n                        when=\"{'0': 'Nobody is viewing.',\r\n                               'one': '1 person is viewing.',\r\n                               'other': '{} people are viewing.'}\">\r\n          </ng-pluralize><br>\r\n\r\n          <!--- Example with offset --->\r\n          With Offset(2):\r\n          <ng-pluralize count=\"personCount\" offset=2\r\n                        when=\"{'0': 'Nobody is viewing.',\r\n                               '1': '{{person1}} is viewing.',\r\n                               '2': '{{person1}} and {{person2}} are viewing.',\r\n                               'one': '{{person1}}, {{person2}} and one other person are viewing.',\r\n                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\r\n          </ng-pluralize>\r\n        </div>\r\n      </doc:source>\r\n      <doc:scenario>\r\n        it('should show correct pluralized string', function() {\r\n          expect(element('.doc-example-live ng-pluralize:first').text()).\r\n                                             toBe('1 person is viewing.');\r\n          expect(element('.doc-example-live ng-pluralize:last').text()).\r\n                                                toBe('Igor is viewing.');\r\n\r\n          using('.doc-example-live').input('personCount').enter('0');\r\n          expect(element('.doc-example-live ng-pluralize:first').text()).\r\n                                               toBe('Nobody is viewing.');\r\n          expect(element('.doc-example-live ng-pluralize:last').text()).\r\n                                              toBe('Nobody is viewing.');\r\n\r\n          using('.doc-example-live').input('personCount').enter('2');\r\n          expect(element('.doc-example-live ng-pluralize:first').text()).\r\n                                            toBe('2 people are viewing.');\r\n          expect(element('.doc-example-live ng-pluralize:last').text()).\r\n                              toBe('Igor and Misko are viewing.');\r\n\r\n          using('.doc-example-live').input('personCount').enter('3');\r\n          expect(element('.doc-example-live ng-pluralize:first').text()).\r\n                                            toBe('3 people are viewing.');\r\n          expect(element('.doc-example-live ng-pluralize:last').text()).\r\n                              toBe('Igor, Misko and one other person are viewing.');\r\n\r\n          using('.doc-example-live').input('personCount').enter('4');\r\n          expect(element('.doc-example-live ng-pluralize:first').text()).\r\n                                            toBe('4 people are viewing.');\r\n          expect(element('.doc-example-live ng-pluralize:last').text()).\r\n                              toBe('Igor, Misko and 2 other people are viewing.');\r\n        });\r\n\r\n        it('should show data-binded names', function() {\r\n          using('.doc-example-live').input('personCount').enter('4');\r\n          expect(element('.doc-example-live ng-pluralize:last').text()).\r\n              toBe('Igor, Misko and 2 other people are viewing.');\r\n\r\n          using('.doc-example-live').input('person1').enter('Di');\r\n          using('.doc-example-live').input('person2').enter('Vojta');\r\n          expect(element('.doc-example-live ng-pluralize:last').text()).\r\n              toBe('Di, Vojta and 2 other people are viewing.');\r\n        });\r\n      </doc:scenario>\r\n    </doc:example>\r\n */\r\nvar ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {\r\n  var BRACE = /{}/g;\r\n  return {\r\n    restrict: 'EA',\r\n    link: function(scope, element, attr) {\r\n      var numberExp = attr.count,\r\n          whenExp = element.attr(attr.$attr.when), // this is because we have {{}} in attrs\r\n          offset = attr.offset || 0,\r\n          whens = scope.$eval(whenExp),\r\n          whensExpFns = {},\r\n          startSymbol = $interpolate.startSymbol(),\r\n          endSymbol = $interpolate.endSymbol();\r\n\r\n      forEach(whens, function(expression, key) {\r\n        whensExpFns[key] =\r\n          $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' +\r\n            offset + endSymbol));\r\n      });\r\n\r\n      scope.$watch(function ngPluralizeWatch() {\r\n        var value = parseFloat(scope.$eval(numberExp));\r\n\r\n        if (!isNaN(value)) {\r\n          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,\r\n          //check it against pluralization rules in $locale service\r\n          if (!(value in whens)) value = $locale.pluralCat(value - offset);\r\n           return whensExpFns[value](scope, element, true);\r\n        } else {\r\n          return '';\r\n        }\r\n      }, function ngPluralizeWatchAction(newVal) {\r\n        element.text(newVal);\r\n      });\r\n    }\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngRepeat\r\n *\r\n * @description\r\n * The `ngRepeat` directive instantiates a template once per item from a collection. Each template\r\n * instance gets its own scope, where the given loop variable is set to the current collection item,\r\n * and `$index` is set to the item index or key.\r\n *\r\n * Special properties are exposed on the local scope of each template instance, including:\r\n *\r\n *   * `$index`  `{number}`  iterator offset of the repeated element (0..length-1)\r\n *   * `$first`  `{boolean}`  true if the repeated element is first in the iterator.\r\n *   * `$middle`  `{boolean}`  true if the repeated element is between the first and last in the iterator.\r\n *   * `$last`  `{boolean}`  true if the repeated element is last in the iterator.\r\n *\r\n * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**,\r\n * **leave** and **move** effects.\r\n *\r\n * @animations\r\n * enter - when a new item is added to the list or when an item is revealed after a filter\r\n * leave - when an item is removed from the list or when an item is filtered out\r\n * move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered\r\n *\r\n * @element ANY\r\n * @scope\r\n * @priority 1000\r\n * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These\r\n *   formats are currently supported:\r\n *\r\n *   * `variable in expression`  where variable is the user defined loop variable and `expression`\r\n *     is a scope expression giving the collection to enumerate.\r\n *\r\n *     For example: `track in cd.tracks`.\r\n *\r\n *   * `(key, value) in expression`  where `key` and `value` can be any user defined identifiers,\r\n *     and `expression` is the scope expression giving the collection to enumerate.\r\n *\r\n *     For example: `(name, age) in {'adam':10, 'amalie':12}`.\r\n *\r\n *   * `variable in expression track by tracking_expression`  You can also provide an optional tracking function\r\n *     which can be used to associate the objects in the collection with the DOM elements. If no tractking function\r\n *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have\r\n *     more then one tractking function to  resolve to the same key. (This would mean that two distinct objects are\r\n *     mapped to the same DOM element, which is not possible.)\r\n *\r\n *     For example: `item in items` is equivalent to `item in items track by $id(item)'. This implies that the DOM elements\r\n *     will be associated by item identity in the array.\r\n *\r\n *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique\r\n *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements\r\n *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM\r\n *     element in the same way ian the DOM.\r\n *\r\n *     For example: `item in items track by item.id` Is a typical pattern when the items come from the database. In this\r\n *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`\r\n *     property is same.\r\n *\r\n * @example\r\n * This example initializes the scope to a list of names and\r\n * then uses `ngRepeat` to display every person:\r\n  <example animations=\"true\">\r\n    <file name=\"index.html\">\r\n      <div ng-init=\"friends = [\r\n        {name:'John', age:25, gender:'boy'},\r\n        {name:'Jessie', age:30, gender:'girl'},\r\n        {name:'Johanna', age:28, gender:'girl'},\r\n        {name:'Joy', age:15, gender:'girl'},\r\n        {name:'Mary', age:28, gender:'girl'},\r\n        {name:'Peter', age:95, gender:'boy'},\r\n        {name:'Sebastian', age:50, gender:'boy'},\r\n        {name:'Erika', age:27, gender:'girl'},\r\n        {name:'Patrick', age:40, gender:'boy'},\r\n        {name:'Samantha', age:60, gender:'girl'}\r\n      ]\">\r\n        I have {{friends.length}} friends. They are:\r\n        <input type=\"search\" ng-model=\"q\" placeholder=\"filter friends...\" />\r\n        <ul>\r\n          <li ng-repeat=\"friend in friends | filter:q\"\r\n              ng-animate=\"{enter: 'example-repeat-enter',\r\n                          leave: 'example-repeat-leave',\r\n                          move: 'example-repeat-move'}\">\r\n            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </file>\r\n    <file name=\"animations.css\">\r\n      .example-repeat-enter,\r\n      .example-repeat-leave,\r\n      .example-repeat-move {\r\n        -webkit-transition:all linear 0.5s;\r\n        -moz-transition:all linear 0.5s;\r\n        -ms-transition:all linear 0.5s;\r\n        -o-transition:all linear 0.5s;\r\n        transition:all linear 0.5s;\r\n      }\r\n\r\n      .example-repeat-enter {\r\n        line-height:0;\r\n        opacity:0;\r\n      }\r\n      .example-repeat-enter.example-repeat-enter-active {\r\n        line-height:20px;\r\n        opacity:1;\r\n      }\r\n\r\n      .example-repeat-leave {\r\n        opacity:1;\r\n        line-height:20px;\r\n      }\r\n      .example-repeat-leave.example-repeat-leave-active {\r\n        opacity:0;\r\n        line-height:0;\r\n      }\r\n\r\n      .example-repeat-move { }\r\n      .example-repeat-move.example-repeat-move-active { }\r\n    </file>\r\n    <file name=\"scenario.js\">\r\n       it('should render initial data set', function() {\r\n         var r = using('.doc-example-live').repeater('ul li');\r\n         expect(r.count()).toBe(10);\r\n         expect(r.row(0)).toEqual([\"1\",\"John\",\"25\"]);\r\n         expect(r.row(1)).toEqual([\"2\",\"Jessie\",\"30\"]);\r\n         expect(r.row(9)).toEqual([\"10\",\"Samantha\",\"60\"]);\r\n         expect(binding('friends.length')).toBe(\"10\");\r\n       });\r\n\r\n       it('should update repeater when filter predicate changes', function() {\r\n         var r = using('.doc-example-live').repeater('ul li');\r\n         expect(r.count()).toBe(10);\r\n\r\n         input('q').enter('ma');\r\n\r\n         expect(r.count()).toBe(2);\r\n         expect(r.row(0)).toEqual([\"1\",\"Mary\",\"28\"]);\r\n         expect(r.row(1)).toEqual([\"2\",\"Samantha\",\"60\"]);\r\n       });\r\n      </file>\r\n    </example>\r\n */\r\nvar ngRepeatDirective = ['$parse', '$animator', function($parse, $animator) {\r\n  var NG_REMOVED = '$$NG_REMOVED';\r\n  return {\r\n    transclude: 'element',\r\n    priority: 1000,\r\n    terminal: true,\r\n    compile: function(element, attr, linker) {\r\n      return function($scope, $element, $attr){\r\n        var animate = $animator($scope, $attr);\r\n        var expression = $attr.ngRepeat;\r\n        var match = expression.match(/^\\s*(.+)\\s+in\\s+(.*?)\\s*(\\s+track\\s+by\\s+(.+)\\s*)?$/),\r\n          trackByExp, trackByExpGetter, trackByIdFn, lhs, rhs, valueIdentifier, keyIdentifier,\r\n          hashFnLocals = {$id: hashKey};\r\n\r\n        if (!match) {\r\n          throw Error(\"Expected ngRepeat in form of '_item_ in _collection_[ track by _id_]' but got '\" +\r\n            expression + \"'.\");\r\n        }\r\n\r\n        lhs = match[1];\r\n        rhs = match[2];\r\n        trackByExp = match[4];\r\n\r\n        if (trackByExp) {\r\n          trackByExpGetter = $parse(trackByExp);\r\n          trackByIdFn = function(key, value, index) {\r\n            // assign key, value, and $index to the locals so that they can be used in hash functions\r\n            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;\r\n            hashFnLocals[valueIdentifier] = value;\r\n            hashFnLocals.$index = index;\r\n            return trackByExpGetter($scope, hashFnLocals);\r\n          };\r\n        } else {\r\n          trackByIdFn = function(key, value) {\r\n            return hashKey(value);\r\n          }\r\n        }\r\n\r\n        match = lhs.match(/^(?:([\\$\\w]+)|\\(([\\$\\w]+)\\s*,\\s*([\\$\\w]+)\\))$/);\r\n        if (!match) {\r\n          throw Error(\"'item' in 'item in collection' should be identifier or (key, value) but got '\" +\r\n              lhs + \"'.\");\r\n        }\r\n        valueIdentifier = match[3] || match[1];\r\n        keyIdentifier = match[2];\r\n\r\n        // Store a list of elements from previous run. This is a hash where key is the item from the\r\n        // iterator, and the value is objects with following properties.\r\n        //   - scope: bound scope\r\n        //   - element: previous element.\r\n        //   - index: position\r\n        var lastBlockMap = {};\r\n\r\n        //watch props\r\n        $scope.$watchCollection(rhs, function ngRepeatAction(collection){\r\n          var index, length,\r\n              cursor = $element,     // current position of the node\r\n              nextCursor,\r\n              // Same as lastBlockMap but it has the current state. It will become the\r\n              // lastBlockMap on the next iteration.\r\n              nextBlockMap = {},\r\n              arrayLength,\r\n              childScope,\r\n              key, value, // key/value of iteration\r\n              trackById,\r\n              collectionKeys,\r\n              block,       // last object information {scope, element, id}\r\n              nextBlockOrder = [];\r\n\r\n\r\n          if (isArrayLike(collection)) {\r\n            collectionKeys = collection;\r\n          } else {\r\n            // if object, extract keys, sort them and use to determine order of iteration over obj props\r\n            collectionKeys = [];\r\n            for (key in collection) {\r\n              if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {\r\n                collectionKeys.push(key);\r\n              }\r\n            }\r\n            collectionKeys.sort();\r\n          }\r\n\r\n          arrayLength = collectionKeys.length;\r\n\r\n          // locate existing items\r\n          length = nextBlockOrder.length = collectionKeys.length;\r\n          for(index = 0; index < length; index++) {\r\n           key = (collection === collectionKeys) ? index : collectionKeys[index];\r\n           value = collection[key];\r\n           trackById = trackByIdFn(key, value, index);\r\n           if(lastBlockMap.hasOwnProperty(trackById)) {\r\n             block = lastBlockMap[trackById]\r\n             delete lastBlockMap[trackById];\r\n             nextBlockMap[trackById] = block;\r\n             nextBlockOrder[index] = block;\r\n           } else if (nextBlockMap.hasOwnProperty(trackById)) {\r\n             // restore lastBlockMap\r\n             forEach(nextBlockOrder, function(block) {\r\n               if (block && block.element) lastBlockMap[block.id] = block;\r\n             });\r\n             // This is a duplicate and we need to throw an error\r\n             throw new Error('Duplicates in a repeater are not allowed. Repeater: ' + expression +\r\n                 ' key: ' + trackById);\r\n           } else {\r\n             // new never before seen block\r\n             nextBlockOrder[index] = { id: trackById };\r\n             nextBlockMap[trackById] = false;\r\n           }\r\n         }\r\n\r\n          // remove existing items\r\n          for (key in lastBlockMap) {\r\n            if (lastBlockMap.hasOwnProperty(key)) {\r\n              block = lastBlockMap[key];\r\n              animate.leave(block.element);\r\n              block.element[0][NG_REMOVED] = true;\r\n              block.scope.$destroy();\r\n            }\r\n          }\r\n\r\n          // we are not using forEach for perf reasons (trying to avoid #call)\r\n          for (index = 0, length = collectionKeys.length; index < length; index++) {\r\n            key = (collection === collectionKeys) ? index : collectionKeys[index];\r\n            value = collection[key];\r\n            block = nextBlockOrder[index];\r\n\r\n            if (block.element) {\r\n              // if we have already seen this object, then we need to reuse the\r\n              // associated scope/element\r\n              childScope = block.scope;\r\n\r\n              nextCursor = cursor[0];\r\n              do {\r\n                nextCursor = nextCursor.nextSibling;\r\n              } while(nextCursor && nextCursor[NG_REMOVED]);\r\n\r\n              if (block.element[0] == nextCursor) {\r\n                // do nothing\r\n                cursor = block.element;\r\n              } else {\r\n                // existing item which got moved\r\n                animate.move(block.element, null, cursor);\r\n                cursor = block.element;\r\n              }\r\n            } else {\r\n              // new item which we don't know about\r\n              childScope = $scope.$new();\r\n            }\r\n\r\n            childScope[valueIdentifier] = value;\r\n            if (keyIdentifier) childScope[keyIdentifier] = key;\r\n            childScope.$index = index;\r\n            childScope.$first = (index === 0);\r\n            childScope.$last = (index === (arrayLength - 1));\r\n            childScope.$middle = !(childScope.$first || childScope.$last);\r\n\r\n            if (!block.element) {\r\n              linker(childScope, function(clone) {\r\n                animate.enter(clone, null, cursor);\r\n                cursor = clone;\r\n                block.scope = childScope;\r\n                block.element = clone;\r\n                nextBlockMap[block.id] = block;\r\n              });\r\n            }\r\n          }\r\n          lastBlockMap = nextBlockMap;\r\n        });\r\n      };\r\n    }\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngShow\r\n *\r\n * @description\r\n * The `ngShow` and `ngHide` directives show or hide a portion of the DOM tree (HTML)\r\n * conditionally based on **\"truthy\"** values evaluated within an {expression}. In other\r\n * words, if the expression assigned to **ngShow evaluates to a true value** then **the element is set to visible**\r\n * (via `display:block` in css) and **if false** then **the element is set to hidden** (so display:none).\r\n * With ngHide this is the reverse whereas true values cause the element itself to become\r\n * hidden.\r\n *\r\n * Additionally, you can also provide animations via the ngAnimate attribute to animate the **show**\r\n * and **hide** effects.\r\n *\r\n * @animations\r\n * show - happens after the ngShow expression evaluates to a truthy value and the contents are set to visible\r\n * hide - happens before the ngShow expression evaluates to a non truthy value and just before the contents are set to hidden\r\n *\r\n * @element ANY\r\n * @param {expression} ngShow If the {@link guide/expression expression} is truthy\r\n *     then the element is shown or hidden respectively.\r\n *\r\n * @example\r\n  <example animations=\"true\">\r\n    <file name=\"index.html\">\r\n      Click me: <input type=\"checkbox\" ng-model=\"checked\"><br/>\r\n      <div>\r\n        Show:\r\n        <span class=\"check-element\"\r\n              ng-show=\"checked\"\r\n              ng-animate=\"{show: 'example-show', hide: 'example-hide'}\">\r\n          <span class=\"icon-thumbs-up\"></span> I show up when your checkbox is checked.\r\n        </span>\r\n      </div>\r\n      <div>\r\n        Hide:\r\n        <span class=\"check-element\"\r\n              ng-hide=\"checked\"\r\n              ng-animate=\"{show: 'example-show', hide: 'example-hide'}\">\r\n          <span class=\"icon-thumbs-down\"></span> I hide when your checkbox is checked.\r\n        </span>\r\n      </div>\r\n    </file>\r\n    <file name=\"animations.css\">\r\n      .example-show, .example-hide {\r\n        -webkit-transition:all linear 0.5s;\r\n        -moz-transition:all linear 0.5s;\r\n        -ms-transition:all linear 0.5s;\r\n        -o-transition:all linear 0.5s;\r\n        transition:all linear 0.5s;\r\n      }\r\n\r\n      .example-show {\r\n        line-height:0;\r\n        opacity:0;\r\n        padding:0 10px;\r\n      }\r\n      .example-show-active.example-show-active {\r\n        line-height:20px;\r\n        opacity:1;\r\n        padding:10px;\r\n        border:1px solid black;\r\n        background:white;\r\n      }\r\n\r\n      .example-hide {\r\n        line-height:20px;\r\n        opacity:1;\r\n        padding:10px;\r\n        border:1px solid black;\r\n        background:white;\r\n      }\r\n      .example-hide-active.example-hide-active {\r\n        line-height:0;\r\n        opacity:0;\r\n        padding:0 10px;\r\n      }\r\n\r\n      .check-element {\r\n        padding:10px;\r\n        border:1px solid black;\r\n        background:white;\r\n      }\r\n    </file>\r\n    <file name=\"scenario.js\">\r\n       it('should check ng-show / ng-hide', function() {\r\n         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);\r\n         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);\r\n\r\n         input('checked').check();\r\n\r\n         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);\r\n         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);\r\n       });\r\n    </file>\r\n  </example>\r\n */\r\n//TODO(misko): refactor to remove element from the DOM\r\nvar ngShowDirective = ['$animator', function($animator) {\r\n  return function(scope, element, attr) {\r\n    var animate = $animator(scope, attr);\r\n    scope.$watch(attr.ngShow, function ngShowWatchAction(value){\r\n      animate[toBoolean(value) ? 'show' : 'hide'](element);\r\n    });\r\n  };\r\n}];\r\n\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngHide\r\n *\r\n * @description\r\n * The `ngShow` and `ngHide` directives show or hide a portion of the DOM tree (HTML)\r\n * conditionally based on **\"truthy\"** values evaluated within an {expression}. In other\r\n * words, if the expression assigned to **ngShow evaluates to a true value** then **the element is set to visible**\r\n * (via `display:block` in css) and **if false** then **the element is set to hidden** (so display:none).\r\n * With ngHide this is the reverse whereas true values cause the element itself to become\r\n * hidden.\r\n *\r\n * Additionally, you can also provide animations via the ngAnimate attribute to animate the **show**\r\n * and **hide** effects.\r\n *\r\n * @animations\r\n * show - happens after the ngHide expression evaluates to a non truthy value and the contents are set to visible\r\n * hide - happens after the ngHide expression evaluates to a truthy value and just before the contents are set to hidden\r\n *\r\n * @element ANY\r\n * @param {expression} ngHide If the {@link guide/expression expression} is truthy then\r\n *     the element is shown or hidden respectively.\r\n *\r\n * @example\r\n  <example animations=\"true\">\r\n    <file name=\"index.html\">\r\n      Click me: <input type=\"checkbox\" ng-model=\"checked\"><br/>\r\n      <div>\r\n        Show:\r\n        <span class=\"check-element\"\r\n              ng-show=\"checked\"\r\n              ng-animate=\"{show: 'example-show', hide: 'example-hide'}\">\r\n          <span class=\"icon-thumbs-up\"></span> I show up when your checkbox is checked.\r\n        </span>\r\n      </div>\r\n      <div>\r\n        Hide:\r\n        <span class=\"check-element\"\r\n              ng-hide=\"checked\"\r\n              ng-animate=\"{show: 'example-show', hide: 'example-hide'}\">\r\n          <span class=\"icon-thumbs-down\"></span> I hide when your checkbox is checked.\r\n        </span>\r\n      </div>\r\n    </file>\r\n    <file name=\"animations.css\">\r\n      .example-show, .example-hide {\r\n        -webkit-transition:all linear 0.5s;\r\n        -moz-transition:all linear 0.5s;\r\n        -ms-transition:all linear 0.5s;\r\n        -o-transition:all linear 0.5s;\r\n        transition:all linear 0.5s;\r\n      }\r\n\r\n      .example-show {\r\n        line-height:0;\r\n        opacity:0;\r\n        padding:0 10px;\r\n      }\r\n      .example-show.example-show-active {\r\n        line-height:20px;\r\n        opacity:1;\r\n        padding:10px;\r\n        border:1px solid black;\r\n        background:white;\r\n      }\r\n\r\n      .example-hide {\r\n        line-height:20px;\r\n        opacity:1;\r\n        padding:10px;\r\n        border:1px solid black;\r\n        background:white;\r\n      }\r\n      .example-hide.example-hide-active {\r\n        line-height:0;\r\n        opacity:0;\r\n        padding:0 10px;\r\n      }\r\n\r\n      .check-element {\r\n        padding:10px;\r\n        border:1px solid black;\r\n        background:white;\r\n      }\r\n    </file>\r\n    <file name=\"scenario.js\">\r\n       it('should check ng-show / ng-hide', function() {\r\n         expect(element('.doc-example-live .check-element:first:hidden').count()).toEqual(1);\r\n         expect(element('.doc-example-live .check-element:last:visible').count()).toEqual(1);\r\n\r\n         input('checked').check();\r\n\r\n         expect(element('.doc-example-live .check-element:first:visible').count()).toEqual(1);\r\n         expect(element('.doc-example-live .check-element:last:hidden').count()).toEqual(1);\r\n       });\r\n    </file>\r\n  </example>\r\n */\r\n//TODO(misko): refactor to remove element from the DOM\r\nvar ngHideDirective = ['$animator', function($animator) {\r\n  return function(scope, element, attr) {\r\n    var animate = $animator(scope, attr);\r\n    scope.$watch(attr.ngHide, function ngHideWatchAction(value){\r\n      animate[toBoolean(value) ? 'hide' : 'show'](element);\r\n    });\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngStyle\r\n *\r\n * @description\r\n * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.\r\n *\r\n * @element ANY\r\n * @param {expression} ngStyle {@link guide/expression Expression} which evals to an\r\n *      object whose keys are CSS style names and values are corresponding values for those CSS\r\n *      keys.\r\n *\r\n * @example\r\n   <example>\r\n     <file name=\"index.html\">\r\n        <input type=\"button\" value=\"set\" ng-click=\"myStyle={color:'red'}\">\r\n        <input type=\"button\" value=\"clear\" ng-click=\"myStyle={}\">\r\n        <br/>\r\n        <span ng-style=\"myStyle\">Sample Text</span>\r\n        <pre>myStyle={{myStyle}}</pre>\r\n     </file>\r\n     <file name=\"style.css\">\r\n       span {\r\n         color: black;\r\n       }\r\n     </file>\r\n     <file name=\"scenario.js\">\r\n       it('should check ng-style', function() {\r\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');\r\n         element('.doc-example-live :button[value=set]').click();\r\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');\r\n         element('.doc-example-live :button[value=clear]').click();\r\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');\r\n       });\r\n     </file>\r\n   </example>\r\n */\r\nvar ngStyleDirective = ngDirective(function(scope, element, attr) {\r\n  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {\r\n    if (oldStyles && (newStyles !== oldStyles)) {\r\n      forEach(oldStyles, function(val, style) { element.css(style, '');});\r\n    }\r\n    if (newStyles) element.css(newStyles);\r\n  }, true);\r\n});\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngSwitch\r\n * @restrict EA\r\n *\r\n * @description\r\n * The ngSwitch directive is used to conditionally swap DOM structure on your template based on a scope expression.\r\n * Elements within ngSwitch but without ngSwitchWhen or ngSwitchDefault directives will be preserved at the location\r\n * as specified in the template.\r\n *\r\n * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it\r\n * from the template cache), ngSwitch simply choses one of the nested elements and makes it visible based on which element\r\n * matches the value obtained from the evaluated expression. In other words, you define a container element\r\n * (where you place the directive), place an expression on the **on=\"...\" attribute**\r\n * (or the **ng-switch=\"...\" attribute**), define any inner elements inside of the directive and place\r\n * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on\r\n * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default\r\n * attribute is displayed.\r\n *\r\n * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**\r\n * and **leave** effects.\r\n *\r\n * @animations\r\n * enter - happens after the ngSwtich contents change and the matched child element is placed inside the container\r\n * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM\r\n *\r\n * @usage\r\n * <ANY ng-switch=\"expression\">\r\n *   <ANY ng-switch-when=\"matchValue1\">...</ANY>\r\n *   <ANY ng-switch-when=\"matchValue2\">...</ANY>\r\n *   <ANY ng-switch-default>...</ANY>\r\n * </ANY>\r\n *\r\n * @scope\r\n * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.\r\n * @paramDescription\r\n * On child elements add:\r\n *\r\n * * `ngSwitchWhen`: the case statement to match against. If match then this\r\n *   case will be displayed. If the same match appears multiple times, all the\r\n *   elements will be displayed.\r\n * * `ngSwitchDefault`: the default case when no other case match. If there\r\n *   are multiple default cases, all of them will be displayed when no other\r\n *   case match.\r\n *\r\n *\r\n * @example\r\n  <example animations=\"true\">\r\n    <file name=\"index.html\">\r\n      <div ng-controller=\"Ctrl\">\r\n        <select ng-model=\"selection\" ng-options=\"item for item in items\">\r\n        </select>\r\n        <tt>selection={{selection}}</tt>\r\n        <hr/>\r\n        <div\r\n          class=\"example-animate-container\"\r\n          ng-switch on=\"selection\"\r\n          ng-animate=\"{enter: 'example-enter', leave: 'example-leave'}\">\r\n            <div ng-switch-when=\"settings\">Settings Div</div>\r\n            <div ng-switch-when=\"home\">Home Span</div>\r\n            <div ng-switch-default>default</div>\r\n        </div>\r\n      </div>\r\n    </file>\r\n    <file name=\"script.js\">\r\n      function Ctrl($scope) {\r\n        $scope.items = ['settings', 'home', 'other'];\r\n        $scope.selection = $scope.items[0];\r\n      }\r\n    </file>\r\n    <file name=\"animations.css\">\r\n      .example-leave, .example-enter {\r\n        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\r\n\r\n        position:absolute;\r\n        top:0;\r\n        left:0;\r\n        right:0;\r\n        bottom:0;\r\n      }\r\n\r\n      .example-animate-container > * {\r\n        display:block;\r\n        padding:10px;\r\n      }\r\n\r\n      .example-enter {\r\n        top:-50px;\r\n      }\r\n      .example-enter.example-enter-active {\r\n        top:0;\r\n      }\r\n\r\n      .example-leave {\r\n        top:0;\r\n      }\r\n      .example-leave.example-leave-active {\r\n        top:50px;\r\n      }\r\n    </file>\r\n    <file name=\"scenario.js\">\r\n      it('should start in settings', function() {\r\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);\r\n      });\r\n      it('should change to home', function() {\r\n        select('selection').option('home');\r\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);\r\n      });\r\n      it('should select default', function() {\r\n        select('selection').option('other');\r\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);\r\n      });\r\n    </file>\r\n  </example>\r\n */\r\nvar ngSwitchDirective = ['$animator', function($animator) {\r\n  return {\r\n    restrict: 'EA',\r\n    require: 'ngSwitch',\r\n\r\n    // asks for $scope to fool the BC controller module\r\n    controller: ['$scope', function ngSwitchController() {\r\n     this.cases = {};\r\n    }],\r\n    link: function(scope, element, attr, ngSwitchController) {\r\n      var animate = $animator(scope, attr);\r\n      var watchExpr = attr.ngSwitch || attr.on,\r\n          selectedTranscludes,\r\n          selectedElements,\r\n          selectedScopes = [];\r\n\r\n      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {\r\n        for (var i= 0, ii=selectedScopes.length; i<ii; i++) {\r\n          selectedScopes[i].$destroy();\r\n          animate.leave(selectedElements[i]);\r\n        }\r\n\r\n        selectedElements = [];\r\n        selectedScopes = [];\r\n\r\n        if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {\r\n          scope.$eval(attr.change);\r\n          forEach(selectedTranscludes, function(selectedTransclude) {\r\n            var selectedScope = scope.$new();\r\n            selectedScopes.push(selectedScope);\r\n            selectedTransclude.transclude(selectedScope, function(caseElement) {\r\n              var anchor = selectedTransclude.element;\r\n\r\n              selectedElements.push(caseElement);\r\n              animate.enter(caseElement, anchor.parent(), anchor);\r\n            });\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n}];\r\n\r\nvar ngSwitchWhenDirective = ngDirective({\r\n  transclude: 'element',\r\n  priority: 500,\r\n  require: '^ngSwitch',\r\n  compile: function(element, attrs, transclude) {\r\n    return function(scope, element, attr, ctrl) {\r\n      ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);\r\n      ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: transclude, element: element });\r\n    };\r\n  }\r\n});\r\n\r\nvar ngSwitchDefaultDirective = ngDirective({\r\n  transclude: 'element',\r\n  priority: 500,\r\n  require: '^ngSwitch',\r\n  compile: function(element, attrs, transclude) {\r\n    return function(scope, element, attr, ctrl) {\r\n      ctrl.cases['?'] = (ctrl.cases['?'] || []);\r\n      ctrl.cases['?'].push({ transclude: transclude, element: element });\r\n    };\r\n  }\r\n});\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngTransclude\r\n *\r\n * @description\r\n * Insert the transcluded DOM here.\r\n *\r\n * @element ANY\r\n *\r\n * @example\r\n   <doc:example module=\"transclude\">\r\n     <doc:source>\r\n       <script>\r\n         function Ctrl($scope) {\r\n           $scope.title = 'Lorem Ipsum';\r\n           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';\r\n         }\r\n\r\n         angular.module('transclude', [])\r\n          .directive('pane', function(){\r\n             return {\r\n               restrict: 'E',\r\n               transclude: true,\r\n               scope: 'isolate',\r\n               locals: { title:'bind' },\r\n               template: '<div style=\"border: 1px solid black;\">' +\r\n                           '<div style=\"background-color: gray\">{{title}}</div>' +\r\n                           '<div ng-transclude></div>' +\r\n                         '</div>'\r\n             };\r\n         });\r\n       </script>\r\n       <div ng-controller=\"Ctrl\">\r\n         <input ng-model=\"title\"><br>\r\n         <textarea ng-model=\"text\"></textarea> <br/>\r\n         <pane title=\"{{title}}\">{{text}}</pane>\r\n       </div>\r\n     </doc:source>\r\n     <doc:scenario>\r\n        it('should have transcluded', function() {\r\n          input('title').enter('TITLE');\r\n          input('text').enter('TEXT');\r\n          expect(binding('title')).toEqual('TITLE');\r\n          expect(binding('text')).toEqual('TEXT');\r\n        });\r\n     </doc:scenario>\r\n   </doc:example>\r\n *\r\n */\r\nvar ngTranscludeDirective = ngDirective({\r\n  controller: ['$transclude', '$element', function($transclude, $element) {\r\n    $transclude(function(clone) {\r\n      $element.append(clone);\r\n    });\r\n  }]\r\n});\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:ngView\r\n * @restrict ECA\r\n *\r\n * @description\r\n * # Overview\r\n * `ngView` is a directive that complements the {@link ng.$route $route} service by\r\n * including the rendered template of the current route into the main layout (`index.html`) file.\r\n * Every time the current route changes, the included view changes with it according to the\r\n * configuration of the `$route` service.\r\n *\r\n * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**\r\n * and **leave** effects.\r\n *\r\n * @animations\r\n * enter - happens just after the ngView contents are changed (when the new view DOM element is inserted into the DOM)\r\n * leave - happens just after the current ngView contents change and just before the former contents are removed from the DOM\r\n *\r\n * @scope\r\n * @example\r\n    <example module=\"ngView\" animations=\"true\">\r\n      <file name=\"index.html\">\r\n        <div ng-controller=\"MainCntl as main\">\r\n          Choose:\r\n          <a href=\"Book/Moby\">Moby</a> |\r\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\r\n          <a href=\"Book/Gatsby\">Gatsby</a> |\r\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\r\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\r\n\r\n          <div\r\n            ng-view\r\n            class=\"example-animate-container\"\r\n            ng-animate=\"{enter: 'example-enter', leave: 'example-leave'}\"></div>\r\n          <hr />\r\n\r\n          <pre>$location.path() = {{main.$location.path()}}</pre>\r\n          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>\r\n          <pre>$route.current.params = {{main.$route.current.params}}</pre>\r\n          <pre>$route.current.scope.name = {{main.$route.current.scope.name}}</pre>\r\n          <pre>$routeParams = {{main.$routeParams}}</pre>\r\n        </div>\r\n      </file>\r\n\r\n      <file name=\"book.html\">\r\n        <div>\r\n          controller: {{book.name}}<br />\r\n          Book Id: {{book.params.bookId}}<br />\r\n        </div>\r\n      </file>\r\n\r\n      <file name=\"chapter.html\">\r\n        <div>\r\n          controller: {{chapter.name}}<br />\r\n          Book Id: {{chapter.params.bookId}}<br />\r\n          Chapter Id: {{chapter.params.chapterId}}\r\n        </div>\r\n      </file>\r\n\r\n      <file name=\"animations.css\">\r\n        .example-leave, .example-enter {\r\n          -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\r\n          -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\r\n          -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\r\n          -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\r\n          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\r\n        }\r\n\r\n        .example-animate-container {\r\n          position:relative;\r\n          height:100px;\r\n        }\r\n\r\n        .example-animate-container > * {\r\n          display:block;\r\n          width:100%;\r\n          border-left:1px solid black;\r\n\r\n          position:absolute;\r\n          top:0;\r\n          left:0;\r\n          right:0;\r\n          bottom:0;\r\n          padding:10px;\r\n        }\r\n\r\n        .example-enter {\r\n          left:100%;\r\n        }\r\n        .example-enter.example-enter-active {\r\n          left:0;\r\n        }\r\n\r\n        .example-leave { }\r\n        .example-leave.example-leave-active {\r\n          left:-100%;\r\n        }\r\n      </file>\r\n\r\n      <file name=\"script.js\">\r\n        angular.module('ngView', [], function($routeProvider, $locationProvider) {\r\n          $routeProvider.when('/Book/:bookId', {\r\n            templateUrl: 'book.html',\r\n            controller: BookCntl,\r\n            controllerAs: 'book'\r\n          });\r\n          $routeProvider.when('/Book/:bookId/ch/:chapterId', {\r\n            templateUrl: 'chapter.html',\r\n            controller: ChapterCntl,\r\n            controllerAs: 'chapter'\r\n          });\r\n\r\n          // configure html5 to get links working on jsfiddle\r\n          $locationProvider.html5Mode(true);\r\n        });\r\n\r\n        function MainCntl($route, $routeParams, $location) {\r\n          this.$route = $route;\r\n          this.$location = $location;\r\n          this.$routeParams = $routeParams;\r\n        }\r\n\r\n        function BookCntl($routeParams) {\r\n          this.name = \"BookCntl\";\r\n          this.params = $routeParams;\r\n        }\r\n\r\n        function ChapterCntl($routeParams) {\r\n          this.name = \"ChapterCntl\";\r\n          this.params = $routeParams;\r\n        }\r\n      </file>\r\n\r\n      <file name=\"scenario.js\">\r\n        it('should load and compile correct template', function() {\r\n          element('a:contains(\"Moby: Ch1\")').click();\r\n          var content = element('.doc-example-live [ng-view]').text();\r\n          expect(content).toMatch(/controller\\: ChapterCntl/);\r\n          expect(content).toMatch(/Book Id\\: Moby/);\r\n          expect(content).toMatch(/Chapter Id\\: 1/);\r\n\r\n          element('a:contains(\"Scarlet\")').click();\r\n          content = element('.doc-example-live [ng-view]').text();\r\n          expect(content).toMatch(/controller\\: BookCntl/);\r\n          expect(content).toMatch(/Book Id\\: Scarlet/);\r\n        });\r\n      </file>\r\n    </example>\r\n */\r\n\r\n\r\n/**\r\n * @ngdoc event\r\n * @name ng.directive:ngView#$viewContentLoaded\r\n * @eventOf ng.directive:ngView\r\n * @eventType emit on the current ngView scope\r\n * @description\r\n * Emitted every time the ngView content is reloaded.\r\n */\r\nvar ngViewDirective = ['$http', '$templateCache', '$route', '$anchorScroll', '$compile',\r\n                       '$controller', '$animator',\r\n               function($http,   $templateCache,   $route,   $anchorScroll,   $compile,\r\n                        $controller,  $animator) {\r\n  return {\r\n    restrict: 'ECA',\r\n    terminal: true,\r\n    link: function(scope, element, attr) {\r\n      var lastScope,\r\n          onloadExp = attr.onload || '',\r\n          animate = $animator(scope, attr);\r\n\r\n      scope.$on('$routeChangeSuccess', update);\r\n      update();\r\n\r\n\r\n      function destroyLastScope() {\r\n        if (lastScope) {\r\n          lastScope.$destroy();\r\n          lastScope = null;\r\n        }\r\n      }\r\n\r\n      function clearContent() {\r\n        animate.leave(element.contents(), element);\r\n        destroyLastScope();\r\n      }\r\n\r\n      function update() {\r\n        var locals = $route.current && $route.current.locals,\r\n            template = locals && locals.$template;\r\n\r\n        if (template) {\r\n          clearContent();\r\n          var enterElements = jqLite('<div></div>').html(template).contents();\r\n          animate.enter(enterElements, element);\r\n\r\n          var link = $compile(enterElements),\r\n              current = $route.current,\r\n              controller;\r\n\r\n          lastScope = current.scope = scope.$new();\r\n          if (current.controller) {\r\n            locals.$scope = lastScope;\r\n            controller = $controller(current.controller, locals);\r\n            if (current.controllerAs) {\r\n              lastScope[current.controllerAs] = controller;\r\n            }\r\n            element.children().data('$ngControllerController', controller);\r\n          }\r\n\r\n          link(lastScope);\r\n          lastScope.$emit('$viewContentLoaded');\r\n          lastScope.$eval(onloadExp);\r\n\r\n          // $anchorScroll might listen on event...\r\n          $anchorScroll();\r\n        } else {\r\n          clearContent();\r\n        }\r\n      }\r\n    }\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:script\r\n *\r\n * @description\r\n * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the\r\n * template can be used by `ngInclude`, `ngView` or directive templates.\r\n *\r\n * @restrict E\r\n * @param {'text/ng-template'} type must be set to `'text/ng-template'`\r\n *\r\n * @example\r\n  <doc:example>\r\n    <doc:source>\r\n      <script type=\"text/ng-template\" id=\"/tpl.html\">\r\n        Content of the template.\r\n      </script>\r\n\r\n      <a ng-click=\"currentTpl='/tpl.html'\" id=\"tpl-link\">Load inlined template</a>\r\n      <div id=\"tpl-content\" ng-include src=\"currentTpl\"></div>\r\n    </doc:source>\r\n    <doc:scenario>\r\n      it('should load template defined inside script tag', function() {\r\n        element('#tpl-link').click();\r\n        expect(element('#tpl-content').text()).toMatch(/Content of the template/);\r\n      });\r\n    </doc:scenario>\r\n  </doc:example>\r\n */\r\nvar scriptDirective = ['$templateCache', function($templateCache) {\r\n  return {\r\n    restrict: 'E',\r\n    terminal: true,\r\n    compile: function(element, attr) {\r\n      if (attr.type == 'text/ng-template') {\r\n        var templateUrl = attr.id,\r\n            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent\r\n            text = element[0].text;\r\n\r\n        $templateCache.put(templateUrl, text);\r\n      }\r\n    }\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ng.directive:select\r\n * @restrict E\r\n *\r\n * @description\r\n * HTML `SELECT` element with angular data-binding.\r\n *\r\n * # `ngOptions`\r\n *\r\n * Optionally `ngOptions` attribute can be used to dynamically generate a list of `<option>`\r\n * elements for a `<select>` element using an array or an object obtained by evaluating the\r\n * `ngOptions` expression.\r\n *\r\n * When an item in the select menu is select, the value of array element or object property\r\n * represented by the selected option will be bound to the model identified by the `ngModel`\r\n * directive of the parent select element.\r\n *\r\n * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can\r\n * be nested into the `<select>` element. This element will then represent `null` or \"not selected\"\r\n * option. See example below for demonstration.\r\n *\r\n * Note: `ngOptions` provides iterator facility for `<option>` element which should be used instead\r\n * of {@link ng.directive:ngRepeat ngRepeat} when you want the\r\n * `select` model to be bound to a non-string value. This is because an option element can currently\r\n * be bound to string values only.\r\n *\r\n * @param {string} ngModel Assignable angular expression to data-bind to.\r\n * @param {string=} name Property name of the form under which the control is published.\r\n * @param {string=} required The control is considered valid only if value is entered.\r\n * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\r\n *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\r\n *    `required` when you want to data-bind to the `required` attribute.\r\n * @param {comprehension_expression=} ngOptions in one of the following forms:\r\n *\r\n *   * for array data sources:\r\n *     * `label` **`for`** `value` **`in`** `array`\r\n *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`\r\n *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`\r\n *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`\r\n *   * for object data sources:\r\n *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`\r\n *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`\r\n *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`\r\n *     * `select` **`as`** `label` **`group by`** `group`\r\n *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`\r\n *\r\n * Where:\r\n *\r\n *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.\r\n *   * `value`: local variable which will refer to each item in the `array` or each property value\r\n *      of `object` during iteration.\r\n *   * `key`: local variable which will refer to a property name in `object` during iteration.\r\n *   * `label`: The result of this expression will be the label for `<option>` element. The\r\n *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).\r\n *   * `select`: The result of this expression will be bound to the model of the parent `<select>`\r\n *      element. If not specified, `select` expression will default to `value`.\r\n *   * `group`: The result of this expression will be used to group options using the `<optgroup>`\r\n *      DOM element.\r\n *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be\r\n *      used to identify the objects in the array. The `trackexpr` will most likely refer to the\r\n *     `value` variable (e.g. `value.propertyName`).\r\n *\r\n * @example\r\n    <doc:example>\r\n      <doc:source>\r\n        <script>\r\n        function MyCntrl($scope) {\r\n          $scope.colors = [\r\n            {name:'black', shade:'dark'},\r\n            {name:'white', shade:'light'},\r\n            {name:'red', shade:'dark'},\r\n            {name:'blue', shade:'dark'},\r\n            {name:'yellow', shade:'light'}\r\n          ];\r\n          $scope.color = $scope.colors[2]; // red\r\n        }\r\n        </script>\r\n        <div ng-controller=\"MyCntrl\">\r\n          <ul>\r\n            <li ng-repeat=\"color in colors\">\r\n              Name: <input ng-model=\"color.name\">\r\n              [<a href ng-click=\"colors.splice($index, 1)\">X</a>]\r\n            </li>\r\n            <li>\r\n              [<a href ng-click=\"colors.push({})\">add</a>]\r\n            </li>\r\n          </ul>\r\n          <hr/>\r\n          Color (null not allowed):\r\n          <select ng-model=\"color\" ng-options=\"c.name for c in colors\"></select><br>\r\n\r\n          Color (null allowed):\r\n          <span  class=\"nullable\">\r\n            <select ng-model=\"color\" ng-options=\"c.name for c in colors\">\r\n              <option value=\"\">-- chose color --</option>\r\n            </select>\r\n          </span><br/>\r\n\r\n          Color grouped by shade:\r\n          <select ng-model=\"color\" ng-options=\"c.name group by c.shade for c in colors\">\r\n          </select><br/>\r\n\r\n\r\n          Select <a href ng-click=\"color={name:'not in list'}\">bogus</a>.<br>\r\n          <hr/>\r\n          Currently selected: {{ {selected_color:color}  }}\r\n          <div style=\"border:solid 1px black; height:20px\"\r\n               ng-style=\"{'background-color':color.name}\">\r\n          </div>\r\n        </div>\r\n      </doc:source>\r\n      <doc:scenario>\r\n         it('should check ng-options', function() {\r\n           expect(binding('{selected_color:color}')).toMatch('red');\r\n           select('color').option('0');\r\n           expect(binding('{selected_color:color}')).toMatch('black');\r\n           using('.nullable').select('color').option('');\r\n           expect(binding('{selected_color:color}')).toMatch('null');\r\n         });\r\n      </doc:scenario>\r\n    </doc:example>\r\n */\r\n\r\nvar ngOptionsDirective = valueFn({ terminal: true });\r\nvar selectDirective = ['$compile', '$parse', function($compile,   $parse) {\r\n                         //0000111110000000000022220000000000000000000000333300000000000000444444444444444440000000005555555555555555500000006666666666666666600000000000000007777000000000000000000088888\r\n  var NG_OPTIONS_REGEXP = /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*)|(?:\\(\\s*([\\$\\w][\\$\\w\\d]*)\\s*,\\s*([\\$\\w][\\$\\w\\d]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/,\r\n      nullModelCtrl = {$setViewValue: noop};\r\n\r\n  return {\r\n    restrict: 'E',\r\n    require: ['select', '?ngModel'],\r\n    controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {\r\n      var self = this,\r\n          optionsMap = {},\r\n          ngModelCtrl = nullModelCtrl,\r\n          nullOption,\r\n          unknownOption;\r\n\r\n\r\n      self.databound = $attrs.ngModel;\r\n\r\n\r\n      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {\r\n        ngModelCtrl = ngModelCtrl_;\r\n        nullOption = nullOption_;\r\n        unknownOption = unknownOption_;\r\n      }\r\n\r\n\r\n      self.addOption = function(value) {\r\n        optionsMap[value] = true;\r\n\r\n        if (ngModelCtrl.$viewValue == value) {\r\n          $element.val(value);\r\n          if (unknownOption.parent()) unknownOption.remove();\r\n        }\r\n      };\r\n\r\n\r\n      self.removeOption = function(value) {\r\n        if (this.hasOption(value)) {\r\n          delete optionsMap[value];\r\n          if (ngModelCtrl.$viewValue == value) {\r\n            this.renderUnknownOption(value);\r\n          }\r\n        }\r\n      };\r\n\r\n\r\n      self.renderUnknownOption = function(val) {\r\n        var unknownVal = '? ' + hashKey(val) + ' ?';\r\n        unknownOption.val(unknownVal);\r\n        $element.prepend(unknownOption);\r\n        $element.val(unknownVal);\r\n        unknownOption.prop('selected', true); // needed for IE\r\n      }\r\n\r\n\r\n      self.hasOption = function(value) {\r\n        return optionsMap.hasOwnProperty(value);\r\n      }\r\n\r\n      $scope.$on('$destroy', function() {\r\n        // disable unknown option so that we don't do work when the whole select is being destroyed\r\n        self.renderUnknownOption = noop;\r\n      });\r\n    }],\r\n\r\n    link: function(scope, element, attr, ctrls) {\r\n      // if ngModel is not defined, we don't need to do anything\r\n      if (!ctrls[1]) return;\r\n\r\n      var selectCtrl = ctrls[0],\r\n          ngModelCtrl = ctrls[1],\r\n          multiple = attr.multiple,\r\n          optionsExp = attr.ngOptions,\r\n          nullOption = false, // if false, user will not be able to select it (used by ngOptions)\r\n          emptyOption,\r\n          // we can't just jqLite('<option>') since jqLite is not smart enough\r\n          // to create it in <select> and IE barfs otherwise.\r\n          optionTemplate = jqLite(document.createElement('option')),\r\n          optGroupTemplate =jqLite(document.createElement('optgroup')),\r\n          unknownOption = optionTemplate.clone();\r\n\r\n      // find \"null\" option\r\n      for(var i = 0, children = element.children(), ii = children.length; i < ii; i++) {\r\n        if (children[i].value == '') {\r\n          emptyOption = nullOption = children.eq(i);\r\n          break;\r\n        }\r\n      }\r\n\r\n      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);\r\n\r\n      // required validator\r\n      if (multiple && (attr.required || attr.ngRequired)) {\r\n        var requiredValidator = function(value) {\r\n          ngModelCtrl.$setValidity('required', !attr.required || (value && value.length));\r\n          return value;\r\n        };\r\n\r\n        ngModelCtrl.$parsers.push(requiredValidator);\r\n        ngModelCtrl.$formatters.unshift(requiredValidator);\r\n\r\n        attr.$observe('required', function() {\r\n          requiredValidator(ngModelCtrl.$viewValue);\r\n        });\r\n      }\r\n\r\n      if (optionsExp) Options(scope, element, ngModelCtrl);\r\n      else if (multiple) Multiple(scope, element, ngModelCtrl);\r\n      else Single(scope, element, ngModelCtrl, selectCtrl);\r\n\r\n\r\n      ////////////////////////////\r\n\r\n\r\n\r\n      function Single(scope, selectElement, ngModelCtrl, selectCtrl) {\r\n        ngModelCtrl.$render = function() {\r\n          var viewValue = ngModelCtrl.$viewValue;\r\n\r\n          if (selectCtrl.hasOption(viewValue)) {\r\n            if (unknownOption.parent()) unknownOption.remove();\r\n            selectElement.val(viewValue);\r\n            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy\r\n          } else {\r\n            if (isUndefined(viewValue) && emptyOption) {\r\n              selectElement.val('');\r\n            } else {\r\n              selectCtrl.renderUnknownOption(viewValue);\r\n            }\r\n          }\r\n        };\r\n\r\n        selectElement.bind('change', function() {\r\n          scope.$apply(function() {\r\n            if (unknownOption.parent()) unknownOption.remove();\r\n            ngModelCtrl.$setViewValue(selectElement.val());\r\n          });\r\n        });\r\n      }\r\n\r\n      function Multiple(scope, selectElement, ctrl) {\r\n        var lastView;\r\n        ctrl.$render = function() {\r\n          var items = new HashMap(ctrl.$viewValue);\r\n          forEach(selectElement.find('option'), function(option) {\r\n            option.selected = isDefined(items.get(option.value));\r\n          });\r\n        };\r\n\r\n        // we have to do it on each watch since ngModel watches reference, but\r\n        // we need to work of an array, so we need to see if anything was inserted/removed\r\n        scope.$watch(function selectMultipleWatch() {\r\n          if (!equals(lastView, ctrl.$viewValue)) {\r\n            lastView = copy(ctrl.$viewValue);\r\n            ctrl.$render();\r\n          }\r\n        });\r\n\r\n        selectElement.bind('change', function() {\r\n          scope.$apply(function() {\r\n            var array = [];\r\n            forEach(selectElement.find('option'), function(option) {\r\n              if (option.selected) {\r\n                array.push(option.value);\r\n              }\r\n            });\r\n            ctrl.$setViewValue(array);\r\n          });\r\n        });\r\n      }\r\n\r\n      function Options(scope, selectElement, ctrl) {\r\n        var match;\r\n\r\n        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {\r\n          throw Error(\r\n            \"Expected ngOptions in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_ (track by _expr_)?'\" +\r\n            \" but got '\" + optionsExp + \"'.\");\r\n        }\r\n\r\n        var displayFn = $parse(match[2] || match[1]),\r\n            valueName = match[4] || match[6],\r\n            keyName = match[5],\r\n            groupByFn = $parse(match[3] || ''),\r\n            valueFn = $parse(match[2] ? match[1] : valueName),\r\n            valuesFn = $parse(match[7]),\r\n            track = match[8],\r\n            trackFn = track ? $parse(match[8]) : null,\r\n            // This is an array of array of existing option groups in DOM. We try to reuse these if possible\r\n            // optionGroupsCache[0] is the options with no option group\r\n            // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element\r\n            optionGroupsCache = [[{element: selectElement, label:''}]];\r\n\r\n        if (nullOption) {\r\n          // compile the element since there might be bindings in it\r\n          $compile(nullOption)(scope);\r\n\r\n          // remove the class, which is added automatically because we recompile the element and it\r\n          // becomes the compilation root\r\n          nullOption.removeClass('ng-scope');\r\n\r\n          // we need to remove it before calling selectElement.html('') because otherwise IE will\r\n          // remove the label from the element. wtf?\r\n          nullOption.remove();\r\n        }\r\n\r\n        // clear contents, we'll add what's needed based on the model\r\n        selectElement.html('');\r\n\r\n        selectElement.bind('change', function() {\r\n          scope.$apply(function() {\r\n            var optionGroup,\r\n                collection = valuesFn(scope) || [],\r\n                locals = {},\r\n                key, value, optionElement, index, groupIndex, length, groupLength;\r\n\r\n            if (multiple) {\r\n              value = [];\r\n              for (groupIndex = 0, groupLength = optionGroupsCache.length;\r\n                   groupIndex < groupLength;\r\n                   groupIndex++) {\r\n                // list of options for that group. (first item has the parent)\r\n                optionGroup = optionGroupsCache[groupIndex];\r\n\r\n                for(index = 1, length = optionGroup.length; index < length; index++) {\r\n                  if ((optionElement = optionGroup[index].element)[0].selected) {\r\n                    key = optionElement.val();\r\n                    if (keyName) locals[keyName] = key;\r\n                    if (trackFn) {\r\n                      for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {\r\n                        locals[valueName] = collection[trackIndex];\r\n                        if (trackFn(scope, locals) == key) break;\r\n                      } \r\n                    } else {\r\n                      locals[valueName] = collection[key];\r\n                    }\r\n                    value.push(valueFn(scope, locals));\r\n                  }\r\n                }\r\n              }\r\n            } else {\r\n              key = selectElement.val();\r\n              if (key == '?') {\r\n                value = undefined;\r\n              } else if (key == ''){\r\n                value = null;\r\n              } else {\r\n                if (trackFn) {\r\n                  for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {\r\n                    locals[valueName] = collection[trackIndex];\r\n                    if (trackFn(scope, locals) == key) {\r\n                      value = valueFn(scope, locals);\r\n                      break;\r\n                    }\r\n                  }\r\n                } else {\r\n                  locals[valueName] = collection[key];\r\n                  if (keyName) locals[keyName] = key;\r\n                  value = valueFn(scope, locals);\r\n                }\r\n              }\r\n            }\r\n            ctrl.$setViewValue(value);\r\n          });\r\n        });\r\n\r\n        ctrl.$render = render;\r\n\r\n        // TODO(vojta): can't we optimize this ?\r\n        scope.$watch(render);\r\n\r\n        function render() {\r\n          var optionGroups = {'':[]}, // Temporary location for the option groups before we render them\r\n              optionGroupNames = [''],\r\n              optionGroupName,\r\n              optionGroup,\r\n              option,\r\n              existingParent, existingOptions, existingOption,\r\n              modelValue = ctrl.$modelValue,\r\n              values = valuesFn(scope) || [],\r\n              keys = keyName ? sortedKeys(values) : values,\r\n              groupLength, length,\r\n              groupIndex, index,\r\n              locals = {},\r\n              selected,\r\n              selectedSet = false, // nothing is selected yet\r\n              lastElement,\r\n              element,\r\n              label;\r\n\r\n          if (multiple) {\r\n            if (trackFn && isArray(modelValue)) {\r\n              selectedSet = new HashMap([]);\r\n              for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {\r\n                locals[valueName] = modelValue[trackIndex];\r\n                selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);\r\n              }\r\n            } else {\r\n              selectedSet = new HashMap(modelValue);\r\n            }\r\n          }\r\n\r\n          // We now build up the list of options we need (we merge later)\r\n          for (index = 0; length = keys.length, index < length; index++) {\r\n               locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];\r\n               optionGroupName = groupByFn(scope, locals) || '';\r\n            if (!(optionGroup = optionGroups[optionGroupName])) {\r\n              optionGroup = optionGroups[optionGroupName] = [];\r\n              optionGroupNames.push(optionGroupName);\r\n            }\r\n            if (multiple) {\r\n              selected = selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)) != undefined;\r\n            } else {\r\n              if (trackFn) {\r\n                var modelCast = {};\r\n                modelCast[valueName] = modelValue;\r\n                selected = trackFn(scope, modelCast) === trackFn(scope, locals);\r\n              } else {\r\n                selected = modelValue === valueFn(scope, locals);\r\n              }\r\n              selectedSet = selectedSet || selected; // see if at least one item is selected\r\n            }\r\n            label = displayFn(scope, locals); // what will be seen by the user\r\n            label = label === undefined ? '' : label; // doing displayFn(scope, locals) || '' overwrites zero values\r\n            optionGroup.push({\r\n              id: trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index),   // either the index into array or key from object\r\n              label: label,\r\n              selected: selected                   // determine if we should be selected\r\n            });\r\n          }\r\n          if (!multiple) {\r\n            if (nullOption || modelValue === null) {\r\n              // insert null option if we have a placeholder, or the model is null\r\n              optionGroups[''].unshift({id:'', label:'', selected:!selectedSet});\r\n            } else if (!selectedSet) {\r\n              // option could not be found, we have to insert the undefined item\r\n              optionGroups[''].unshift({id:'?', label:'', selected:true});\r\n            }\r\n          }\r\n\r\n          // Now we need to update the list of DOM nodes to match the optionGroups we computed above\r\n          for (groupIndex = 0, groupLength = optionGroupNames.length;\r\n               groupIndex < groupLength;\r\n               groupIndex++) {\r\n            // current option group name or '' if no group\r\n            optionGroupName = optionGroupNames[groupIndex];\r\n\r\n            // list of options for that group. (first item has the parent)\r\n            optionGroup = optionGroups[optionGroupName];\r\n\r\n            if (optionGroupsCache.length <= groupIndex) {\r\n              // we need to grow the optionGroups\r\n              existingParent = {\r\n                element: optGroupTemplate.clone().attr('label', optionGroupName),\r\n                label: optionGroup.label\r\n              };\r\n              existingOptions = [existingParent];\r\n              optionGroupsCache.push(existingOptions);\r\n              selectElement.append(existingParent.element);\r\n            } else {\r\n              existingOptions = optionGroupsCache[groupIndex];\r\n              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element\r\n\r\n              // update the OPTGROUP label if not the same.\r\n              if (existingParent.label != optionGroupName) {\r\n                existingParent.element.attr('label', existingParent.label = optionGroupName);\r\n              }\r\n            }\r\n\r\n            lastElement = null;  // start at the beginning\r\n            for(index = 0, length = optionGroup.length; index < length; index++) {\r\n              option = optionGroup[index];\r\n              if ((existingOption = existingOptions[index+1])) {\r\n                // reuse elements\r\n                lastElement = existingOption.element;\r\n                if (existingOption.label !== option.label) {\r\n                  lastElement.text(existingOption.label = option.label);\r\n                }\r\n                if (existingOption.id !== option.id) {\r\n                  lastElement.val(existingOption.id = option.id);\r\n                }\r\n                // lastElement.prop('selected') provided by jQuery has side-effects\r\n                if (lastElement[0].selected !== option.selected) {\r\n                  lastElement.prop('selected', (existingOption.selected = option.selected));\r\n                }\r\n              } else {\r\n                // grow elements\r\n\r\n                // if it's a null option\r\n                if (option.id === '' && nullOption) {\r\n                  // put back the pre-compiled element\r\n                  element = nullOption;\r\n                } else {\r\n                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but\r\n                  // in this version of jQuery on some browser the .text() returns a string\r\n                  // rather then the element.\r\n                  (element = optionTemplate.clone())\r\n                      .val(option.id)\r\n                      .attr('selected', option.selected)\r\n                      .text(option.label);\r\n                }\r\n\r\n                existingOptions.push(existingOption = {\r\n                    element: element,\r\n                    label: option.label,\r\n                    id: option.id,\r\n                    selected: option.selected\r\n                });\r\n                if (lastElement) {\r\n                  lastElement.after(element);\r\n                } else {\r\n                  existingParent.element.append(element);\r\n                }\r\n                lastElement = element;\r\n              }\r\n            }\r\n            // remove any excessive OPTIONs in a group\r\n            index++; // increment since the existingOptions[0] is parent element not OPTION\r\n            while(existingOptions.length > index) {\r\n              existingOptions.pop().element.remove();\r\n            }\r\n          }\r\n          // remove any excessive OPTGROUPs from select\r\n          while(optionGroupsCache.length > groupIndex) {\r\n            optionGroupsCache.pop()[0].element.remove();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}];\r\n\r\nvar optionDirective = ['$interpolate', function($interpolate) {\r\n  var nullSelectCtrl = {\r\n    addOption: noop,\r\n    removeOption: noop\r\n  };\r\n\r\n  return {\r\n    restrict: 'E',\r\n    priority: 100,\r\n    compile: function(element, attr) {\r\n      if (isUndefined(attr.value)) {\r\n        var interpolateFn = $interpolate(element.text(), true);\r\n        if (!interpolateFn) {\r\n          attr.$set('value', element.text());\r\n        }\r\n      }\r\n\r\n      return function (scope, element, attr) {\r\n        var selectCtrlName = '$selectController',\r\n            parent = element.parent(),\r\n            selectCtrl = parent.data(selectCtrlName) ||\r\n              parent.parent().data(selectCtrlName); // in case we are in optgroup\r\n\r\n        if (selectCtrl && selectCtrl.databound) {\r\n          // For some reason Opera defaults to true and if not overridden this messes up the repeater.\r\n          // We don't want the view to drive the initialization of the model anyway.\r\n          element.prop('selected', false);\r\n        } else {\r\n          selectCtrl = nullSelectCtrl;\r\n        }\r\n\r\n        if (interpolateFn) {\r\n          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {\r\n            attr.$set('value', newVal);\r\n            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);\r\n            selectCtrl.addOption(newVal);\r\n          });\r\n        } else {\r\n          selectCtrl.addOption(attr.value);\r\n        }\r\n\r\n        element.bind('$destroy', function() {\r\n          selectCtrl.removeOption(attr.value);\r\n        });\r\n      };\r\n    }\r\n  }\r\n}];\r\n\r\nvar styleDirective = valueFn({\r\n  restrict: 'E',\r\n  terminal: true\r\n});\r\n\r\n  //try to bind to jquery now so that one can write angular.element().read()\r\n  //but we will rebind on bootstrap again.\r\n  bindJQuery();\r\n\r\n  publishExternalAPI(angular);\r\n\r\n  jqLite(document).ready(function() {\r\n    angularInit(document, bootstrap);\r\n  });\r\n\r\n})(window, document);\r\nangular.element(document).find('head').append('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\\\:form{display:block;}</style>');",
    "/*! Socket.IO.min.js build:0.9.16, production. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\r\nvar io=\"undefined\"==typeof module?{}:module.exports;(function(){(function(a,b){var c=a;c.version=\"0.9.16\",c.protocol=1,c.transports=[],c.j=[],c.sockets={},c.connect=function(a,d){var e=c.util.parseUri(a),f,g;b&&b.location&&(e.protocol=e.protocol||b.location.protocol.slice(0,-1),e.host=e.host||(b.document?b.document.domain:b.location.hostname),e.port=e.port||b.location.port),f=c.util.uniqueUri(e);var h={host:e.host,secure:\"https\"==e.protocol,port:e.port||(\"https\"==e.protocol?443:80),query:e.query||\"\"};c.util.merge(h,d);if(h[\"force new connection\"]||!c.sockets[f])g=new c.Socket(h);return!h[\"force new connection\"]&&g&&(c.sockets[f]=g),g=g||c.sockets[f],g.of(e.path.length>1?e.path:\"\")}})(\"object\"==typeof module?module.exports:this.io={},this),function(a,b){var c=a.util={},d=/^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/,e=[\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"];c.parseUri=function(a){var b=d.exec(a||\"\"),c={},f=14;while(f--)c[e[f]]=b[f]||\"\";return c},c.uniqueUri=function(a){var c=a.protocol,d=a.host,e=a.port;return\"document\"in b?(d=d||document.domain,e=e||(c==\"https\"&&document.location.protocol!==\"https:\"?443:document.location.port)):(d=d||\"localhost\",!e&&c==\"https\"&&(e=443)),(c||\"http\")+\"://\"+d+\":\"+(e||80)},c.query=function(a,b){var d=c.chunkQuery(a||\"\"),e=[];c.merge(d,c.chunkQuery(b||\"\"));for(var f in d)d.hasOwnProperty(f)&&e.push(f+\"=\"+d[f]);return e.length?\"?\"+e.join(\"&\"):\"\"},c.chunkQuery=function(a){var b={},c=a.split(\"&\"),d=0,e=c.length,f;for(;d<e;++d)f=c[d].split(\"=\"),f[0]&&(b[f[0]]=f[1]);return b};var f=!1;c.load=function(a){if(\"document\"in b&&document.readyState===\"complete\"||f)return a();c.on(b,\"load\",a,!1)},c.on=function(a,b,c,d){a.attachEvent?a.attachEvent(\"on\"+b,c):a.addEventListener&&a.addEventListener(b,c,d)},c.request=function(a){if(a&&\"undefined\"!=typeof XDomainRequest&&!c.ua.hasCORS)return new XDomainRequest;if(\"undefined\"!=typeof XMLHttpRequest&&(!a||c.ua.hasCORS))return new XMLHttpRequest;if(!a)try{return new(window[[\"Active\"].concat(\"Object\").join(\"X\")])(\"Microsoft.XMLHTTP\")}catch(b){}return null},\"undefined\"!=typeof window&&c.load(function(){f=!0}),c.defer=function(a){if(!c.ua.webkit||\"undefined\"!=typeof importScripts)return a();c.load(function(){setTimeout(a,100)})},c.merge=function(b,d,e,f){var g=f||[],h=typeof e==\"undefined\"?2:e,i;for(i in d)d.hasOwnProperty(i)&&c.indexOf(g,i)<0&&(typeof b[i]!=\"object\"||!h?(b[i]=d[i],g.push(d[i])):c.merge(b[i],d[i],h-1,g));return b},c.mixin=function(a,b){c.merge(a.prototype,b.prototype)},c.inherit=function(a,b){function c(){}c.prototype=b.prototype,a.prototype=new c},c.isArray=Array.isArray||function(a){return Object.prototype.toString.call(a)===\"[object Array]\"},c.intersect=function(a,b){var d=[],e=a.length>b.length?a:b,f=a.length>b.length?b:a;for(var g=0,h=f.length;g<h;g++)~c.indexOf(e,f[g])&&d.push(f[g]);return d},c.indexOf=function(a,b,c){for(var d=a.length,c=c<0?c+d<0?0:c+d:c||0;c<d&&a[c]!==b;c++);return d<=c?-1:c},c.toArray=function(a){var b=[];for(var c=0,d=a.length;c<d;c++)b.push(a[c]);return b},c.ua={},c.ua.hasCORS=\"undefined\"!=typeof XMLHttpRequest&&function(){try{var a=new XMLHttpRequest}catch(b){return!1}return a.withCredentials!=undefined}(),c.ua.webkit=\"undefined\"!=typeof navigator&&/webkit/i.test(navigator.userAgent),c.ua.iDevice=\"undefined\"!=typeof navigator&&/iPad|iPhone|iPod/i.test(navigator.userAgent)}(\"undefined\"!=typeof io?io:module.exports,this),function(a,b){function c(){}a.EventEmitter=c,c.prototype.on=function(a,c){return this.$events||(this.$events={}),this.$events[a]?b.util.isArray(this.$events[a])?this.$events[a].push(c):this.$events[a]=[this.$events[a],c]:this.$events[a]=c,this},c.prototype.addListener=c.prototype.on,c.prototype.once=function(a,b){function d(){c.removeListener(a,d),b.apply(this,arguments)}var c=this;return d.listener=b,this.on(a,d),this},c.prototype.removeListener=function(a,c){if(this.$events&&this.$events[a]){var d=this.$events[a];if(b.util.isArray(d)){var e=-1;for(var f=0,g=d.length;f<g;f++)if(d[f]===c||d[f].listener&&d[f].listener===c){e=f;break}if(e<0)return this;d.splice(e,1),d.length||delete this.$events[a]}else(d===c||d.listener&&d.listener===c)&&delete this.$events[a]}return this},c.prototype.removeAllListeners=function(a){return a===undefined?(this.$events={},this):(this.$events&&this.$events[a]&&(this.$events[a]=null),this)},c.prototype.listeners=function(a){return this.$events||(this.$events={}),this.$events[a]||(this.$events[a]=[]),b.util.isArray(this.$events[a])||(this.$events[a]=[this.$events[a]]),this.$events[a]},c.prototype.emit=function(a){if(!this.$events)return!1;var c=this.$events[a];if(!c)return!1;var d=Array.prototype.slice.call(arguments,1);if(\"function\"==typeof c)c.apply(this,d);else{if(!b.util.isArray(c))return!1;var e=c.slice();for(var f=0,g=e.length;f<g;f++)e[f].apply(this,d)}return!0}}(\"undefined\"!=typeof io?io:module.exports,\"undefined\"!=typeof io?io:module.parent.exports),function(exports,nativeJSON){function f(a){return a<10?\"0\"+a:a}function date(a,b){return isFinite(a.valueOf())?a.getUTCFullYear()+\"-\"+f(a.getUTCMonth()+1)+\"-\"+f(a.getUTCDate())+\"T\"+f(a.getUTCHours())+\":\"+f(a.getUTCMinutes())+\":\"+f(a.getUTCSeconds())+\"Z\":null}function quote(a){return escapable.lastIndex=0,escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i instanceof Date&&(i=date(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";return e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g,e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));return e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g,e}}\"use strict\";if(nativeJSON&&nativeJSON.parse)return exports.JSON={parse:nativeJSON.parse,stringify:nativeJSON.stringify};var JSON=exports.JSON={},cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")},JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\")))return j=eval(\"(\"+text+\")\"),typeof reviver==\"function\"?walk({\"\":j},\"\"):j;throw new SyntaxError(\"JSON.parse\")}}(\"undefined\"!=typeof io?io:module.exports,typeof JSON!=\"undefined\"?JSON:undefined),function(a,b){var c=a.parser={},d=c.packets=[\"disconnect\",\"connect\",\"heartbeat\",\"message\",\"json\",\"event\",\"ack\",\"error\",\"noop\"],e=c.reasons=[\"transport not supported\",\"client not handshaken\",\"unauthorized\"],f=c.advice=[\"reconnect\"],g=b.JSON,h=b.util.indexOf;c.encodePacket=function(a){var b=h(d,a.type),c=a.id||\"\",i=a.endpoint||\"\",j=a.ack,k=null;switch(a.type){case\"error\":var l=a.reason?h(e,a.reason):\"\",m=a.advice?h(f,a.advice):\"\";if(l!==\"\"||m!==\"\")k=l+(m!==\"\"?\"+\"+m:\"\");break;case\"message\":a.data!==\"\"&&(k=a.data);break;case\"event\":var n={name:a.name};a.args&&a.args.length&&(n.args=a.args),k=g.stringify(n);break;case\"json\":k=g.stringify(a.data);break;case\"connect\":a.qs&&(k=a.qs);break;case\"ack\":k=a.ackId+(a.args&&a.args.length?\"+\"+g.stringify(a.args):\"\")}var o=[b,c+(j==\"data\"?\"+\":\"\"),i];return k!==null&&k!==undefined&&o.push(k),o.join(\":\")},c.encodePayload=function(a){var b=\"\";if(a.length==1)return a[0];for(var c=0,d=a.length;c<d;c++){var e=a[c];b+=\"\\ufffd\"+e.length+\"\\ufffd\"+a[c]}return b};var i=/([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;c.decodePacket=function(a){var b=a.match(i);if(!b)return{};var c=b[2]||\"\",a=b[5]||\"\",h={type:d[b[1]],endpoint:b[4]||\"\"};c&&(h.id=c,b[3]?h.ack=\"data\":h.ack=!0);switch(h.type){case\"error\":var b=a.split(\"+\");h.reason=e[b[0]]||\"\",h.advice=f[b[1]]||\"\";break;case\"message\":h.data=a||\"\";break;case\"event\":try{var j=g.parse(a);h.name=j.name,h.args=j.args}catch(k){}h.args=h.args||[];break;case\"json\":try{h.data=g.parse(a)}catch(k){}break;case\"connect\":h.qs=a||\"\";break;case\"ack\":var b=a.match(/^([0-9]+)(\\+)?(.*)/);if(b){h.ackId=b[1],h.args=[];if(b[3])try{h.args=b[3]?g.parse(b[3]):[]}catch(k){}}break;case\"disconnect\":case\"heartbeat\":}return h},c.decodePayload=function(a){if(a.charAt(0)==\"\\ufffd\"){var b=[];for(var d=1,e=\"\";d<a.length;d++)a.charAt(d)==\"\\ufffd\"?(b.push(c.decodePacket(a.substr(d+1).substr(0,e))),d+=Number(e)+1,e=\"\"):e+=a.charAt(d);return b}return[c.decodePacket(a)]}}(\"undefined\"!=typeof io?io:module.exports,\"undefined\"!=typeof io?io:module.parent.exports),function(a,b){function c(a,b){this.socket=a,this.sessid=b}a.Transport=c,b.util.mixin(c,b.EventEmitter),c.prototype.heartbeats=function(){return!0},c.prototype.onData=function(a){this.clearCloseTimeout(),(this.socket.connected||this.socket.connecting||this.socket.reconnecting)&&this.setCloseTimeout();if(a!==\"\"){var c=b.parser.decodePayload(a);if(c&&c.length)for(var d=0,e=c.length;d<e;d++)this.onPacket(c[d])}return this},c.prototype.onPacket=function(a){return this.socket.setHeartbeatTimeout(),a.type==\"heartbeat\"?this.onHeartbeat():(a.type==\"connect\"&&a.endpoint==\"\"&&this.onConnect(),a.type==\"error\"&&a.advice==\"reconnect\"&&(this.isOpen=!1),this.socket.onPacket(a),this)},c.prototype.setCloseTimeout=function(){if(!this.closeTimeout){var a=this;this.closeTimeout=setTimeout(function(){a.onDisconnect()},this.socket.closeTimeout)}},c.prototype.onDisconnect=function(){return this.isOpen&&this.close(),this.clearTimeouts(),this.socket.onDisconnect(),this},c.prototype.onConnect=function(){return this.socket.onConnect(),this},c.prototype.clearCloseTimeout=function(){this.closeTimeout&&(clearTimeout(this.closeTimeout),this.closeTimeout=null)},c.prototype.clearTimeouts=function(){this.clearCloseTimeout(),this.reopenTimeout&&clearTimeout(this.reopenTimeout)},c.prototype.packet=function(a){this.send(b.parser.encodePacket(a))},c.prototype.onHeartbeat=function(a){this.packet({type:\"heartbeat\"})},c.prototype.onOpen=function(){this.isOpen=!0,this.clearCloseTimeout(),this.socket.onOpen()},c.prototype.onClose=function(){var a=this;this.isOpen=!1,this.socket.onClose(),this.onDisconnect()},c.prototype.prepareUrl=function(){var a=this.socket.options;return this.scheme()+\"://\"+a.host+\":\"+a.port+\"/\"+a.resource+\"/\"+b.protocol+\"/\"+this.name+\"/\"+this.sessid},c.prototype.ready=function(a,b){b.call(this)}}(\"undefined\"!=typeof io?io:module.exports,\"undefined\"!=typeof io?io:module.parent.exports),function(a,b,c){function d(a){this.options={port:80,secure:!1,document:\"document\"in c?document:!1,resource:\"socket.io\",transports:b.transports,\"connect timeout\":1e4,\"try multiple transports\":!0,reconnect:!0,\"reconnection delay\":500,\"reconnection limit\":Infinity,\"reopen delay\":3e3,\"max reconnection attempts\":10,\"sync disconnect on unload\":!1,\"auto connect\":!0,\"flash policy port\":10843,manualFlush:!1},b.util.merge(this.options,a),this.connected=!1,this.open=!1,this.connecting=!1,this.reconnecting=!1,this.namespaces={},this.buffer=[],this.doBuffer=!1;if(this.options[\"sync disconnect on unload\"]&&(!this.isXDomain()||b.util.ua.hasCORS)){var d=this;b.util.on(c,\"beforeunload\",function(){d.disconnectSync()},!1)}this.options[\"auto connect\"]&&this.connect()}function e(){}a.Socket=d,b.util.mixin(d,b.EventEmitter),d.prototype.of=function(a){return this.namespaces[a]||(this.namespaces[a]=new b.SocketNamespace(this,a),a!==\"\"&&this.namespaces[a].packet({type:\"connect\"})),this.namespaces[a]},d.prototype.publish=function(){this.emit.apply(this,arguments);var a;for(var b in this.namespaces)this.namespaces.hasOwnProperty(b)&&(a=this.of(b),a.$emit.apply(a,arguments))},d.prototype.handshake=function(a){function f(b){b instanceof Error?(c.connecting=!1,c.onError(b.message)):a.apply(null,b.split(\":\"))}var c=this,d=this.options,g=[\"http\"+(d.secure?\"s\":\"\")+\":/\",d.host+\":\"+d.port,d.resource,b.protocol,b.util.query(this.options.query,\"t=\"+ +(new Date))].join(\"/\");if(this.isXDomain()&&!b.util.ua.hasCORS){var h=document.getElementsByTagName(\"script\")[0],i=document.createElement(\"script\");i.src=g+\"&jsonp=\"+b.j.length,h.parentNode.insertBefore(i,h),b.j.push(function(a){f(a),i.parentNode.removeChild(i)})}else{var j=b.util.request();j.open(\"GET\",g,!0),this.isXDomain()&&(j.withCredentials=!0),j.onreadystatechange=function(){j.readyState==4&&(j.onreadystatechange=e,j.status==200?f(j.responseText):j.status==403?c.onError(j.responseText):(c.connecting=!1,!c.reconnecting&&c.onError(j.responseText)))},j.send(null)}},d.prototype.getTransport=function(a){var c=a||this.transports,d;for(var e=0,f;f=c[e];e++)if(b.Transport[f]&&b.Transport[f].check(this)&&(!this.isXDomain()||b.Transport[f].xdomainCheck(this)))return new b.Transport[f](this,this.sessionid);return null},d.prototype.connect=function(a){if(this.connecting)return this;var c=this;return c.connecting=!0,this.handshake(function(d,e,f,g){function h(a){c.transport&&c.transport.clearTimeouts(),c.transport=c.getTransport(a);if(!c.transport)return c.publish(\"connect_failed\");c.transport.ready(c,function(){c.connecting=!0,c.publish(\"connecting\",c.transport.name),c.transport.open(),c.options[\"connect timeout\"]&&(c.connectTimeoutTimer=setTimeout(function(){if(!c.connected){c.connecting=!1;if(c.options[\"try multiple transports\"]){var a=c.transports;while(a.length>0&&a.splice(0,1)[0]!=c.transport.name);a.length?h(a):c.publish(\"connect_failed\")}}},c.options[\"connect timeout\"]))})}c.sessionid=d,c.closeTimeout=f*1e3,c.heartbeatTimeout=e*1e3,c.transports||(c.transports=c.origTransports=g?b.util.intersect(g.split(\",\"),c.options.transports):c.options.transports),c.setHeartbeatTimeout(),h(c.transports),c.once(\"connect\",function(){clearTimeout(c.connectTimeoutTimer),a&&typeof a==\"function\"&&a()})}),this},d.prototype.setHeartbeatTimeout=function(){clearTimeout(this.heartbeatTimeoutTimer);if(this.transport&&!this.transport.heartbeats())return;var a=this;this.heartbeatTimeoutTimer=setTimeout(function(){a.transport.onClose()},this.heartbeatTimeout)},d.prototype.packet=function(a){return this.connected&&!this.doBuffer?this.transport.packet(a):this.buffer.push(a),this},d.prototype.setBuffer=function(a){this.doBuffer=a,!a&&this.connected&&this.buffer.length&&(this.options.manualFlush||this.flushBuffer())},d.prototype.flushBuffer=function(){this.transport.payload(this.buffer),this.buffer=[]},d.prototype.disconnect=function(){if(this.connected||this.connecting)this.open&&this.of(\"\").packet({type:\"disconnect\"}),this.onDisconnect(\"booted\");return this},d.prototype.disconnectSync=function(){var a=b.util.request(),c=[\"http\"+(this.options.secure?\"s\":\"\")+\":/\",this.options.host+\":\"+this.options.port,this.options.resource,b.protocol,\"\",this.sessionid].join(\"/\")+\"/?disconnect=1\";a.open(\"GET\",c,!1),a.send(null),this.onDisconnect(\"booted\")},d.prototype.isXDomain=function(){var a=c.location.port||(\"https:\"==c.location.protocol?443:80);return this.options.host!==c.location.hostname||this.options.port!=a},d.prototype.onConnect=function(){this.connected||(this.connected=!0,this.connecting=!1,this.doBuffer||this.setBuffer(!1),this.emit(\"connect\"))},d.prototype.onOpen=function(){this.open=!0},d.prototype.onClose=function(){this.open=!1,clearTimeout(this.heartbeatTimeoutTimer)},d.prototype.onPacket=function(a){this.of(a.endpoint).onPacket(a)},d.prototype.onError=function(a){a&&a.advice&&a.advice===\"reconnect\"&&(this.connected||this.connecting)&&(this.disconnect(),this.options.reconnect&&this.reconnect()),this.publish(\"error\",a&&a.reason?a.reason:a)},d.prototype.onDisconnect=function(a){var b=this.connected,c=this.connecting;this.connected=!1,this.connecting=!1,this.open=!1;if(b||c)this.transport.close(),this.transport.clearTimeouts(),b&&(this.publish(\"disconnect\",a),\"booted\"!=a&&this.options.reconnect&&!this.reconnecting&&this.reconnect())},d.prototype.reconnect=function(){function e(){if(a.connected){for(var b in a.namespaces)a.namespaces.hasOwnProperty(b)&&\"\"!==b&&a.namespaces[b].packet({type:\"connect\"});a.publish(\"reconnect\",a.transport.name,a.reconnectionAttempts)}clearTimeout(a.reconnectionTimer),a.removeListener(\"connect_failed\",f),a.removeListener(\"connect\",f),a.reconnecting=!1,delete a.reconnectionAttempts,delete a.reconnectionDelay,delete a.reconnectionTimer,delete a.redoTransports,a.options[\"try multiple transports\"]=c}function f(){if(!a.reconnecting)return;if(a.connected)return e();if(a.connecting&&a.reconnecting)return a.reconnectionTimer=setTimeout(f,1e3);a.reconnectionAttempts++>=b?a.redoTransports?(a.publish(\"reconnect_failed\"),e()):(a.on(\"connect_failed\",f),a.options[\"try multiple transports\"]=!0,a.transports=a.origTransports,a.transport=a.getTransport(),a.redoTransports=!0,a.connect()):(a.reconnectionDelay<d&&(a.reconnectionDelay*=2),a.connect(),a.publish(\"reconnecting\",a.reconnectionDelay,a.reconnectionAttempts),a.reconnectionTimer=setTimeout(f,a.reconnectionDelay))}this.reconnecting=!0,this.reconnectionAttempts=0,this.reconnectionDelay=this.options[\"reconnection delay\"];var a=this,b=this.options[\"max reconnection attempts\"],c=this.options[\"try multiple transports\"],d=this.options[\"reconnection limit\"];this.options[\"try multiple transports\"]=!1,this.reconnectionTimer=setTimeout(f,this.reconnectionDelay),this.on(\"connect\",f)}}(\"undefined\"!=typeof io?io:module.exports,\"undefined\"!=typeof io?io:module.parent.exports,this),function(a,b){function c(a,b){this.socket=a,this.name=b||\"\",this.flags={},this.json=new d(this,\"json\"),this.ackPackets=0,this.acks={}}function d(a,b){this.namespace=a,this.name=b}a.SocketNamespace=c,b.util.mixin(c,b.EventEmitter),c.prototype.$emit=b.EventEmitter.prototype.emit,c.prototype.of=function(){return this.socket.of.apply(this.socket,arguments)},c.prototype.packet=function(a){return a.endpoint=this.name,this.socket.packet(a),this.flags={},this},c.prototype.send=function(a,b){var c={type:this.flags.json?\"json\":\"message\",data:a};return\"function\"==typeof b&&(c.id=++this.ackPackets,c.ack=!0,this.acks[c.id]=b),this.packet(c)},c.prototype.emit=function(a){var b=Array.prototype.slice.call(arguments,1),c=b[b.length-1],d={type:\"event\",name:a};return\"function\"==typeof c&&(d.id=++this.ackPackets,d.ack=\"data\",this.acks[d.id]=c,b=b.slice(0,b.length-1)),d.args=b,this.packet(d)},c.prototype.disconnect=function(){return this.name===\"\"?this.socket.disconnect():(this.packet({type:\"disconnect\"}),this.$emit(\"disconnect\")),this},c.prototype.onPacket=function(a){function d(){c.packet({type:\"ack\",args:b.util.toArray(arguments),ackId:a.id})}var c=this;switch(a.type){case\"connect\":this.$emit(\"connect\");break;case\"disconnect\":this.name===\"\"?this.socket.onDisconnect(a.reason||\"booted\"):this.$emit(\"disconnect\",a.reason);break;case\"message\":case\"json\":var e=[\"message\",a.data];a.ack==\"data\"?e.push(d):a.ack&&this.packet({type:\"ack\",ackId:a.id}),this.$emit.apply(this,e);break;case\"event\":var e=[a.name].concat(a.args);a.ack==\"data\"&&e.push(d),this.$emit.apply(this,e);break;case\"ack\":this.acks[a.ackId]&&(this.acks[a.ackId].apply(this,a.args),delete this.acks[a.ackId]);break;case\"error\":a.advice?this.socket.onError(a):a.reason==\"unauthorized\"?this.$emit(\"connect_failed\",a.reason):this.$emit(\"error\",a.reason)}},d.prototype.send=function(){this.namespace.flags[this.name]=!0,this.namespace.send.apply(this.namespace,arguments)},d.prototype.emit=function(){this.namespace.flags[this.name]=!0,this.namespace.emit.apply(this.namespace,arguments)}}(\"undefined\"!=typeof io?io:module.exports,\"undefined\"!=typeof io?io:module.parent.exports),function(a,b,c){function d(a){b.Transport.apply(this,arguments)}a.websocket=d,b.util.inherit(d,b.Transport),d.prototype.name=\"websocket\",d.prototype.open=function(){var a=b.util.query(this.socket.options.query),d=this,e;return e||(e=c.MozWebSocket||c.WebSocket),this.websocket=new e(this.prepareUrl()+a),this.websocket.onopen=function(){d.onOpen(),d.socket.setBuffer(!1)},this.websocket.onmessage=function(a){d.onData(a.data)},this.websocket.onclose=function(){d.onClose(),d.socket.setBuffer(!0)},this.websocket.onerror=function(a){d.onError(a)},this},b.util.ua.iDevice?d.prototype.send=function(a){var b=this;return setTimeout(function(){b.websocket.send(a)},0),this}:d.prototype.send=function(a){return this.websocket.send(a),this},d.prototype.payload=function(a){for(var b=0,c=a.length;b<c;b++)this.packet(a[b]);return this},d.prototype.close=function(){return this.websocket.close(),this},d.prototype.onError=function(a){this.socket.onError(a)},d.prototype.scheme=function(){return this.socket.options.secure?\"wss\":\"ws\"},d.check=function(){return\"WebSocket\"in c&&!(\"__addTask\"in WebSocket)||\"MozWebSocket\"in c},d.xdomainCheck=function(){return!0},b.transports.push(\"websocket\")}(\"undefined\"!=typeof io?io.Transport:module.exports,\"undefined\"!=typeof io?io:module.parent.exports,this),function(a,b){function c(){b.Transport.websocket.apply(this,arguments)}a.flashsocket=c,b.util.inherit(c,b.Transport.websocket),c.prototype.name=\"flashsocket\",c.prototype.open=function(){var a=this,c=arguments;return WebSocket.__addTask(function(){b.Transport.websocket.prototype.open.apply(a,c)}),this},c.prototype.send=function(){var a=this,c=arguments;return WebSocket.__addTask(function(){b.Transport.websocket.prototype.send.apply(a,c)}),this},c.prototype.close=function(){return WebSocket.__tasks.length=0,b.Transport.websocket.prototype.close.call(this),this},c.prototype.ready=function(a,d){function e(){var b=a.options,e=b[\"flash policy port\"],g=[\"http\"+(b.secure?\"s\":\"\")+\":/\",b.host+\":\"+b.port,b.resource,\"static/flashsocket\",\"WebSocketMain\"+(a.isXDomain()?\"Insecure\":\"\")+\".swf\"];c.loaded||(typeof WEB_SOCKET_SWF_LOCATION==\"undefined\"&&(WEB_SOCKET_SWF_LOCATION=g.join(\"/\")),e!==843&&WebSocket.loadFlashPolicyFile(\"xmlsocket://\"+b.host+\":\"+e),WebSocket.__initialize(),c.loaded=!0),d.call(f)}var f=this;if(document.body)return e();b.util.load(e)},c.check=function(){return typeof WebSocket!=\"undefined\"&&\"__initialize\"in WebSocket&&!!swfobject?swfobject.getFlashPlayerVersion().major>=10:!1},c.xdomainCheck=function(){return!0},typeof window!=\"undefined\"&&(WEB_SOCKET_DISABLE_AUTO_INITIALIZATION=!0),b.transports.push(\"flashsocket\")}(\"undefined\"!=typeof io?io.Transport:module.exports,\"undefined\"!=typeof io?io:module.parent.exports);if(\"undefined\"!=typeof window)var swfobject=function(){function A(){if(t)return;try{var a=i.getElementsByTagName(\"body\")[0].appendChild(Q(\"span\"));a.parentNode.removeChild(a)}catch(b){return}t=!0;var c=l.length;for(var d=0;d<c;d++)l[d]()}function B(a){t?a():l[l.length]=a}function C(b){if(typeof h.addEventListener!=a)h.addEventListener(\"load\",b,!1);else if(typeof i.addEventListener!=a)i.addEventListener(\"load\",b,!1);else if(typeof h.attachEvent!=a)R(h,\"onload\",b);else if(typeof h.onload==\"function\"){var c=h.onload;h.onload=function(){c(),b()}}else h.onload=b}function D(){k?E():F()}function E(){var c=i.getElementsByTagName(\"body\")[0],d=Q(b);d.setAttribute(\"type\",e);var f=c.appendChild(d);if(f){var g=0;(function(){if(typeof f.GetVariable!=a){var b=f.GetVariable(\"$version\");b&&(b=b.split(\" \")[1].split(\",\"),y.pv=[parseInt(b[0],10),parseInt(b[1],10),parseInt(b[2],10)])}else if(g<10){g++,setTimeout(arguments.callee,10);return}c.removeChild(d),f=null,F()})()}else F()}function F(){var b=m.length;if(b>0)for(var c=0;c<b;c++){var d=m[c].id,e=m[c].callbackFn,f={success:!1,id:d};if(y.pv[0]>0){var g=P(d);if(g)if(S(m[c].swfVersion)&&!(y.wk&&y.wk<312))U(d,!0),e&&(f.success=!0,f.ref=G(d),e(f));else if(m[c].expressInstall&&H()){var h={};h.data=m[c].expressInstall,h.width=g.getAttribute(\"width\")||\"0\",h.height=g.getAttribute(\"height\")||\"0\",g.getAttribute(\"class\")&&(h.styleclass=g.getAttribute(\"class\")),g.getAttribute(\"align\")&&(h.align=g.getAttribute(\"align\"));var i={},j=g.getElementsByTagName(\"param\"),k=j.length;for(var l=0;l<k;l++)j[l].getAttribute(\"name\").toLowerCase()!=\"movie\"&&(i[j[l].getAttribute(\"name\")]=j[l].getAttribute(\"value\"));I(h,i,d,e)}else J(g),e&&e(f)}else{U(d,!0);if(e){var n=G(d);n&&typeof n.SetVariable!=a&&(f.success=!0,f.ref=n),e(f)}}}}function G(c){var d=null,e=P(c);if(e&&e.nodeName==\"OBJECT\")if(typeof e.SetVariable!=a)d=e;else{var f=e.getElementsByTagName(b)[0];f&&(d=f)}return d}function H(){return!u&&S(\"6.0.65\")&&(y.win||y.mac)&&!(y.wk&&y.wk<312)}function I(b,c,d,e){u=!0,r=e||null,s={success:!1,id:d};var g=P(d);if(g){g.nodeName==\"OBJECT\"?(p=K(g),q=null):(p=g,q=d),b.id=f;if(typeof b.width==a||!/%$/.test(b.width)&&parseInt(b.width,10)<310)b.width=\"310\";if(typeof b.height==a||!/%$/.test(b.height)&&parseInt(b.height,10)<137)b.height=\"137\";i.title=i.title.slice(0,47)+\" - Flash Player Installation\";var j=y.ie&&y.win?[\"Active\"].concat(\"\").join(\"X\"):\"PlugIn\",k=\"MMredirectURL=\"+h.location.toString().replace(/&/g,\"%26\")+\"&MMplayerType=\"+j+\"&MMdoctitle=\"+i.title;typeof c.flashvars!=a?c.flashvars+=\"&\"+k:c.flashvars=k;if(y.ie&&y.win&&g.readyState!=4){var l=Q(\"div\");d+=\"SWFObjectNew\",l.setAttribute(\"id\",d),g.parentNode.insertBefore(l,g),g.style.display=\"none\",function(){g.readyState==4?g.parentNode.removeChild(g):setTimeout(arguments.callee,10)}()}L(b,c,d)}}function J(a){if(y.ie&&y.win&&a.readyState!=4){var b=Q(\"div\");a.parentNode.insertBefore(b,a),b.parentNode.replaceChild(K(a),b),a.style.display=\"none\",function(){a.readyState==4?a.parentNode.removeChild(a):setTimeout(arguments.callee,10)}()}else a.parentNode.replaceChild(K(a),a)}function K(a){var c=Q(\"div\");if(y.win&&y.ie)c.innerHTML=a.innerHTML;else{var d=a.getElementsByTagName(b)[0];if(d){var e=d.childNodes;if(e){var f=e.length;for(var g=0;g<f;g++)(e[g].nodeType!=1||e[g].nodeName!=\"PARAM\")&&e[g].nodeType!=8&&c.appendChild(e[g].cloneNode(!0))}}}return c}function L(c,d,f){var g,h=P(f);if(y.wk&&y.wk<312)return g;if(h){typeof c.id==a&&(c.id=f);if(y.ie&&y.win){var i=\"\";for(var j in c)c[j]!=Object.prototype[j]&&(j.toLowerCase()==\"data\"?d.movie=c[j]:j.toLowerCase()==\"styleclass\"?i+=' class=\"'+c[j]+'\"':j.toLowerCase()!=\"classid\"&&(i+=\" \"+j+'=\"'+c[j]+'\"'));var k=\"\";for(var l in d)d[l]!=Object.prototype[l]&&(k+='<param name=\"'+l+'\" value=\"'+d[l]+'\" />');h.outerHTML='<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"'+i+\">\"+k+\"</object>\",n[n.length]=c.id,g=P(c.id)}else{var m=Q(b);m.setAttribute(\"type\",e);for(var o in c)c[o]!=Object.prototype[o]&&(o.toLowerCase()==\"styleclass\"?m.setAttribute(\"class\",c[o]):o.toLowerCase()!=\"classid\"&&m.setAttribute(o,c[o]));for(var p in d)d[p]!=Object.prototype[p]&&p.toLowerCase()!=\"movie\"&&M(m,p,d[p]);h.parentNode.replaceChild(m,h),g=m}}return g}function M(a,b,c){var d=Q(\"param\");d.setAttribute(\"name\",b),d.setAttribute(\"value\",c),a.appendChild(d)}function N(a){var b=P(a);b&&b.nodeName==\"OBJECT\"&&(y.ie&&y.win?(b.style.display=\"none\",function(){b.readyState==4?O(a):setTimeout(arguments.callee,10)}()):b.parentNode.removeChild(b))}function O(a){var b=P(a);if(b){for(var c in b)typeof b[c]==\"function\"&&(b[c]=null);b.parentNode.removeChild(b)}}function P(a){var b=null;try{b=i.getElementById(a)}catch(c){}return b}function Q(a){return i.createElement(a)}function R(a,b,c){a.attachEvent(b,c),o[o.length]=[a,b,c]}function S(a){var b=y.pv,c=a.split(\".\");return c[0]=parseInt(c[0],10),c[1]=parseInt(c[1],10)||0,c[2]=parseInt(c[2],10)||0,b[0]>c[0]||b[0]==c[0]&&b[1]>c[1]||b[0]==c[0]&&b[1]==c[1]&&b[2]>=c[2]?!0:!1}function T(c,d,e,f){if(y.ie&&y.mac)return;var g=i.getElementsByTagName(\"head\")[0];if(!g)return;var h=e&&typeof e==\"string\"?e:\"screen\";f&&(v=null,w=null);if(!v||w!=h){var j=Q(\"style\");j.setAttribute(\"type\",\"text/css\"),j.setAttribute(\"media\",h),v=g.appendChild(j),y.ie&&y.win&&typeof i.styleSheets!=a&&i.styleSheets.length>0&&(v=i.styleSheets[i.styleSheets.length-1]),w=h}y.ie&&y.win?v&&typeof v.addRule==b&&v.addRule(c,d):v&&typeof i.createTextNode!=a&&v.appendChild(i.createTextNode(c+\" {\"+d+\"}\"))}function U(a,b){if(!x)return;var c=b?\"visible\":\"hidden\";t&&P(a)?P(a).style.visibility=c:T(\"#\"+a,\"visibility:\"+c)}function V(b){var c=/[\\\\\\\"<>\\.;]/,d=c.exec(b)!=null;return d&&typeof encodeURIComponent!=a?encodeURIComponent(b):b}var a=\"undefined\",b=\"object\",c=\"Shockwave Flash\",d=\"ShockwaveFlash.ShockwaveFlash\",e=\"application/x-shockwave-flash\",f=\"SWFObjectExprInst\",g=\"onreadystatechange\",h=window,i=document,j=navigator,k=!1,l=[D],m=[],n=[],o=[],p,q,r,s,t=!1,u=!1,v,w,x=!0,y=function(){var f=typeof i.getElementById!=a&&typeof i.getElementsByTagName!=a&&typeof i.createElement!=a,g=j.userAgent.toLowerCase(),l=j.platform.toLowerCase(),m=l?/win/.test(l):/win/.test(g),n=l?/mac/.test(l):/mac/.test(g),o=/webkit/.test(g)?parseFloat(g.replace(/^.*webkit\\/(\\d+(\\.\\d+)?).*$/,\"$1\")):!1,p=!1,q=[0,0,0],r=null;if(typeof j.plugins!=a&&typeof j.plugins[c]==b)r=j.plugins[c].description,r&&(typeof j.mimeTypes==a||!j.mimeTypes[e]||!!j.mimeTypes[e].enabledPlugin)&&(k=!0,p=!1,r=r.replace(/^.*\\s+(\\S+\\s+\\S+$)/,\"$1\"),q[0]=parseInt(r.replace(/^(.*)\\..*$/,\"$1\"),10),q[1]=parseInt(r.replace(/^.*\\.(.*)\\s.*$/,\"$1\"),10),q[2]=/[a-zA-Z]/.test(r)?parseInt(r.replace(/^.*[a-zA-Z]+(.*)$/,\"$1\"),10):0);else if(typeof h[[\"Active\"].concat(\"Object\").join(\"X\")]!=a)try{var s=new(window[[\"Active\"].concat(\"Object\").join(\"X\")])(d);s&&(r=s.GetVariable(\"$version\"),r&&(p=!0,r=r.split(\" \")[1].split(\",\"),q=[parseInt(r[0],10),parseInt(r[1],10),parseInt(r[2],10)]))}catch(t){}return{w3:f,pv:q,wk:o,ie:p,win:m,mac:n}}(),z=function(){if(!y.w3)return;(typeof i.readyState!=a&&i.readyState==\"complete\"||typeof i.readyState==a&&(i.getElementsByTagName(\"body\")[0]||i.body))&&A(),t||(typeof i.addEventListener!=a&&i.addEventListener(\"DOMContentLoaded\",A,!1),y.ie&&y.win&&(i.attachEvent(g,function(){i.readyState==\"complete\"&&(i.detachEvent(g,arguments.callee),A())}),h==top&&function(){if(t)return;try{i.documentElement.doScroll(\"left\")}catch(a){setTimeout(arguments.callee,0);return}A()}()),y.wk&&function(){if(t)return;if(!/loaded|complete/.test(i.readyState)){setTimeout(arguments.callee,0);return}A()}(),C(A))}(),W=function(){y.ie&&y.win&&window.attachEvent(\"onunload\",function(){var a=o.length;for(var b=0;b<a;b++)o[b][0].detachEvent(o[b][1],o[b][2]);var c=n.length;for(var d=0;d<c;d++)N(n[d]);for(var e in y)y[e]=null;y=null;for(var f in swfobject)swfobject[f]=null;swfobject=null})}();return{registerObject:function(a,b,c,d){if(y.w3&&a&&b){var e={};e.id=a,e.swfVersion=b,e.expressInstall=c,e.callbackFn=d,m[m.length]=e,U(a,!1)}else d&&d({success:!1,id:a})},getObjectById:function(a){if(y.w3)return G(a)},embedSWF:function(c,d,e,f,g,h,i,j,k,l){var m={success:!1,id:d};y.w3&&!(y.wk&&y.wk<312)&&c&&d&&e&&f&&g?(U(d,!1),B(function(){e+=\"\",f+=\"\";var n={};if(k&&typeof k===b)for(var o in k)n[o]=k[o];n.data=c,n.width=e,n.height=f;var p={};if(j&&typeof j===b)for(var q in j)p[q]=j[q];if(i&&typeof i===b)for(var r in i)typeof p.flashvars!=a?p.flashvars+=\"&\"+r+\"=\"+i[r]:p.flashvars=r+\"=\"+i[r];if(S(g)){var s=L(n,p,d);n.id==d&&U(d,!0),m.success=!0,m.ref=s}else{if(h&&H()){n.data=h,I(n,p,d,l);return}U(d,!0)}l&&l(m)})):l&&l(m)},switchOffAutoHideShow:function(){x=!1},ua:y,getFlashPlayerVersion:function(){return{major:y.pv[0],minor:y.pv[1],release:y.pv[2]}},hasFlashPlayerVersion:S,createSWF:function(a,b,c){return y.w3?L(a,b,c):undefined},showExpressInstall:function(a,b,c,d){y.w3&&H()&&I(a,b,c,d)},removeSWF:function(a){y.w3&&N(a)},createCSS:function(a,b,c,d){y.w3&&T(a,b,c,d)},addDomLoadEvent:B,addLoadEvent:C,getQueryParamValue:function(a){var b=i.location.search||i.location.hash;if(b){/\\?/.test(b)&&(b=b.split(\"?\")[1]);if(a==null)return V(b);var c=b.split(\"&\");for(var d=0;d<c.length;d++)if(c[d].substring(0,c[d].indexOf(\"=\"))==a)return V(c[d].substring(c[d].indexOf(\"=\")+1))}return\"\"},expressInstallCallback:function(){if(u){var a=P(f);a&&p&&(a.parentNode.replaceChild(p,a),q&&(U(q,!0),y.ie&&y.win&&(p.style.display=\"block\")),r&&r(s)),u=!1}}}}();(function(){if(\"undefined\"==typeof window||window.WebSocket)return;var a=window.console;if(!a||!a.log||!a.error)a={log:function(){},error:function(){}};if(!swfobject.hasFlashPlayerVersion(\"10.0.0\")){a.error(\"Flash Player >= 10.0.0 is required.\");return}location.protocol==\"file:\"&&a.error(\"WARNING: web-socket-js doesn't work in file:///... URL unless you set Flash Security Settings properly. Open the page via Web server i.e. http://...\"),WebSocket=function(a,b,c,d,e){var f=this;f.__id=WebSocket.__nextId++,WebSocket.__instances[f.__id]=f,f.readyState=WebSocket.CONNECTING,f.bufferedAmount=0,f.__events={},b?typeof b==\"string\"&&(b=[b]):b=[],setTimeout(function(){WebSocket.__addTask(function(){WebSocket.__flash.create(f.__id,a,b,c||null,d||0,e||null)})},0)},WebSocket.prototype.send=function(a){if(this.readyState==WebSocket.CONNECTING)throw\"INVALID_STATE_ERR: Web Socket connection has not been established\";var b=WebSocket.__flash.send(this.__id,encodeURIComponent(a));return b<0?!0:(this.bufferedAmount+=b,!1)},WebSocket.prototype.close=function(){if(this.readyState==WebSocket.CLOSED||this.readyState==WebSocket.CLOSING)return;this.readyState=WebSocket.CLOSING,WebSocket.__flash.close(this.__id)},WebSocket.prototype.addEventListener=function(a,b,c){a in this.__events||(this.__events[a]=[]),this.__events[a].push(b)},WebSocket.prototype.removeEventListener=function(a,b,c){if(!(a in this.__events))return;var d=this.__events[a];for(var e=d.length-1;e>=0;--e)if(d[e]===b){d.splice(e,1);break}},WebSocket.prototype.dispatchEvent=function(a){var b=this.__events[a.type]||[];for(var c=0;c<b.length;++c)b[c](a);var d=this[\"on\"+a.type];d&&d(a)},WebSocket.prototype.__handleEvent=function(a){\"readyState\"in a&&(this.readyState=a.readyState),\"protocol\"in a&&(this.protocol=a.protocol);var b;if(a.type==\"open\"||a.type==\"error\")b=this.__createSimpleEvent(a.type);else if(a.type==\"close\")b=this.__createSimpleEvent(\"close\");else{if(a.type!=\"message\")throw\"unknown event type: \"+a.type;var c=decodeURIComponent(a.message);b=this.__createMessageEvent(\"message\",c)}this.dispatchEvent(b)},WebSocket.prototype.__createSimpleEvent=function(a){if(document.createEvent&&window.Event){var b=document.createEvent(\"Event\");return b.initEvent(a,!1,!1),b}return{type:a,bubbles:!1,cancelable:!1}},WebSocket.prototype.__createMessageEvent=function(a,b){if(document.createEvent&&window.MessageEvent&&!window.opera){var c=document.createEvent(\"MessageEvent\");return c.initMessageEvent(\"message\",!1,!1,b,null,null,window,null),c}return{type:a,data:b,bubbles:!1,cancelable:!1}},WebSocket.CONNECTING=0,WebSocket.OPEN=1,WebSocket.CLOSING=2,WebSocket.CLOSED=3,WebSocket.__flash=null,WebSocket.__instances={},WebSocket.__tasks=[],WebSocket.__nextId=0,WebSocket.loadFlashPolicyFile=function(a){WebSocket.__addTask(function(){WebSocket.__flash.loadManualPolicyFile(a)})},WebSocket.__initialize=function(){if(WebSocket.__flash)return;WebSocket.__swfLocation&&(window.WEB_SOCKET_SWF_LOCATION=WebSocket.__swfLocation);if(!window.WEB_SOCKET_SWF_LOCATION){a.error(\"[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf\");return}var b=document.createElement(\"div\");b.id=\"webSocketContainer\",b.style.position=\"absolute\",WebSocket.__isFlashLite()?(b.style.left=\"0px\",b.style.top=\"0px\"):(b.style.left=\"-100px\",b.style.top=\"-100px\");var c=document.createElement(\"div\");c.id=\"webSocketFlash\",b.appendChild(c),document.body.appendChild(b),swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION,\"webSocketFlash\",\"1\",\"1\",\"10.0.0\",null,null,{hasPriority:!0,swliveconnect:!0,allowScriptAccess:\"always\"},null,function(b){b.success||a.error(\"[WebSocket] swfobject.embedSWF failed\")})},WebSocket.__onFlashInitialized=function(){setTimeout(function(){WebSocket.__flash=document.getElementById(\"webSocketFlash\"),WebSocket.__flash.setCallerUrl(location.href),WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);for(var a=0;a<WebSocket.__tasks.length;++a)WebSocket.__tasks[a]();WebSocket.__tasks=[]},0)},WebSocket.__onFlashEvent=function(){return setTimeout(function(){try{var b=WebSocket.__flash.receiveEvents();for(var c=0;c<b.length;++c)WebSocket.__instances[b[c].webSocketId].__handleEvent(b[c])}catch(d){a.error(d)}},0),!0},WebSocket.__log=function(b){a.log(decodeURIComponent(b))},WebSocket.__error=function(b){a.error(decodeURIComponent(b))},WebSocket.__addTask=function(a){WebSocket.__flash?a():WebSocket.__tasks.push(a)},WebSocket.__isFlashLite=function(){if(!window.navigator||!window.navigator.mimeTypes)return!1;var a=window.navigator.mimeTypes[\"application/x-shockwave-flash\"];return!a||!a.enabledPlugin||!a.enabledPlugin.filename?!1:a.enabledPlugin.filename.match(/flashlite/i)?!0:!1},window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION||(window.addEventListener?window.addEventListener(\"load\",function(){WebSocket.__initialize()},!1):window.attachEvent(\"onload\",function(){WebSocket.__initialize()}))})(),function(a,b,c){function d(a){if(!a)return;b.Transport.apply(this,arguments),this.sendBuffer=[]}function e(){}a.XHR=d,b.util.inherit(d,b.Transport),d.prototype.open=function(){return this.socket.setBuffer(!1),this.onOpen(),this.get(),this.setCloseTimeout(),this},d.prototype.payload=function(a){var c=[];for(var d=0,e=a.length;d<e;d++)c.push(b.parser.encodePacket(a[d]));this.send(b.parser.encodePayload(c))},d.prototype.send=function(a){return this.post(a),this},d.prototype.post=function(a){function d(){this.readyState==4&&(this.onreadystatechange=e,b.posting=!1,this.status==200?b.socket.setBuffer(!1):b.onClose())}function f(){this.onload=e,b.socket.setBuffer(!1)}var b=this;this.socket.setBuffer(!0),this.sendXHR=this.request(\"POST\"),c.XDomainRequest&&this.sendXHR instanceof XDomainRequest?this.sendXHR.onload=this.sendXHR.onerror=f:this.sendXHR.onreadystatechange=d,this.sendXHR.send(a)},d.prototype.close=function(){return this.onClose(),this},d.prototype.request=function(a){var c=b.util.request(this.socket.isXDomain()),d=b.util.query(this.socket.options.query,\"t=\"+ +(new Date));c.open(a||\"GET\",this.prepareUrl()+d,!0);if(a==\"POST\")try{c.setRequestHeader?c.setRequestHeader(\"Content-type\",\"text/plain;charset=UTF-8\"):c.contentType=\"text/plain\"}catch(e){}return c},d.prototype.scheme=function(){return this.socket.options.secure?\"https\":\"http\"},d.check=function(a,d){try{var e=b.util.request(d),f=c.XDomainRequest&&e instanceof XDomainRequest,g=a&&a.options&&a.options.secure?\"https:\":\"http:\",h=c.location&&g!=c.location.protocol;if(e&&(!f||!h))return!0}catch(i){}return!1},d.xdomainCheck=function(a){return d.check(a,!0)}}(\"undefined\"!=typeof io?io.Transport:module.exports,\"undefined\"!=typeof io?io:module.parent.exports,this),function(a,b){function c(a){b.Transport.XHR.apply(this,arguments)}a.htmlfile=c,b.util.inherit(c,b.Transport.XHR),c.prototype.name=\"htmlfile\",c.prototype.get=function(){this.doc=new(window[[\"Active\"].concat(\"Object\").join(\"X\")])(\"htmlfile\"),this.doc.open(),this.doc.write(\"<html></html>\"),this.doc.close(),this.doc.parentWindow.s=this;var a=this.doc.createElement(\"div\");a.className=\"socketio\",this.doc.body.appendChild(a),this.iframe=this.doc.createElement(\"iframe\"),a.appendChild(this.iframe);var c=this,d=b.util.query(this.socket.options.query,\"t=\"+ +(new Date));this.iframe.src=this.prepareUrl()+d,b.util.on(window,\"unload\",function(){c.destroy()})},c.prototype._=function(a,b){a=a.replace(/\\\\\\//g,\"/\"),this.onData(a);try{var c=b.getElementsByTagName(\"script\")[0];c.parentNode.removeChild(c)}catch(d){}},c.prototype.destroy=function(){if(this.iframe){try{this.iframe.src=\"about:blank\"}catch(a){}this.doc=null,this.iframe.parentNode.removeChild(this.iframe),this.iframe=null,CollectGarbage()}},c.prototype.close=function(){return this.destroy(),b.Transport.XHR.prototype.close.call(this)},c.check=function(a){if(typeof window!=\"undefined\"&&[\"Active\"].concat(\"Object\").join(\"X\")in window)try{var c=new(window[[\"Active\"].concat(\"Object\").join(\"X\")])(\"htmlfile\");return c&&b.Transport.XHR.check(a)}catch(d){}return!1},c.xdomainCheck=function(){return!1},b.transports.push(\"htmlfile\")}(\"undefined\"!=typeof io?io.Transport:module.exports,\"undefined\"!=typeof io?io:module.parent.exports),function(a,b,c){function d(){b.Transport.XHR.apply(this,arguments)}function e(){}a[\"xhr-polling\"]=d,b.util.inherit(d,b.Transport.XHR),b.util.merge(d,b.Transport.XHR),d.prototype.name=\"xhr-polling\",d.prototype.heartbeats=function(){return!1},d.prototype.open=function(){var a=this;return b.Transport.XHR.prototype.open.call(a),!1},d.prototype.get=function(){function b(){this.readyState==4&&(this.onreadystatechange=e,this.status==200?(a.onData(this.responseText),a.get()):a.onClose())}function d(){this.onload=e,this.onerror=e,a.retryCounter=1,a.onData(this.responseText),a.get()}function f(){a.retryCounter++,!a.retryCounter||a.retryCounter>3?a.onClose():a.get()}if(!this.isOpen)return;var a=this;this.xhr=this.request(),c.XDomainRequest&&this.xhr instanceof XDomainRequest?(this.xhr.onload=d,this.xhr.onerror=f):this.xhr.onreadystatechange=b,this.xhr.send(null)},d.prototype.onClose=function(){b.Transport.XHR.prototype.onClose.call(this);if(this.xhr){this.xhr.onreadystatechange=this.xhr.onload=this.xhr.onerror=e;try{this.xhr.abort()}catch(a){}this.xhr=null}},d.prototype.ready=function(a,c){var d=this;b.util.defer(function(){c.call(d)})},b.transports.push(\"xhr-polling\")}(\"undefined\"!=typeof io?io.Transport:module.exports,\"undefined\"!=typeof io?io:module.parent.exports,this),function(a,b,c){function e(a){b.Transport[\"xhr-polling\"].apply(this,arguments),this.index=b.j.length;var c=this;b.j.push(function(a){c._(a)})}var d=c.document&&\"MozAppearance\"in c.document.documentElement.style;a[\"jsonp-polling\"]=e,b.util.inherit(e,b.Transport[\"xhr-polling\"]),e.prototype.name=\"jsonp-polling\",e.prototype.post=function(a){function i(){j(),c.socket.setBuffer(!1)}function j(){c.iframe&&c.form.removeChild(c.iframe);try{h=document.createElement('<iframe name=\"'+c.iframeId+'\">')}catch(a){h=document.createElement(\"iframe\"),h.name=c.iframeId}h.id=c.iframeId,c.form.appendChild(h),c.iframe=h}var c=this,d=b.util.query(this.socket.options.query,\"t=\"+ +(new Date)+\"&i=\"+this.index);if(!this.form){var e=document.createElement(\"form\"),f=document.createElement(\"textarea\"),g=this.iframeId=\"socketio_iframe_\"+this.index,h;e.className=\"socketio\",e.style.position=\"absolute\",e.style.top=\"0px\",e.style.left=\"0px\",e.style.display=\"none\",e.target=g,e.method=\"POST\",e.setAttribute(\"accept-charset\",\"utf-8\"),f.name=\"d\",e.appendChild(f),document.body.appendChild(e),this.form=e,this.area=f}this.form.action=this.prepareUrl()+d,j(),this.area.value=b.JSON.stringify(a);try{this.form.submit()}catch(k){}this.iframe.attachEvent?h.onreadystatechange=function(){c.iframe.readyState==\"complete\"&&i()}:this.iframe.onload=i,this.socket.setBuffer(!0)},e.prototype.get=function(){var a=this,c=document.createElement(\"script\"),e=b.util.query(this.socket.options.query,\"t=\"+ +(new Date)+\"&i=\"+this.index);this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),c.async=!0,c.src=this.prepareUrl()+e,c.onerror=function(){a.onClose()};var f=document.getElementsByTagName(\"script\")[0];f.parentNode.insertBefore(c,f),this.script=c,d&&setTimeout(function(){var a=document.createElement(\"iframe\");document.body.appendChild(a),document.body.removeChild(a)},100)},e.prototype._=function(a){return this.onData(a),this.isOpen&&this.get(),this},e.prototype.ready=function(a,c){var e=this;if(!d)return c.call(this);b.util.load(function(){c.call(e)})},e.check=function(){return\"document\"in c},e.xdomainCheck=function(){return!0},b.transports.push(\"jsonp-polling\")}(\"undefined\"!=typeof io?io.Transport:module.exports,\"undefined\"!=typeof io?io:module.parent.exports,this),typeof define==\"function\"&&define.amd&&define([],function(){return io})})()",
    "/*\r\n * angular-socket-io v0.2.0\r\n * (c) 2013 Brian Ford http://briantford.com\r\n * License: MIT\r\n */\r\n\r\n'use strict';\r\n\r\nangular.module('btford.socket-io', []).\r\n    provider('socket', function () {\r\n\r\n        // when forwarding events, prefix the event name\r\n        var prefix = 'socket:',\r\n            ioSocket;\r\n\r\n        // expose to provider\r\n        this.$get = function ($rootScope, $timeout) {\r\n\r\n            var socket = ioSocket || io.connect();\r\n\r\n            var asyncAngularify = function (callback) {\r\n                return function () {\r\n                    var args = arguments;\r\n                    $timeout(function () {\r\n                        callback.apply(socket, args);\r\n                    }, 0);\r\n                };\r\n            };\r\n\r\n            var addListener = function (eventName, callback) {\r\n                socket.on(eventName, asyncAngularify(callback));\r\n            };\r\n\r\n            var wrappedSocket = {\r\n                on: addListener,\r\n                addListener: addListener,\r\n\r\n                emit: function (eventName, data, callback) {\r\n                    if (callback) {\r\n                        socket.emit(eventName, data, asyncAngularify(callback));\r\n                    } else {\r\n                        socket.emit(eventName, data);\r\n                    }\r\n                },\r\n\r\n                removeListener: function () {\r\n                    var args = arguments;\r\n                    return socket.removeListener.apply(socket, args);\r\n                },\r\n\r\n                // when socket.on('someEvent', fn (data) { ... }),\r\n                // call scope.$broadcast('someEvent', data)\r\n                forward: function (events, scope) {\r\n                    if (events instanceof Array === false) {\r\n                        events = [events];\r\n                    }\r\n                    if (!scope) {\r\n                        scope = $rootScope;\r\n                    }\r\n                    events.forEach(function (eventName) {\r\n                        var prefixed = prefix + eventName;\r\n                        var forwardEvent = asyncAngularify(function (data) {\r\n                            scope.$broadcast(prefixed, data);\r\n                        });\r\n                        scope.$on('$destroy', function () {\r\n                            socket.removeListener(eventName, forwardEvent);\r\n                        });\r\n                        socket.on(eventName, forwardEvent);\r\n                    });\r\n                }\r\n            };\r\n\r\n            return wrappedSocket;\r\n        };\r\n\r\n        this.prefix = function (newPrefix) {\r\n            prefix = newPrefix;\r\n        };\r\n\r\n        this.ioSocket = function (socket) {\r\n            ioSocket = socket;\r\n        };\r\n    });",
    "/**\r\n * angular-ui-utils - Swiss-Army-Knife of AngularJS tools (with no external dependencies!)\r\n * @version v0.0.3 - 2013-06-30\r\n * @link http://angular-ui.github.com\r\n * @license MIT License, http://www.opensource.org/licenses/MIT\r\n */\r\nangular.module(\"ui.event\",[]).directive(\"uiEvent\",[\"$parse\",function(a){return function(b,c,d){var e=b.$eval(d.uiEvent);angular.forEach(e,function(d,e){var f=a(d);c.bind(e,function(a){var c=Array.prototype.slice.call(arguments);c=c.splice(1),f(b,{$event:a,$params:c}),b.$$phase||b.$apply()})})}}]),angular.module(\"ui.format\",[]).filter(\"format\",function(){return function(a,b){var c=a;if(angular.isString(c)&&void 0!==b)if(angular.isArray(b)||angular.isObject(b)||(b=[b]),angular.isArray(b)){var d=b.length,e=function(a,c){return c=parseInt(c,10),c>=0&&d>c?b[c]:a};c=c.replace(/\\$([0-9]+)/g,e)}else angular.forEach(b,function(a,b){c=c.split(\":\"+b).join(a)});return c}}),angular.module(\"ui.highlight\",[]).filter(\"highlight\",function(){return function(a,b,c){return b||angular.isNumber(b)?(a=a.toString(),b=b.toString(),c?a.split(b).join('<span class=\"ui-match\">'+b+\"</span>\"):a.replace(new RegExp(b,\"gi\"),'<span class=\"ui-match\">$&</span>')):a}}),angular.module(\"ui.indeterminate\",[]).directive(\"uiIndeterminate\",[function(){return{compile:function(a,b){return b.type&&\"checkbox\"===b.type.toLowerCase()?function(a,b,c){a.$watch(c.uiIndeterminate,function(a){b[0].indeterminate=!!a})}:angular.noop}}}]),angular.module(\"ui.inflector\",[]).filter(\"inflector\",function(){function a(a){return a.replace(/^([a-z])|\\s+([a-z])/g,function(a){return a.toUpperCase()})}function b(a,b){return a.replace(/[A-Z]/g,function(a){return b+a})}var c={humanize:function(c){return a(b(c,\" \").split(\"_\").join(\" \"))},underscore:function(a){return a.substr(0,1).toLowerCase()+b(a.substr(1),\"_\").toLowerCase().split(\" \").join(\"_\")},variable:function(b){return b=b.substr(0,1).toLowerCase()+a(b.split(\"_\").join(\" \")).substr(1).split(\" \").join(\"\")}};return function(a,b){return b!==!1&&angular.isString(a)?(b=b||\"humanize\",c[b](a)):a}}),angular.module(\"ui.jq\",[]).value(\"uiJqConfig\",{}).directive(\"uiJq\",[\"uiJqConfig\",\"$timeout\",function(a,b){return{restrict:\"A\",compile:function(c,d){if(!angular.isFunction(c[d.uiJq]))throw new Error('ui-jq: The \"'+d.uiJq+'\" function does not exist');var e=a&&a[d.uiJq];return function(a,c,d){function f(){b(function(){c[d.uiJq].apply(c,g)},0,!1)}var g=[];d.uiOptions?(g=a.$eval(\"[\"+d.uiOptions+\"]\"),angular.isObject(e)&&angular.isObject(g[0])&&(g[0]=angular.extend({},e,g[0]))):e&&(g=[e]),d.ngModel&&c.is(\"select,input,textarea\")&&c.bind(\"change\",function(){c.trigger(\"input\")}),d.uiRefresh&&a.$watch(d.uiRefresh,function(){f()}),f()}}}}]),angular.module(\"ui.keypress\",[]).factory(\"keypressHelper\",[\"$parse\",function(a){var b={8:\"backspace\",9:\"tab\",13:\"enter\",27:\"esc\",32:\"space\",33:\"pageup\",34:\"pagedown\",35:\"end\",36:\"home\",37:\"left\",38:\"up\",39:\"right\",40:\"down\",45:\"insert\",46:\"delete\"},c=function(a){return a.charAt(0).toUpperCase()+a.slice(1)};return function(d,e,f,g){var h,i=[];h=e.$eval(g[\"ui\"+c(d)]),angular.forEach(h,function(b,c){var d,e;e=a(b),angular.forEach(c.split(\" \"),function(a){d={expression:e,keys:{}},angular.forEach(a.split(\"-\"),function(a){d.keys[a]=!0}),i.push(d)})}),f.bind(d,function(a){var c=!(!a.metaKey||a.ctrlKey),f=!!a.altKey,g=!!a.ctrlKey,h=!!a.shiftKey,j=a.keyCode;\"keypress\"===d&&!h&&j>=97&&122>=j&&(j-=32),angular.forEach(i,function(d){var i=d.keys[b[j]]||d.keys[j.toString()],k=!!d.keys.meta,l=!!d.keys.alt,m=!!d.keys.ctrl,n=!!d.keys.shift;i&&k===c&&l===f&&m===g&&n===h&&e.$apply(function(){d.expression(e,{$event:a})})})})}}]),angular.module(\"ui.keypress\").directive(\"uiKeydown\",[\"keypressHelper\",function(a){return{link:function(b,c,d){a(\"keydown\",b,c,d)}}}]),angular.module(\"ui.keypress\").directive(\"uiKeypress\",[\"keypressHelper\",function(a){return{link:function(b,c,d){a(\"keypress\",b,c,d)}}}]),angular.module(\"ui.keypress\").directive(\"uiKeyup\",[\"keypressHelper\",function(a){return{link:function(b,c,d){a(\"keyup\",b,c,d)}}}]),angular.module(\"ui.mask\",[]).value(\"uiMaskConfig\",{maskDefinitions:{9:/\\d/,A:/[a-zA-Z]/,\"*\":/[a-zA-Z0-9]/}}).directive(\"uiMask\",[\"uiMaskConfig\",function(a){return{priority:100,require:\"ngModel\",restrict:\"A\",compile:function(){var b=a;return function(a,c,d,e){function f(a){return angular.isDefined(a)?(p(a),K?(j(),k(),!0):i()):i()}function g(a){return K?(D=n(a||\"\"),F=m(D),e.$setValidity(\"mask\",F),F&&D.length?o(D):void 0):a}function h(a){return K?(D=n(a||\"\"),F=m(D),e.$viewValue=D.length?o(D):\"\",e.$setValidity(\"mask\",F),\"\"===D&&void 0!==e.$error.required&&e.$setValidity(\"required\",!1),F?D:void 0):a}function i(){return K=!1,l(),angular.isDefined(M)?c.attr(\"placeholder\",M):c.removeAttr(\"placeholder\"),angular.isDefined(N)?c.attr(\"maxlength\",N):c.removeAttr(\"maxlength\"),c.val(e.$modelValue),e.$viewValue=e.$modelValue,!1}function j(){D=H=n(e.$modelValue||\"\"),E=G=o(D),F=m(D);var a=F&&D.length?E:\"\";d.maxlength&&c.attr(\"maxlength\",2*y[y.length-1]),c.attr(\"placeholder\",A),c.val(a),e.$viewValue=a}function k(){L||(c.bind(\"blur\",q),c.bind(\"mousedown mouseup\",r),c.bind(\"input keyup click\",t),L=!0)}function l(){L&&(c.unbind(\"blur\",q),c.unbind(\"mousedown\",r),c.unbind(\"mouseup\",r),c.unbind(\"input\",t),c.unbind(\"keyup\",t),c.unbind(\"click\",t),L=!1)}function m(a){return a.length?a.length>=C:!0}function n(a){var b=\"\",c=z.slice();return a=a.toString(),angular.forEach(B,function(b){a=a.replace(b,\"\")}),angular.forEach(a.split(\"\"),function(a){c.length&&c[0].test(a)&&(b+=a,c.shift())}),b}function o(a){var b=\"\",c=y.slice();return angular.forEach(A.split(\"\"),function(d,e){a.length&&e===c[0]?(b+=a.charAt(0)||\"_\",a=a.substr(1),c.shift()):b+=d}),b}function p(a){var b=0;if(y=[],z=[],A=\"\",\"string\"==typeof a){C=0;var c=!1;angular.forEach(a.split(\"\"),function(a){O.maskDefinitions[a]?(y.push(b),A+=\"_\",z.push(O.maskDefinitions[a]),b++,c||C++):\"?\"===a?c=!0:(A+=a,b++)})}y.push(y.slice().pop()+1),B=A.replace(/[_]+/g,\"_\").replace(/([^_]+)([a-zA-Z0-9])([^_])/g,\"$1$2_$3\").split(\"_\"),K=y.length>1?!0:!1}function q(){I=0,J=0,F&&0!==D.length||(E=\"\",c.val(\"\"),a.$apply(function(){e.$setViewValue(\"\")}))}function r(a){\"mousedown\"===a.type?c.bind(\"mouseout\",s):c.unbind(\"mouseout\",s)}function s(){J=x(this),c.unbind(\"mouseout\",s)}function t(b){b=b||{};var d=b.which,f=b.type;if(16!==d&&91!==d){var g,h=c.val(),i=G,j=n(h),k=H,l=!1,m=v(this)||0,p=I||0,q=m-p,r=y[0],s=y[j.length]||y.slice().shift(),t=J||0,z=x(this)>0,A=t>0,B=h.length>i.length||t&&h.length>i.length-t,C=h.length<i.length||t&&h.length===i.length-t,D=d>=37&&40>=d&&b.shiftKey,E=37===d,F=8===d||\"keyup\"!==f&&C&&-1===q,K=46===d||\"keyup\"!==f&&C&&0===q&&!A,L=(E||F||\"click\"===f)&&m>r;if(J=x(this),!D&&(!z||\"click\"!==f&&\"keyup\"!==f)){if(\"input\"===f&&C&&!A&&j===k){for(;F&&m>r&&!u(m);)m--;for(;K&&s>m&&-1===y.indexOf(m);)m++;var M=y.indexOf(m);j=j.substring(0,M)+j.substring(M+1),l=!0}for(g=o(j),G=g,H=j,c.val(g),l&&a.$apply(function(){e.$setViewValue(j)}),B&&r>=m&&(m=r+1),L&&m--,m=m>s?s:r>m?r:m;!u(m)&&m>r&&s>m;)m+=L?-1:1;(L&&s>m||B&&!u(p))&&m++,I=m,w(this,m)}}}function u(a){return y.indexOf(a)>-1}function v(a){if(void 0!==a.selectionStart)return a.selectionStart;if(document.selection){a.focus();var b=document.selection.createRange();return b.moveStart(\"character\",-a.value.length),b.text.length}return 0}function w(a,b){if(0!==a.offsetWidth&&0!==a.offsetHeight)if(a.setSelectionRange)a.focus(),a.setSelectionRange(b,b);else if(a.createTextRange){var c=a.createTextRange();c.collapse(!0),c.moveEnd(\"character\",b),c.moveStart(\"character\",b),c.select()}}function x(a){return void 0!==a.selectionStart?a.selectionEnd-a.selectionStart:document.selection?document.selection.createRange().text.length:0}var y,z,A,B,C,D,E,F,G,H,I,J,K=!1,L=!1,M=d.placeholder,N=d.maxlength,O={};d.uiOptions?(O=a.$eval(\"[\"+d.uiOptions+\"]\"),angular.isObject(O[0])&&(O=function(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&(b[c]?angular.extend(b[c],a[c]):b[c]=angular.copy(a[c]));return b}(b,O[0]))):O=b,d.$observe(\"uiMask\",f),e.$formatters.push(g),e.$parsers.push(h),c.bind(\"mousedown mouseup\",r),Array.prototype.indexOf||(Array.prototype.indexOf=function(a){\"use strict\";if(null===this)throw new TypeError;var b=Object(this),c=b.length>>>0;if(0===c)return-1;var d=0;if(arguments.length>1&&(d=Number(arguments[1]),d!==d?d=0:0!==d&&1/0!==d&&d!==-1/0&&(d=(d>0||-1)*Math.floor(Math.abs(d)))),d>=c)return-1;for(var e=d>=0?d:Math.max(c-Math.abs(d),0);c>e;e++)if(e in b&&b[e]===a)return e;return-1})}}}}]),angular.module(\"ui.reset\",[]).value(\"uiResetConfig\",null).directive(\"uiReset\",[\"uiResetConfig\",function(a){var b=null;return void 0!==a&&(b=a),{require:\"ngModel\",link:function(a,c,d,e){var f;f=angular.element('<a class=\"ui-reset\" />'),c.wrap('<span class=\"ui-resetwrap\" />').after(f),f.bind(\"click\",function(c){c.preventDefault(),a.$apply(function(){d.uiReset?e.$setViewValue(a.$eval(d.uiReset)):e.$setViewValue(b),e.$render()})})}}}]),angular.module(\"ui.route\",[]).directive(\"uiRoute\",[\"$location\",\"$parse\",function(a,b){return{restrict:\"AC\",scope:!0,compile:function(c,d){var e;if(d.uiRoute)e=\"uiRoute\";else if(d.ngHref)e=\"ngHref\";else{if(!d.href)throw new Error(\"uiRoute missing a route or href property on \"+c[0]);e=\"href\"}return function(c,d,f){function g(b){(hash=b.indexOf(\"#\"))>-1&&(b=b.substr(hash+1)),j=function(){i(c,a.path().indexOf(b)>-1)},j()}function h(b){(hash=b.indexOf(\"#\"))>-1&&(b=b.substr(hash+1)),j=function(){var d=new RegExp(\"^\"+b+\"$\",[\"i\"]);i(c,d.test(a.path()))},j()}var i=b(f.ngModel||f.routeModel||\"$uiRoute\").assign,j=angular.noop;switch(e){case\"uiRoute\":f.uiRoute?h(f.uiRoute):f.$observe(\"uiRoute\",h);break;case\"ngHref\":f.ngHref?g(f.ngHref):f.$observe(\"ngHref\",g);break;case\"href\":g(f.href)}c.$on(\"$routeChangeSuccess\",function(){j()}),c.$on(\"$stateChangeSuccess\",function(){j()})}}}}]),angular.module(\"ui.scrollfix\",[]).directive(\"uiScrollfix\",[\"$window\",function(a){\"use strict\";return{require:\"^?uiScrollfixTarget\",link:function(b,c,d,e){var f=c[0].offsetTop,g=e&&e.$element||angular.element(a);d.uiScrollfix?\"-\"===d.uiScrollfix.charAt(0)?d.uiScrollfix=f-d.uiScrollfix.substr(1):\"+\"===d.uiScrollfix.charAt(0)&&(d.uiScrollfix=f+parseFloat(d.uiScrollfix.substr(1))):d.uiScrollfix=f,g.bind(\"scroll\",function(){var b;if(angular.isDefined(a.pageYOffset))b=a.pageYOffset;else{var e=document.compatMode&&\"BackCompat\"!==document.compatMode?document.documentElement:document.body;b=e.scrollTop}!c.hasClass(\"ui-scrollfix\")&&b>d.uiScrollfix?c.addClass(\"ui-scrollfix\"):c.hasClass(\"ui-scrollfix\")&&b<d.uiScrollfix&&c.removeClass(\"ui-scrollfix\")})}}}]).directive(\"uiScrollfixTarget\",[function(){\"use strict\";return{controller:function(a){this.$element=a}}}]),angular.module(\"ui.showhide\",[]).directive(\"uiShow\",[function(){return function(a,b,c){a.$watch(c.uiShow,function(a){a?b.addClass(\"ui-show\"):b.removeClass(\"ui-show\")})}}]).directive(\"uiHide\",[function(){return function(a,b,c){a.$watch(c.uiHide,function(a){a?b.addClass(\"ui-hide\"):b.removeClass(\"ui-hide\")})}}]).directive(\"uiToggle\",[function(){return function(a,b,c){a.$watch(c.uiToggle,function(a){a?b.removeClass(\"ui-hide\").addClass(\"ui-show\"):b.removeClass(\"ui-show\").addClass(\"ui-hide\")})}}]),angular.module(\"ui.unique\",[]).filter(\"unique\",[\"$parse\",function(a){return function(b,c){if(c===!1)return b;if((c||angular.isUndefined(c))&&angular.isArray(b)){var d=[],e=angular.isString(c)?a(c):function(a){return a},f=function(a){return angular.isObject(a)?e(a):a};angular.forEach(b,function(a){for(var b=!1,c=0;c<d.length;c++)if(angular.equals(f(d[c]),f(a))){b=!0;break}b||d.push(a)}),b=d}return b}}]),angular.module(\"ui.validate\",[]).directive(\"uiValidate\",function(){return{restrict:\"A\",require:\"ngModel\",link:function(a,b,c,d){var e,f,g={},h=a.$eval(c.uiValidate);h&&(angular.isString(h)&&(h={validator:h}),angular.forEach(h,function(b,c){e=function(e){var f=a.$eval(b,{$value:e});return angular.isObject(f)&&angular.isFunction(f.then)?(f.then(function(){d.$setValidity(c,!0)},function(){d.$setValidity(c,!1)}),e):f?(d.$setValidity(c,!0),e):(d.$setValidity(c,!1),void 0)},g[c]=e,d.$formatters.push(e),d.$parsers.push(e)}),c.uiValidateWatch&&(f=a.$eval(c.uiValidateWatch),angular.isString(f)?a.$watch(f,function(){angular.forEach(g,function(a){a(d.$modelValue)})}):angular.forEach(f,function(b,c){a.$watch(b,function(){g[c](d.$modelValue)})})))}}}),angular.module(\"ui.utils\",[\"ui.event\",\"ui.format\",\"ui.highlight\",\"ui.indeterminate\",\"ui.inflector\",\"ui.jq\",\"ui.keypress\",\"ui.mask\",\"ui.reset\",\"ui.route\",\"ui.scrollfix\",\"ui.showhide\",\"ui.unique\",\"ui.validate\"]);",
    "'use strict';\r\n\r\nfunction commentsGistCtrl($scope, $routeParams, ghAPI) {\r\n    console.log('>>>>>>>>>>>>> Comments',$scope.gist.comments);\r\n    if ($scope.gist.comments > 0) {\r\n        ghAPI.comments($routeParams.gistId, function (response) {\r\n            if (response.status === 200) {\r\n                $scope.comments = response.data;\r\n            } else {\r\n                console.warn('[!!!] >>> Comments not loaded - server responded with error.');\r\n            }\r\n        });\r\n    }\r\n}",
    "'use strict';\r\n\r\nfunction createGistCtrl($scope, $rootScope, ghAPI, gistData) {\r\n\r\n    $scope.description = '';\r\n\r\n    $scope.isPublic = false;\r\n    $scope.files = [\r\n        {\r\n            filename: '',\r\n            content: ''\r\n        }\r\n    ];\r\n\r\n    $scope.addFile = function () {\r\n        console.log('add file');\r\n        console.log($scope);\r\n        $scope.files.push({\r\n            content: '',\r\n            filename: '',\r\n            language: 'html'\r\n        });\r\n    };\r\n\r\n    $scope.deleteFile = function (index) {\r\n        $scope.files.splice(index,1);\r\n    };\r\n\r\n    $scope.enableEdit = function () {\r\n        $rootScope.edit = true;\r\n        $('.edit').slideDown('slow');\r\n    };\r\n    $scope.disableEdit = function () {\r\n        $rootScope.edit = false;\r\n        $('.edit').slideUp('slow');\r\n    };\r\n\r\n    $scope.dragStart = function (e) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        $('.edit').slideDown('slow');\r\n        $('.main section').addClass('dragarea');\r\n        $('.edit span').text('Drag detected - now drop!');\r\n        console.log('dragging start');\r\n    };\r\n\r\n    $scope.drop = function (e) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        var data = event.dataTransfer;\r\n        for (var i = 0; i < data.files.length; i++) { // For each dropped file\r\n            var file = data.files[i];\r\n            var reader = new FileReader();\r\n\r\n            $('.edit').slideUp('slow');\r\n            $('.ok').slideDown('slow');\r\n            $('.main section').removeClass('dragarea');\r\n            $('.ok span').html('Dropped: <b>' + file.name + '</b>');\r\n            $rootScope.edit = true;\r\n            reader.onloadend = (function (filename) {\r\n                return function (event) {\r\n                    $scope.files.push({\r\n                        filename: filename,\r\n                        content: event.target.result,\r\n                        language: 'html'\r\n                    });\r\n                    $scope.$digest();\r\n                };\r\n            })(file.name);\r\n\r\n            reader.readAsText(file);\r\n\r\n        }\r\n    };\r\n\r\n    $scope.dragEnd = function (e) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        console.log('drag end');\r\n    };\r\n\r\n    $scope.save = function ($event) {\r\n\r\n        if ($event) {\r\n            $event.preventDefault();\r\n        }\r\n\r\n        var data = {\r\n            description: $scope.description,\r\n            \"public\": $scope.isPublic,\r\n            files: {}\r\n        };\r\n\r\n        for (var file in $scope.files) {\r\n            data.files[$scope.files[file].filename] = {\r\n                content: $scope.files[file].content\r\n            };\r\n        }\r\n\r\n        ghAPI.create(data, function (response) {\r\n            if (response.status === 201) {\r\n\r\n                var newGist = {\r\n                    id: response.data.id,\r\n                    description: $scope.description,\r\n                    \"public\": $scope.isPublic,\r\n                    files: {}\r\n                };\r\n                $rootScope.edit = false;\r\n                $('.ok').slideDown('slow');\r\n                $('.ok span').text('Gist saved');\r\n                newGist.tags = $scope.description ? $scope.description.match(/(#[A-Za-z0-9\\-\\_]+)/g) : [];\r\n                gistData.list.unshift(newGist);\r\n\r\n                window.location.href = \"#/gist/\" + response.data.id;\r\n            }\r\n        });\r\n    };\r\n}",
    "'use strict';\r\n\r\nfunction headerController($scope, notificationService, $location, appSettings, gistData, onlineStatus) {\r\n\r\n    notificationService.login();\r\n\r\n    notificationService.forward('receiveNotification', $scope);\r\n    notificationService.forward('notificationRead', $scope);\r\n    notificationService.forward('identify', $scope);\r\n    notificationService.forward('disconnect', $scope);\r\n\r\n    $scope.avatar = 'https://secure.gravatar.com/avatar/' + JSON.parse(localStorage.settings).avatar;\r\n    $scope.notifications = notificationService.notifications;\r\n\r\n    $scope.logOut = function () {\r\n\r\n        console.log('logging out');\r\n        notificationService.logout();\r\n\r\n        gistData.list = [];\r\n        appSettings.logOut();\r\n    };\r\n\r\n    $scope.onlineStatus = onlineStatus;\r\n\r\n    $scope.$watch('onlineStatus.isOnline()', function(online) {\r\n       if (online && (!window.ioSocket.socket.connected || !window.ioSocket.socket.reconnecting) ) {\r\n           notificationService.login();\r\n       } else if (!online) {\r\n           notificationService.disconnected();\r\n       }\r\n    });\r\n\r\n    $scope.$on('socket:disconnect', function(e) {\r\n       console.log('disconnected');\r\n        notificationService.disconnected();\r\n    });\r\n\r\n    $scope.$on('socket:identify', function(e, data) {\r\n        // identify to the server\r\n        console.log('recieved identify request');\r\n        notificationService.register();\r\n\r\n    });\r\n\r\n    $scope.$on('socket:receiveNotification', function(e, data) {\r\n        console.log(data);\r\n        notificationService.add({\r\n            sender: data.sender,\r\n            name: data.name,\r\n            gistId: data.gistId,\r\n            gravatar_id: data.gravatar_id\r\n        });\r\n        console.log({sender: data.sender,\r\n            name: data.name,\r\n            gistId: data.gistId,\r\n            gravatar_id: data.gravatar_id});\r\n    });\r\n\r\n    $scope.$on('socket:notificationRead', function(e, data) {\r\n        // remove read notification\r\n        console.log('recieved read notification deleting notification');\r\n        (data && data.gistId) && notificationService.remove(data.gistId);\r\n    });\r\n\r\n    $scope.loadExternalGist = function(id, user) {\r\n        $location.url('/shared/' + user + '/' + id);\r\n    };\r\n\r\n    $scope.reject = function(id) {\r\n        console.log('remove id: ' + id);\r\n        notificationService.remove(id);\r\n        notificationService.send('notificationRead', {gistId: id});\r\n    };\r\n\r\n}",
    "'use strict';\r\n\r\nfunction listGistCtrl($scope, ghAPI, gistData, notificationService) {\r\n    $scope.gists = gistData.list;\r\n    $scope.onlineStatus = {\r\n       state: \"Offline\",\r\n       status: false\r\n    };\r\n\r\n    $scope.$on('ApplicationState', function(e, data) {\r\n        console.log(data);\r\n        $scope.onlineStatus.state = data.online ? \"Online\" : \"Offline\";\r\n        $scope.onlineStatus.status = data.online;\r\n\r\n    }, true);\r\n\r\n    // Get the gists list\r\n    if ($scope.gists.hasOwnProperty('lastUpdated')) {\r\n        console.log($scope.gists.lastUpdated);\r\n        var now = new Date();\r\n        var seconds = Math.round((now.getTime() - $scope.gists.lastUpdated.getTime()) / 1000);\r\n        console.log(seconds + ' have passed since last LIST updated');\r\n        if (seconds > 60) {\r\n            ghAPI.gists();\r\n        }\r\n    } else {\r\n        ghAPI.gists();\r\n    }\r\n}",
    "'use strict';\r\n\r\nfunction loginCtrl($scope, ghAPI, appSettings, notificationService) {\r\n    $scope.submit = function () {\r\n        $scope.spinner = true;\r\n        ghAPI.login($scope.user, $scope.pass, function (response) {\r\n            if (response.status === 201) {\r\n                console.log(response);\r\n                var data = {};\r\n                data.token = response.data.token;\r\n                ghAPI.setToken(response.data.token);\r\n                data.theme = appSettings.get('default') || 'default';\r\n                data.avatar = appSettings.get('none') || 'none';\r\n                data.editor_theme = appSettings.get('tomorrow') || 'tomorrow';\r\n                localStorage.settings = JSON.stringify(data);\r\n                window.location.href = '#/';\r\n            } else {\r\n                $scope.spinner = false;\r\n                console.warn('[!!!] >>> Log-in failed - server responded with error.');\r\n                $('.warn').slideDown('slow');\r\n                $('.warn span').text('Log-in failed - server responded with error');\r\n                setTimeout(function () {\r\n                    $('.warn').slideUp();\r\n                }, 2500);\r\n            }\r\n        });\r\n    };\r\n}",
    "'use strict';\r\n\r\nfunction mainCtrl($scope, $http, appSettings) {\r\n    $scope.latestVersion = appSettings.get('latestVersion');\r\n    $scope.currentVersion = '';\r\n    $scope.updateAvailable = false;\r\n\r\n    $scope.gotoSite = function () {\r\n        gui.Shell.openExternal('http://www.gistoapp.com');\r\n    };\r\n\r\n    // get the current version number\r\n    $http.get('./package.json').success(function (data) {\r\n        $scope.currentVersion = data.version;\r\n    });\r\n\r\n    var timestamp = new Date().getTime() - 86400000; // 1 day ago\r\n    if (!$scope.latestVersion || $scope.latestVersion.timestamp < timestamp) {\r\n        console.log('save');\r\n        // get the latest version number\r\n        $http({\r\n            url: 'https://api.github.com/repos/Gisto/Gisto/contents/app/package.json',\r\n            headers: {\r\n                Accept: \"application/vnd.github.3.raw\"\r\n            },\r\n            method: 'get'\r\n        }).success(function (data) {\r\n                appSettings.setOne('latestVersion', {version: data.version, timestamp: new Date().getTime() });\r\n            });\r\n\r\n    }\r\n\r\n    $scope.$watch('currentVersion + latestVersion', function () {\r\n\r\n        if ($scope.currentVersion && $scope.latestVersion && $scope.currentVersion !== $scope.latestVersion.version) {\r\n            $scope.updateAvailable = true;\r\n        }\r\n    });\r\n}",
    "'use strict';\r\n\r\nfunction settingsCtrl($scope, appSettings,$rootScope) {\r\n    $scope.themes = appSettings.theme_list;\r\n    $scope.editor_theme = appSettings.get('editor_theme') || 'tomorrow';\r\n    $scope.editor_themes = appSettings.editor_theme_list;\r\n    $scope.font_sizes = appSettings.font_size;\r\n    $scope.font_size = appSettings.get('font_size') || '13';\r\n    $scope.min_height = appSettings.get('min_height') || '';\r\n    $scope.max_height = appSettings.get('max_height') || '';\r\n    $scope.theme = appSettings.get('theme') || 'default';\r\n    $scope.token = appSettings.get('token') || '';\r\n    $scope.avatar = appSettings.get('avatar') || '';\r\n    angular.element('.the-gist pre').css({\r\n        'min-height': $scope.min_height + 'px',\r\n        'max-height': $scope.max_height + 'px'\r\n    });\r\n    $scope.update_settings = function () {\r\n        var data = {};\r\n        data.theme = $scope.theme;\r\n        data.editor_theme = $scope.editor_theme;\r\n        data.font_size = $scope.font_size;\r\n        data.min_height = $scope.min_height;\r\n        data.max_height = $scope.max_height;\r\n        data.token = appSettings.get('token');\r\n        data.avatar = appSettings.get('avatar');\r\n        var saved = appSettings.set(data, function (response) {\r\n            if (response.status === 'ok') {\r\n                console.log('SAVED SETTINGS');\r\n                window.location.reload();\r\n            } else {\r\n                console.log('NOT SAVED SETTINGS');\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n    $rootScope.goToSite = function(url,params) {\r\n\r\n        for(var i = 0, l = params.length; i < l; i++){\r\n            var out = url.replace(/{(\\d+)}/g,function(match, i) {\r\n                return typeof params[i] != 'undefined' ? params[i] : match;\r\n            });\r\n        }\r\n        console.log('Out:',out);\r\n        gui.Shell.openExternal(out);\r\n    };\r\n}",
    "'use strict';\r\n\r\nfunction sharedCtrl($scope, ghAPI, gistData, $routeParams, $location, notificationService, $window) {\r\n\r\n    $scope.author = $routeParams.user;\r\n\r\n    $scope.gist = ghAPI.gist($routeParams.id);\r\n\r\n    $scope.fork = function() {\r\n        ghAPI.fork($routeParams.id).then(function(data) {\r\n            notificationService.remove($routeParams.id);\r\n            notificationService.send('notificationRead', {gistId: $routeParams.id});\r\n            $location.url('/gist/' + data.id);\r\n        });\r\n    };\r\n\r\n    $scope.reject = function() {\r\n        notificationService.remove($routeParams.id);\r\n        console.log('sending notificationRead request');\r\n        notificationService.send('notificationRead', {gistId: $routeParams.id});\r\n        $window.history.back(-1);\r\n    };\r\n\r\n};",
    "'use strict';\r\n\r\nfunction singleGistCtrl($scope, $routeParams, gistData, ghAPI, $rootScope, notificationService) {\r\n\r\n    $scope.gist = gistData.getGistById($routeParams.gistId);\r\n\r\n    if ($scope.gist.hasOwnProperty('single') && $scope.gist.single.hasOwnProperty('lastUpdated')) {\r\n        console.log($scope.gist.single.lastUpdated);\r\n        var now = new Date();\r\n        var seconds = Math.round((now.getTime() - $scope.gist.single.lastUpdated.getTime()) / 1000);\r\n        console.log(seconds + ' have passed since last updated');\r\n        if (seconds > 60) {\r\n            ghAPI.gist($routeParams.gistId);\r\n        }\r\n    } else {\r\n        ghAPI.gist($routeParams.gistId);\r\n    }\r\n\r\n    $scope.share = function() {\r\n        if ($scope.userToShare) {\r\n            notificationService.send('sendNotification', { recipient: $scope.userToShare, gistId: $scope.gist.id, name: $scope.gist.description, gravatar_id: $scope.gist.user.gravatar_id});\r\n            console.log('sent notification!');\r\n        } else {\r\n            $('.warn').slideDown('slow');\r\n            $('.warn span').text('User is empty');\r\n            setTimeout(function () {\r\n                $('.warn').slideUp();\r\n            }, 2500);\r\n        }\r\n\r\n    };\r\n\r\n    $scope.copyToClipboard = function (data, message,type) {\r\n        message = message || 'Content of a file <b>' + data.filename + '</b> copied to clipboard';\r\n        if (clipboard !== undefined) {\r\n            if(type === 'embed') {\r\n                clipboard.set('<script src=\"' + data + '\"></script>');\r\n            } else {\r\n                clipboard.set(data.content || data, 'text');\r\n            }\r\n        } else {\r\n            // Copy to clipboard really only works in App\r\n            console.warn('>>> DEBUG MODE ON | Copy to clipboard really only works in App \\n Data: ' + (data.content || data));\r\n            console.log('data:', data);\r\n        }\r\n\r\n        $('.ok').slideDown('slow');\r\n        $('.ok span').html(message);\r\n        setTimeout(function () {\r\n            $('.ok').slideUp();\r\n        }, 2500);\r\n    };\r\n\r\n    $scope.goToGist = function (user, id, file) {\r\n        console.log('url', 'https://gist.github.com/' + user + '/' + id + '/#file-' + file.replace(/[.]/gi, '-'));\r\n        gui.Shell.openExternal('https://gist.github.com/' + user + '/' + id + '/#file-' + file.replace(/[.]/gi, '-'));\r\n    };\r\n\r\n    $scope.enableEdit = function (old_obj,old_description) {\r\n        $scope.old_object = angular.copy(old_obj);\r\n        $scope.old_description = old_description;\r\n\r\n        $rootScope.edit = true;\r\n        $('.edit').slideDown('slow');\r\n    };\r\n    $scope.disableEdit = function () {\r\n        $rootScope.edit = false;\r\n        $('.edit').slideUp('slow');\r\n    };\r\n\r\n    $scope.warnDeleteGist = function () {\r\n        $('.delete').slideDown('slow');\r\n    };\r\n    $scope.cancelDeleteGist = function () {\r\n        $('.delete').slideUp('slow');\r\n    };\r\n\r\n    $scope.$on('serverFailure', function() {\r\n        console.log('server failure');\r\n        $('.notification-error').slideDown('slow');\r\n\r\n        setTimeout(function() {\r\n            $('.notification-error').slideUp('slow');\r\n        }, 3000);\r\n    });\r\n\r\n    $scope.star = function ($event) {\r\n        if ($event) {\r\n            $event.preventDefault();\r\n        }\r\n        ghAPI.star($scope.gist.single.id, function (response) {\r\n            if (response.status === 204) {\r\n                console.log(response);\r\n                $('.ok').slideDown('slow');\r\n                $('.ok span').text('Gist starred');\r\n                $('.star').removeClass('icon-star-empty').addClass('icon-star');\r\n                $scope.gist.single.starred = !$scope.gist.single.starred;\r\n                $scope.gist.has_star = true;\r\n                setTimeout(function () {\r\n                    $('.ok').slideUp();\r\n                }, 2500);\r\n            } else {\r\n                console.log(response);\r\n                $('.warn').slideDown('slow');\r\n                $('.warn span').text('Gist not starred, something went wrong');\r\n                setTimeout(function () {\r\n                    $('.warn').slideUp();\r\n                }, 2500);\r\n            }\r\n        });\r\n    };\r\n\r\n    $scope.unstar = function ($event) {\r\n        if ($event) {\r\n            $event.preventDefault();\r\n        }\r\n        ghAPI.unstar($scope.gist.single.id, function (response) {\r\n            if (response.status === 204) {\r\n                console.log(response);\r\n                $('.ok').slideDown('slow');\r\n                $('.ok span').text('Star removed');\r\n                $('.star').removeClass('icon-star').addClass('icon-star-empty');\r\n                $scope.gist.single.starred = !$scope.gist.single.starred;\r\n                $scope.gist.has_star = false;\r\n                setTimeout(function () {\r\n                    $('.ok').slideUp();\r\n                }, 2500);\r\n            } else {\r\n                console.log(response);\r\n                $('.warn').slideDown('slow');\r\n                $('.warn span').text('Something went wrong');\r\n                setTimeout(function () {\r\n                    $('.warn').slideUp();\r\n                }, 2500);\r\n            }\r\n        });\r\n    };\r\n\r\n    $scope.del = function ($event) {\r\n        if ($event) {\r\n            $event.preventDefault();\r\n        }\r\n        console.log($scope);\r\n        ghAPI.delete($scope.gist.single.id, function (response) {\r\n            if (response.status === 204) {\r\n                $('.ok').slideDown('slow');\r\n                $('.ok span').text('Gist deleted');\r\n                // Remove from list of gists.\r\n                gistData.list.splice(gistData.list.indexOf(gistData.getGistById($scope.gist.single.id)), 1);\r\n                setTimeout(function () {\r\n                    $('.ok').slideUp();\r\n                    window.location.href = 'index.html#/';\r\n                }, 1000);\r\n            } else {\r\n                console.log(response);\r\n                $('.warn').slideDown('slow');\r\n                $('.warn span').text('Gist not deleted, something went wrong');\r\n                setTimeout(function () {\r\n                    $('.warn').slideUp();\r\n                }, 2500);\r\n            }\r\n        });\r\n    };\r\n\r\n    $scope.addFile = function () {\r\n        var fileName = 'newFile' + Object.keys($scope.gist.single.files).length + '.txt';\r\n        $scope.gist.single.files[fileName] = {\r\n            content: '',\r\n            filename: fileName,\r\n            language: 'text'\r\n        };\r\n        $scope.enableEdit();\r\n    };\r\n\r\n    $scope.dragStart = function (e) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        $('.edit').slideDown('slow');\r\n        $('.main section').addClass('dragarea');\r\n        $('.edit span').text('Drag detected - now drop!');\r\n        console.log('dragging start');\r\n    };\r\n\r\n    $scope.drop = function (e) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        var data = event.dataTransfer;\r\n        for (var i = 0; i < data.files.length; i++) { // For each dropped file\r\n            var file = data.files[i];\r\n            var reader = new FileReader();\r\n\r\n            $('.edit').slideUp('slow');\r\n            $('.ok').slideDown('slow');\r\n            $('.main section').removeClass('dragarea');\r\n            $('.ok span').html('Dropped: <b>' + file.name + '</b>');\r\n            $rootScope.edit = true;\r\n            reader.onloadend = (function (filename) {\r\n                return function (event) {\r\n                    $scope.gist.single.files[filename] = {\r\n                        filename: filename,\r\n                        content: event.target.result,\r\n                        language: 'html'\r\n                    };\r\n                    $scope.$digest();\r\n                };\r\n            })(file.name);\r\n\r\n            reader.readAsText(file);\r\n\r\n        }\r\n    };\r\n\r\n    $scope.dragEnd = function (e) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        console.log('drag end');\r\n    };\r\n\r\n    $scope.deleteFile = function (file_name) {\r\n        console.log('delete file', file_name);\r\n        $('.loading span').html('Deleting file <b>' + file_name + '</b>');\r\n\r\n        var data = {\r\n            description: $scope.gist.description,\r\n            id: $scope.gist.id,\r\n            files: {}\r\n        };\r\n\r\n        for (var file in $scope.gist.single.files) {\r\n            data.files[file] = {\r\n                content: $scope.gist.single.files[file].content,\r\n                filename: $scope.gist.single.files[file].filename\r\n            };\r\n        }\r\n        // Remove single file from gist array\r\n        data.files[file_name] = null;\r\n        delete $scope.gist.single.files[file_name];\r\n\r\n        ghAPI.edit($scope.gist.single.id, data, function (response) {\r\n            if (response.status === 200) {\r\n                $('.ok').slideDown('slow');\r\n                $('.ok span').html('File ' + file_name + ' removed');\r\n                $rootScope.edit = false;\r\n                //$scope.gist.single.files = response.data.files;\r\n                $scope.gist.single.history = response.data.history;\r\n                $scope.gist.filesCount = Object.keys($scope.gist.single.files).length;\r\n\r\n                console.warn(response.data.id);\r\n\r\n                setTimeout(function () {\r\n                    $('.ok').slideUp();\r\n                }, 2500);\r\n            } else {\r\n                $('.warn').slideDown('slow');\r\n                $('.warn span').text('Something went wrong');\r\n                setTimeout(function () {\r\n                    $('.warn').slideUp();\r\n                }, 2500);\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n    $scope.update = function () {\r\n        $('.loading span').text('Saving...');\r\n        $('.edit').slideUp();\r\n\r\n        var data = {\r\n            description: $scope.gist.description,\r\n            id: $scope.gist.id,\r\n            files: {}\r\n        };\r\n\r\n        for (var file in $scope.gist.single.files) {\r\n            data.files[file] = {\r\n                content: $scope.gist.single.files[file].content,\r\n                filename: $scope.gist.single.files[file].filename\r\n            };\r\n        }\r\n\r\n        if( angular.equals($scope.old_object, $scope.gist.single.files) && angular.equals($scope.old_description, $scope.gist.description) ) {\r\n            $('.warn').slideDown('slow');\r\n            $('.warn span').text('No changes to save.');\r\n            $rootScope.edit = false;\r\n            setTimeout(function () {\r\n                $('.warn').slideUp();\r\n            }, 2500);\r\n        } else {\r\n            ghAPI.edit($scope.gist.single.id, data, function (response) {\r\n                if (response.status === 200) {\r\n                    $('.ok').slideDown('slow');\r\n                    $('.ok span').text('Gist saved');\r\n                    $rootScope.edit = false;\r\n                    $scope.gist.single.files = response.data.files;\r\n                    $scope.gist.single.history = response.data.history;\r\n                    $scope.gist.tags = $scope.gist.description ? $scope.gist.description.match(/(#[A-Za-z0-9\\-\\_]+)/g) : [];\r\n                    $scope.gist.filesCount = Object.keys($scope.gist.single.files).length;\r\n\r\n                    setTimeout(function () {\r\n                        $('.ok').slideUp();\r\n                    }, 2500);\r\n                } else if (response.status === 422) { // ststus code of: 422 (Unprocessable Entity)\r\n                    $('.warn').slideDown('slow');\r\n                    $('.warn span').text('You cannot save empty files');\r\n                    setTimeout(function () {\r\n                        $('.warn').slideUp();\r\n                    }, 2500);\r\n                } else {\r\n                    $('.warn').slideDown('slow');\r\n                    $('.warn span').text('Something went wrong');\r\n                    setTimeout(function () {\r\n                        $('.warn').slideUp();\r\n                    }, 2500);\r\n                }\r\n            });\r\n        }\r\n    };\r\n}",
    "'use strict';\r\n\r\nangular.module('gisto.directive.editor', []).directive('editor', function ($timeout) {\r\n    var editorWindow = angular.element('<pre id=\"editor-{{$index}}\">{{file.content}}</pre>');\r\n    return {\r\n        restrict: 'E',\r\n        compile: function (elem) {\r\n            elem.append(editorWindow);\r\n\r\n            return function (scope, element, attrs) {\r\n\r\n                $timeout(function () {\r\n\r\n                    var lang = attrs.language,\r\n                        font = +attrs.font,\r\n                        editor = ace.edit('editor-' + attrs.index),\r\n                        theme = attrs.theme;\r\n\r\n\r\n                    editor.setTheme(\"ace/theme/\" + theme);\r\n                    editor.getSession().setMode(\"ace/mode/\" + lang);\r\n                    editor.setFontSize(font);\r\n                    editor.setShowPrintMargin(false);\r\n                    editor.setAutoScrollEditorIntoView(true);\r\n\r\n                    function fitSize() {\r\n                    var newHeight =\r\n                        editor.getSession().getScreenLength()\r\n                            * editor.renderer.lineHeight\r\n                            + editor.renderer.scrollBar.getWidth();\r\n\r\n                    $('pre#editor-' + attrs.index).height(newHeight.toString() + \"px\");\r\n                    editor.resize(true);\r\n                    }\r\n\r\n                    fitSize();\r\n\r\n                    console.log('language:', lang);\r\n                    console.log('Theme:', theme);\r\n                    console.log('Font size:', font);\r\n\r\n                    editor.on('change', function (data) {\r\n                        fitSize();\r\n                        scope.$apply(function () {\r\n                            scope.file.content = editor.getValue();\r\n                            if (!scope.edit) {\r\n                                scope.enableEdit();\r\n                            }\r\n                        });\r\n                    });\r\n\r\n                }, 0);\r\n            };\r\n        }\r\n\r\n    };\r\n});",
    "'use strict';\r\n\r\nangular.module('gisto.directive.scrollTo', []).directive(\"scrollTo\", [\"$window\", function ($window) {\r\n    // http://ngmodules.org/modules/ngScrollTo\r\n    // This directive is currently for files dropdown only\r\n    // TODO: rewrite to be as single directive.\r\n    return {\r\n        restrict: \"AC\",\r\n        compile: function () {\r\n\r\n            var document = $window.document;\r\n\r\n            function scrollInto(idOrName) {\r\n                if (!idOrName)\r\n                    $window.scrollTo(0, 0);\r\n                var el = document.getElementById(idOrName);\r\n                if (!el) {\r\n                    el = document.getElementsByName(idOrName);\r\n\r\n                    if (el && el.length)\r\n                        el = el[0];\r\n                    else\r\n                        el = null;\r\n                }\r\n\r\n                if (el) {\r\n                    el.scrollIntoView();\r\n                }\r\n            }\r\n\r\n            return function (scope, element, attr) {\r\n                element.bind(\"click\", function (event) {\r\n                    scrollInto(attr.scrollTo);\r\n                });\r\n            };\r\n        }\r\n    };\r\n}]);",
    "'use strict';\r\n\r\nangular.module('gisto.filter.markDown', []).filter('markDown', function () {\r\n        return function (input) {\r\n            var converter = new Showdown.converter();\r\n            var html = converter.makeHtml(input);\r\n            return html;\r\n        };\r\n    })",
    "'use strict';\r\n\r\nangular.module('gisto.filter.publicOrPrivet', []).filter('publicOrPrivet', function () {\r\n        return function (input) {\r\n            return input ? 'unlock' : 'lock';\r\n        };\r\n    });",
    "'use strict';\r\n\r\nangular.module('gisto.filter.removeTagSymbol', []).filter('removeTagSymbol', function () {\r\n        return function (input) {\r\n            return input.substring(1, input.length);\r\n        };\r\n    });",
    "'use strict';\r\n\r\nangular.module('gisto.filter.removeTags', []).filter('removeTags', function () {\r\n        return function (input) {\r\n            return input ? input.replace(/(#[A-Za-z0-9\\-\\_]+)/g, '') : input;\r\n        };\r\n    });",
    "'use strict';\r\n\r\nangular.module('gisto.filter.codeLanguage', []).filter('codeLanguage', function () {\r\n\r\n        var languages = {\r\n            null: \"text\",\r\n            \"ABAP\": \"abap\",\r\n            \"ActionScript\": \"actionscript\",\r\n            \"Ada\": \"ada\",\r\n            \"ASP\": \"vbscript\",\r\n            \"ApacheConf\": \"text\",\r\n            \"Assembly\": \"assembly_x86\",\r\n            \"AutoHotkey\": \"autohotkey\",\r\n            \"Batchfile\": \"batchfile\",\r\n            \"C\": \"c_cpp\",\r\n            \"C#\": \"csharp\",\r\n            \"C++\": \"c_cpp\",\r\n            \"Clojure\": \"clojure\",\r\n            \"CoffeeScript\": \"coffee\",\r\n            \"ColdFusion\": \"coldfusion\",\r\n            \"Common Lisp\": \"lisp\",\r\n            \"CSS\": \"css\",\r\n            \"D\": \"d \",\r\n            \"Dart\": \"dart\",\r\n            \"Diff\": \"diff\",\r\n            \"DOT\": \"dot\",\r\n            \"Erlang\": \"erlang\",\r\n            \"Forth\": \"forth\",\r\n            \"Go\": \"golang\",\r\n            \"Groovy\": \"groovy\",\r\n            \"Haml\": \"haml\",\r\n            \"Haskell\": \"haskell\",\r\n            \"Haxe\": \"haxe\",\r\n            \"HTML\": \"html\",\r\n            \"HTML+Django\": \"html\",\r\n            \"HTML+ERB\": \"html\",\r\n            \"HTML+PHP\": \"html\",\r\n            \"INI\": \"ini\",\r\n            \"Java\": \"java\",\r\n            \"Java Server Pages\": \"jsp\",\r\n            \"JavaScript\": \"javascript\",\r\n            \"JSON\": \"json\",\r\n            \"Julia\": \"julia\",\r\n            \"Less\": \"less\",\r\n            \"LiveScript\": \"livescript\",\r\n            \"Lua\": \"lua\",\r\n            \"Makefile\": \"makefile\",\r\n            \"Markdown\": \"markdown\",\r\n            \"Matlab\": \"matlab \",\r\n            \"Nginx\": \"json \",\r\n            \"Objective-C\": \"objectivec\",\r\n            \"OCaml\": \"ocaml\",\r\n            \"Perl\": \"perl\",\r\n            \"PHP\": \"php\",\r\n            \"PowerShell\": \"powershell\",\r\n            \"Prolog\": \"prolog\",\r\n            \"Python\": \"python\",\r\n            \"R\": \"r\",\r\n            \"RHTML\": \"rhtml\",\r\n            \"Ruby\": \"ruby\",\r\n            \"Rust\": \"rust\",\r\n            \"Sass\": \"sass\",\r\n            \"Scala\": \"scala\",\r\n            \"Scheme\": \"scheme\",\r\n            \"SCSS\": \"scss\",\r\n            \"Shell\": \"sh\",\r\n            \"SQL\": \"sql\",\r\n            \"Tcl\": \"tcl\",\r\n            \"TeX\": \"tex\",\r\n            \"Text\": \"text\",\r\n            \"Textile\": \"textile\",\r\n            \"TOML\": \"toml\",\r\n            \"Twig\": \"twig\",\r\n            \"TypeScript\": \"typescript\",\r\n            \"XML\": \"xml\",\r\n            \"XQuery\": \"xquery\",\r\n            \"YAML\": \"yaml\"\r\n        };\r\n\r\n        return function (input) {\r\n            return languages.hasOwnProperty(input) ? languages[input] : 'text';\r\n        };\r\n    });",
    "'use strict';\r\n\r\nangular.module('gisto.filter.truncate', []).filter('truncate', function () {\r\n        return function (text, length, end) {\r\n\r\n            if (!text) {\r\n                return '';\r\n            }\r\n            if (isNaN(length)) {\r\n                length = 10;\r\n            }\r\n            if (end === undefined) {\r\n                end = \"...\";\r\n            }\r\n            if (text.length <= length || text.length - end.length <= length) {\r\n                return text;\r\n            }\r\n            else {\r\n                return String(text).substring(0, length - end.length) + end;\r\n            }\r\n\r\n        };\r\n    });",
    "'use strict';\r\n\r\nangular.module('gisto.service.gistData', [], function ($provide) {\r\n    $provide.factory('gistData', function () {\r\n        var dataService = {\r\n            list: [],\r\n            getGistById: function (id) {\r\n                for (var gist in dataService.list) {\r\n                    gist = dataService.list[gist];\r\n                    if (gist.id === id) {\r\n                        return gist;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return dataService;\r\n    });\r\n});",
    "'use strict';\r\n\r\nangular.module('gisto.service.gitHubAPI', [\r\n    'gisto.service.gistData',\r\n    'gisto.service.appSettings',\r\n    'gisto.service.requestHandler'\r\n], function ($provide) {\r\n    $provide.factory('ghAPI', function ($http, gistData, appSettings, requestHandler, $q) {\r\n        var api_url = 'https://api.github.com/gists',\r\n            token = appSettings.get('token');\r\n        var api = {\r\n\r\n            setToken: function (newToken) {\r\n                token = newToken;\r\n            },\r\n\r\n            getLoggedInUser: function () {\r\n\r\n                var deferred = $q.defer();\r\n\r\n                var user = appSettings.get('username');\r\n\r\n                if (user) {\r\n                    console.log('from saved data');\r\n                    deferred.resolve({login: user});\r\n                    return deferred;\r\n                }\r\n\r\n                requestHandler({\r\n                    method: 'GET',\r\n                    url: 'https://api.github.com/user',\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data) {\r\n                        appSettings.set({\r\n                           username: data.login,\r\n                           gravatar_id: data.gravatar_id\r\n                        });\r\n                        deferred.resolve(data);\r\n                    }).error(function (error) {\r\n                        console.log('Could not get logged in user', error);\r\n                        deferred.reject(error);\r\n                    });\r\n\r\n                return deferred.promise;\r\n            },\r\n\r\n            // POST /authorizations\r\n            login: function (user, pass, callback) {\r\n                requestHandler({\r\n                    method: 'POST',\r\n                    url: 'https://api.github.com/authorizations',\r\n                    data: {\"scopes\": [\r\n                        \"gist\"\r\n                    ],\r\n                        \"note\": \"Gisto\"\r\n                    },\r\n                    headers: {\r\n                        \"Authorization\": \"Basic \" + btoa(user + \":\" + pass),\r\n                        \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // GET /gists\r\n            gists: function (updateOnly, pageNumber) {\r\n                var url = pageNumber ? api_url + '?page=' + pageNumber : api_url,\r\n                    headers = {\r\n                        Authorization: 'token ' + JSON.parse(localStorage.settings).token\r\n                    };\r\n\r\n                if (updateOnly) {\r\n                    headers['If-Modified-Since'] = localStorage.gistsLastUpdated;\r\n                }\r\n\r\n                requestHandler({\r\n                    method: 'GET',\r\n                    url: url,\r\n                    headers: headers\r\n                }).success(function (data, status, headers, config) {\r\n                        for (var item in data) { // process and arrange data\r\n                            data[item].tags = data[item].description ? data[item].description.match(/(#[A-Za-z0-9\\-\\_]+)/g) : [];\r\n                            data[item].single = {};\r\n                            data[item].filesCount = Object.keys(data[item].files).length;\r\n                        }\r\n\r\n                        // Set lastUpdated for 60 sec cache\r\n                        data.lastUpdated = new Date();\r\n\r\n                        // Set avatar\r\n                        appSettings.setOne('avatar', data[item].user.gravatar_id);\r\n                        gistData.list.push.apply(gistData.list, data); // transfer the data to the data service\r\n                        // localStorage.gistsLastUpdated = data.headers['last-modified'];\r\n\r\n                        var header = headers();\r\n                        if (header.link) {\r\n                            var links = header.link.split(',');\r\n                            for (var link in links) {\r\n                                link = links[link];\r\n                                if (link.indexOf('rel=\"next') > -1) {\r\n                                    var nextPage = link.match(/[0-9]+/)[0];\r\n\r\n                                    if (!pageNumber || nextPage > pageNumber) {\r\n                                        api.gists(null, nextPage);\r\n                                        return; // end the function before it reaches starred gist list call\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // end of the paging calls\r\n                        api.starred(function (response) {\r\n                            for (var s in response.data) {\r\n                                var gist = gistData.getGistById(response.data[s].id);\r\n                                if (gist) {\r\n                                    gist.has_star = true;\r\n                                }\r\n                            }\r\n                        });\r\n\r\n                    }).error(function (data, status, headers, config) {\r\n                        console.log({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // GET /gists/:id\r\n            gist: function (id) {\r\n\r\n                var deferred = $q.defer();\r\n\r\n                var gist = gistData.getGistById(id) || {}; // get the currently viewed gist or an empty object to apply the data\r\n\r\n                requestHandler({\r\n                    method: 'GET',\r\n                    url: api_url + '/' + id,\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        api.is_starred(data.id, function (response) {\r\n                            if (response.status === 204) {\r\n                                data.starred = true;\r\n                            } else {\r\n                                data.starred = false;\r\n                            }\r\n                            console.log('Is it starred: ' + data.starred);\r\n                        });\r\n\r\n                        // save timestamp of pull\r\n                        data.lastUpdated = new Date();\r\n                        console.log(data.lastUpdated);\r\n\r\n                        gist.single = data; // update the current gist with the new data\r\n\r\n                        deferred.resolve(gist);\r\n\r\n                    }).error(function (data, status, headers, config) {\r\n                        console.log({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n\r\n                        deferred.reject(status);\r\n                    });\r\n\r\n                return deferred.promise;\r\n            },\r\n\r\n            // POST /gists\r\n            create: function (data, callback) {\r\n                requestHandler({\r\n                    method: 'POST',\r\n                    url: api_url,\r\n                    data: data,\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // PATCH /gists/:id\r\n            edit: function (id, data, callback) {\r\n                requestHandler({\r\n                    method: 'PATCH',\r\n                    url: api_url + '/' + id,\r\n                    data: data,\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // DELETE /gists/:id\r\n            delete: function (id, callback) {\r\n                requestHandler({\r\n                    method: 'DELETE',\r\n                    url: api_url + '/' + id,\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // GET /gists/:id/comments\r\n            comments: function (id, callback) {\r\n                requestHandler({\r\n                    method: 'GET',\r\n                    url: api_url + '/' + id + '/comments',\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // GET /gists/starred\r\n            starred: function (callback, pageNumber) {\r\n                var url = pageNumber ? api_url + '/starred' + '?page=' + pageNumber : api_url + '/starred';\r\n                requestHandler({\r\n                    method: 'GET',\r\n                    url: url,\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n\r\n                        // return the data\r\n                        callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n\r\n                        var header = headers();\r\n                        if (header.link) {\r\n                            var links = header.link.split(',');\r\n                            for (var link in links) {\r\n                                link = links[link];\r\n                                if (link.indexOf('rel=\"next') > -1) {\r\n                                    var nextPage = link.match(/[0-9]+/)[0];\r\n\r\n                                    if (!pageNumber || nextPage > pageNumber) {\r\n                                        api.starred(callback, nextPage);\r\n                                        return; // end the function before it reaches starred gist list call\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // PUT /gists/:id/star\r\n            star: function (id, callback) {\r\n                requestHandler({\r\n                    method: 'PUT',\r\n                    url: api_url + '/' + id + '/star',\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // DELETE /gists/:id/star\r\n            unstar: function (id, callback) {\r\n                requestHandler({\r\n                    method: 'DELETE',\r\n                    url: api_url + '/' + id + '/star',\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // GET /gists/:id/star\r\n            is_starred: function (id, callback) {\r\n                requestHandler({\r\n                    method: 'get',\r\n                    url: api_url + '/' + id + '/star',\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    }).error(function (data, status, headers, config) {\r\n                        return callback({\r\n                            data: data,\r\n                            status: status,\r\n                            headers: headers(),\r\n                            config: config\r\n                        });\r\n                    });\r\n            },\r\n\r\n            // POST /gists/:id/forks\r\n            fork: function (id) {\r\n\r\n                var deferred = $q.defer();\r\n\r\n                requestHandler({\r\n                    method: 'post',\r\n                    url: api_url + '/' + id + '/forks',\r\n                    headers: {\r\n                        Authorization: 'token ' + token\r\n                    }\r\n                }).success(function (data, status, headers, config) {\r\n                        gistData.list.push(data);\r\n                        deferred.resolve(data);\r\n                }).error(function (data, status, headers, config) {\r\n                        deferred.reject(data);\r\n                });\r\n\r\n                return deferred.promise;\r\n\r\n            }\r\n        };\r\n\r\n        return api;\r\n    });\r\n});",
    "'use strict';\r\n\r\nangular.module('gisto.service.notificationService', [], function ($provide) {\r\n    $provide.factory('notificationService', function (ghAPI, socket, $rootScope, $http, $q) {\r\n        var service = {\r\n            notifications: [],\r\n            isOnline: false,\r\n            token: '',\r\n\r\n            register: function () {\r\n             // register for notifications on the server.\r\n\r\n                $q.all([\r\n                    $http.get('./config.json'),\r\n                    ghAPI.getLoggedInUser()\r\n                ]).then(function(data) {\r\n                        service.token = data[0].data.server_token;\r\n                        socket.emit('registerClient', { user: data[1].login, token: service.token });\r\n                        $rootScope.$broadcast('ApplicationState', { online: true });\r\n                });\r\n            },\r\n            logout: function() {\r\n                console.log('log out');\r\n                window.ioSocket.socket.disconnect();\r\n            },\r\n            login: function() {\r\n                if (!window.ioSocket.socket.connected) {\r\n                    window.ioSocket.socket.connect();\r\n                }\r\n            },\r\n            send: function(e, data) {\r\n                if (!window.ioSocket.socket.connected) {\r\n                    // notify\r\n                    $rootScope.$broadcast('serverFailure');\r\n                    return;\r\n                }\r\n\r\n                socket.emit(e,data);\r\n            },\r\n            forward: socket.forward,\r\n            add: function (notification) {\r\n\r\n                // check for duplicate notifications\r\n                var filter = this.notifications.filter(function(item) {\r\n                   return  item.gistId === notification.gistId;\r\n                });\r\n                console.log(filter);\r\n                if (filter.length > 0) {\r\n                    return; // duplicate notification found do not add to list\r\n                };\r\n\r\n                this.notifications.push(notification);\r\n            },\r\n            remove: function (id) {\r\n\r\n                if (!window.ioSocket.socket.connected) {\r\n                    // notify\r\n                    $rootScope.$broadcast('serverFailure');\r\n                    return;\r\n                }\r\n\r\n                var gist = this.notifications.filter(function (item) {\r\n                    console.log('filter', item, id);\r\n                    return item.gistId === id;\r\n                });\r\n\r\n                console.log('remove', gist);\r\n\r\n                if (gist && gist.length > 0) {\r\n                    for (var i = 0, limit = gist.length; i < limit; i++) {\r\n                        this.notifications.splice(this.notifications.indexOf(gist[i]), 1);\r\n                    }\r\n                }\r\n            },\r\n            disconnected: function() {\r\n                $rootScope.$broadcast('ApplicationState', { online: false });\r\n            }\r\n\r\n        };\r\n\r\n        return service;\r\n    });\r\n});",
    "'use strict';\r\n\r\nvar onlineStatusApp = angular.module('gisto.service.onlineStatusService', []);\r\n\r\nonlineStatusApp.factory('onlineStatus', [\"$window\", \"$rootScope\", function ($window, $rootScope) {\r\n    var onlineStatus = {};\r\n    onlineStatus.onLine = $window.navigator.onLine;\r\n    onlineStatus.isOnline = function() {\r\n        return onlineStatus.onLine;\r\n    };\r\n\r\n    $window.addEventListener(\"online\", function () {\r\n        $rootScope.$apply(function() {\r\n            onlineStatus.onLine = true;\r\n        });\r\n\r\n    }, true);\r\n\r\n    $window.addEventListener(\"offline\", function () {\r\n        $rootScope.$apply(function() {\r\n            onlineStatus.onLine = false;\r\n        });\r\n    }, true);\r\n\r\n    return onlineStatus;\r\n}]);",
    "'use strict';\r\n\r\n\r\nangular.module('gisto.service.requestHandler', [], function ($provide) {\r\n    $provide.factory('requestHandler', function ($http) {\r\n\r\n        function handleRequest(args) {\r\n\r\n            if (!args.stopNotification) { // stop the notification if requested\r\n                $('.loading').show();\r\n            }\r\n\r\n            var http = $http(args);\r\n\r\n            var requestService = {\r\n                success: function (callback) {\r\n                    http.success(function (data, status, headers, config) {\r\n                        // only hide the notification if there are no pending requests\r\n                        if ($http.pendingRequests.length < 1) {\r\n                            $('.loading').slideUp();\r\n                        }\r\n                        callback(data, status, headers, config); // call the user callback\r\n                    });\r\n                    return requestService; // return the object for chaining\r\n                },\r\n                error: function (callback) {\r\n                    http.error(function (data, status, headers, config) {\r\n                        // only hide the notification if there are no pending requests\r\n                        if ($http.pendingRequests.length < 1) {\r\n                            $('.loading').slideUp();\r\n                        }\r\n                        callback(data, status, headers, config); // call the user callback\r\n                    });\r\n                    return requestService; // return the object for chaining\r\n                }\r\n            };\r\n\r\n            return requestService;\r\n        }\r\n\r\n        // create the main function mimicking $http\r\n        var requestHandler = function (args) {\r\n            return handleRequest(args);\r\n        };\r\n\r\n        // add $http sub methods support\r\n\r\n        requestHandler.delete = function (url, config) {\r\n            config = config || {};\r\n            config.method = 'delete';\r\n            config.url = url;\r\n            return handleRequest(config);\r\n        };\r\n\r\n        requestHandler.get = function (url, config) {\r\n            config = config || {};\r\n            config.method = 'get';\r\n            config.url = url;\r\n            return handleRequest(config);\r\n        };\r\n\r\n        requestHandler.jsonp = function (url, config) {\r\n            config = config || {};\r\n            config.method = 'jsonp';\r\n            config.url = url;\r\n            return handleRequest(config);\r\n        };\r\n\r\n        requestHandler.post = function (url, data, config) {\r\n            config = config || {};\r\n            config.method = 'post';\r\n            config.url = url;\r\n            config.data = data;\r\n            return handleRequest(config);\r\n        };\r\n\r\n        requestHandler.put = function (url, data, config) {\r\n            config = config || {};\r\n            config.method = 'put';\r\n            config.url = url;\r\n            config.data = data;\r\n            return handleRequest(config);\r\n        };\r\n\r\n        return requestHandler;\r\n\r\n    });\r\n});",
    "'use strict';\r\n\r\nangular.module('gisto.service.appSettings', [], function ($provide) {\r\n    $provide.factory('appSettings', function () {\r\n        var settings = {\r\n\r\n            theme_list: ['default', 'gisto', 'nite', 'dark', 'dark-blue'],\r\n            font_size: ['10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'],\r\n            editor_theme_list: [\r\n                \"ambiance\",\r\n                \"chaos\",\r\n                \"chrome\",\r\n                \"clouds\",\r\n                \"clouds_midnight\",\r\n                \"cobalt\",\r\n                \"crimson_editor\",\r\n                \"dawn\",\r\n                \"dreamweaver\",\r\n                \"eclipse\",\r\n                \"github\",\r\n                \"idle_fingers\",\r\n                \"kr_theme\",\r\n                \"merbivore\",\r\n                \"merbivore_soft\",\r\n                \"monokai\",\r\n                \"mono_industrial\",\r\n                \"pastel_on_dark\",\r\n                \"solarized_dark\",\r\n                \"solarized_light\",\r\n                \"terminal\",\r\n                \"textmate\",\r\n                \"tomorrow\",\r\n                \"tomorrow_night\",\r\n                \"tomorrow_night_blue\",\r\n                \"tomorrow_night_bright\",\r\n                \"tomorrow_night_eighties\",\r\n                \"twilight\",\r\n                \"vibrant_ink\",\r\n                \"xcode\"\r\n            ],\r\n\r\n            isLoggedIn: function (callback) {\r\n\r\n                if (localStorage.settings && JSON.parse(localStorage.settings).token !== undefined) {\r\n                    return true;\r\n                } else {\r\n                    document.location.href = '#/login';\r\n                }\r\n            },\r\n\r\n            logOut: function () {\r\n                delete localStorage.settings;\r\n                document.location.href = '#/login';\r\n            },\r\n\r\n            getAll: function () {\r\n                var all_settings = JSON.parse(localStorage.settings);\r\n                return all_settings;\r\n            },\r\n\r\n            get: function (name) {\r\n                if (settings.isLoggedIn()) {\r\n                    var storage = JSON.parse(localStorage.settings);\r\n                    return storage[name];\r\n                }\r\n            },\r\n\r\n            set: function (data, callback) {\r\n\r\n                var settings = JSON.parse(localStorage.settings) || {};\r\n\r\n                for (var key in data) {\r\n                    settings[key] = data[key];\r\n                }\r\n                settings.last_modified = new Date().toUTCString();\r\n                localStorage.settings = JSON.stringify(settings);\r\n\r\n                if (callback) {\r\n                    return callback({\r\n                        status: 'ok'\r\n                    });\r\n                }\r\n\r\n            },\r\n\r\n            setOne: function (key, new_data, callback) {\r\n                var old_data = settings.getAll();\r\n                old_data[key] = new_data;\r\n                settings.set(old_data);\r\n            }\r\n        };\r\n\r\n        return settings;\r\n    });\r\n});",
    "'use strict';\r\n\r\n// Declare app level module which depends on filters, and services\r\nangular.module('gisto', [\r\n        'ui.utils',\r\n        'gisto.filter.removeTags',\r\n        'gisto.filter.truncate',\r\n        'gisto.filter.publicOrPrivet',\r\n        'gisto.filter.removeTags',\r\n        'gisto.filter.markDown',\r\n        'gisto.filter.codeLanguage',\r\n        'gisto.filter.removeTagSymbol',\r\n        'gisto.directive.scrollTo',\r\n        'gisto.directive.editor',\r\n        'gisto.service.gistData',\r\n        'gisto.service.requestHandler',\r\n        'gisto.service.gitHubAPI',\r\n        'gisto.service.appSettings',\r\n        'btford.socket-io',\r\n        'gisto.service.notificationService',\r\n        'gisto.service.onlineStatusService'\r\n    ]).\r\n    config(['$routeProvider', 'socketProvider', function ($routeProvider, socketProvider) {\r\n\r\n        // connect to notification server\r\n        var socket = io.connect('http://localhost:3000'); // development\r\n        //var socket = io.connect('http://server.gistoapp.com:3000'); // production\r\n        socketProvider.ioSocket(socket);\r\n        window.ioSocket = socket;\r\n\r\n        $routeProvider.when('/', {\r\n            templateUrl: 'partials/empty.html',\r\n            controller: mainCtrl\r\n        });\r\n        $routeProvider.when('/login', {\r\n            templateUrl: 'partials/login.html',\r\n            controller: loginCtrl\r\n        });\r\n        $routeProvider.when('/settings', {\r\n            templateUrl: 'partials/settings.html'\r\n        });\r\n        $routeProvider.when('/gist/:gistId', {\r\n            templateUrl: 'partials/single-gist.html',\r\n            controller: singleGistCtrl\r\n        });\r\n        $routeProvider.when('/create', {\r\n            templateUrl: 'partials/create.html',\r\n            controller: createGistCtrl\r\n        });\r\n        $routeProvider.when('/shared/:user/:id', {\r\n            templateUrl: 'partials/shared.html',\r\n            controller: sharedCtrl\r\n        });\r\n        $routeProvider.otherwise({\r\n            redirectTo: '/'\r\n        });\r\n    }]);\r\n",
    "//\r\n// showdown.js -- A javascript port of Markdown.\r\n//\r\n// Copyright (c) 2007 John Fraser.\r\n//\r\n// Original Markdown Copyright (c) 2004-2005 John Gruber\r\n//   <http://daringfireball.net/projects/markdown/>\r\n//\r\n// Redistributable under a BSD-style open source license.\r\n// See license.txt for more information.\r\n//\r\n// The full source distribution is at:\r\n//\r\n//\t\t\t\tA A L\r\n//\t\t\t\tT C A\r\n//\t\t\t\tT K B\r\n//\r\n//   <http://www.attacklab.net/>\r\n//\r\n//\r\n// Wherever possible, Showdown is a straight, line-by-line port\r\n// of the Perl version of Markdown.\r\n//\r\n// This is not a normal parser design; it's basically just a\r\n// series of string substitutions.  It's hard to read and\r\n// maintain this way,  but keeping Showdown close to the original\r\n// design makes it easier to port new features.\r\n//\r\n// More importantly, Showdown behaves like markdown.pl in most\r\n// edge cases.  So web applications can do client-side preview\r\n// in Javascript, and then build identical HTML on the server.\r\n//\r\n// This port needs the new RegExp functionality of ECMA 262,\r\n// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers\r\n// should do fine.  Even with the new regular expression features,\r\n// We do a lot of work to emulate Perl's regex functionality.\r\n// The tricky changes in this file mostly have the \"attacklab:\"\r\n// label.  Major or self-explanatory changes don't.\r\n//\r\n// Smart diff tools like Araxis Merge will be able to match up\r\n// this file with markdown.pl in a useful way.  A little tweaking\r\n// helps: in a copy of markdown.pl, replace \"#\" with \"//\" and\r\n// replace \"$text\" with \"text\".  Be sure to ignore whitespace\r\n// and line endings.\r\n//\r\n//\r\n// Showdown usage:\r\n//\r\n//   var text = \"Markdown *rocks*.\";\r\n//\r\n//   var converter = new Showdown.converter();\r\n//   var html = converter.makeHtml(text);\r\n//\r\n//   alert(html);\r\n//\r\n// Note: move the sample code to the bottom of this\r\n// file before uncommenting it.\r\n//\r\n//\r\n// Showdown namespace\r\n//\r\nvar Showdown = {extensions: {}}, forEach = Showdown.forEach = function (a, b) {\r\n    if (typeof a.forEach == \"function\")a.forEach(b); else {\r\n        var c, d = a.length;\r\n        for (c = 0; c < d; c++)b(a[c], c, a)\r\n    }\r\n}, stdExtName = function (a) {\r\n    return a.replace(/[_-]||\\s/g, \"\").toLowerCase()\r\n};\r\nShowdown.converter = function (a) {\r\n    var b, c, d, e = 0, f = [], g = [];\r\n    if (typeof module != \"undefind\" && typeof exports != \"undefined\" && typeof require != \"undefind\") {\r\n        var h = require(\"fs\");\r\n        if (h) {\r\n            var i = h.readdirSync((__dirname || \".\") + \"/extensions\").filter(function (a) {\r\n                return~a.indexOf(\".js\")\r\n            }).map(function (a) {\r\n                    return a.replace(/\\.js$/, \"\")\r\n                });\r\n            Showdown.forEach(i, function (a) {\r\n                var b = stdExtName(a);\r\n                Showdown.extensions[b] = require(\"./extensions/\" + a)\r\n            })\r\n        }\r\n    }\r\n    this.makeHtml = function (a) {\r\n        return b = {}, c = {}, d = [], a = a.replace(/~/g, \"~T\"), a = a.replace(/\\$/g, \"~D\"), a = a.replace(/\\r\\n/g, \"\\n\"), a = a.replace(/\\r/g, \"\\n\"), a = \"\\n\\n\" + a + \"\\n\\n\", a = M(a), a = a.replace(/^[ \\t]+$/mg, \"\"), Showdown.forEach(f, function (b) {\r\n            a = k(b, a)\r\n        }), a = z(a), a = m(a), a = l(a), a = o(a), a = K(a), a = a.replace(/~D/g, \"$$\"), a = a.replace(/~T/g, \"~\"), Showdown.forEach(g, function (b) {\r\n            a = k(b, a)\r\n        }), a\r\n    };\r\n    if (a && a.extensions) {\r\n        var j = this;\r\n        Showdown.forEach(a.extensions, function (a) {\r\n            typeof a == \"string\" && (a = Showdown.extensions[stdExtName(a)]);\r\n            if (typeof a != \"function\")throw\"Extension '\" + a + \"' could not be loaded.  It was either not found or is not a valid extension.\";\r\n            Showdown.forEach(a(j), function (a) {\r\n                a.type ? a.type === \"language\" || a.type === \"lang\" ? f.push(a) : (a.type === \"output\" || a.type === \"html\") && g.push(a) : g.push(a)\r\n            })\r\n        })\r\n    }\r\n    var k = function (a, b) {\r\n        if (a.regex) {\r\n            var c = new RegExp(a.regex, \"g\");\r\n            return b.replace(c, a.replace)\r\n        }\r\n        if (a.filter)return a.filter(b)\r\n    }, l = function (a) {\r\n        return a += \"~0\", a = a.replace(/^[ ]{0,3}\\[(.+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"(](.+?)[\")][ \\t]*)?(?:\\n+|(?=~0))/gm, function (a, d, e, f, g) {\r\n            return d = d.toLowerCase(), b[d] = G(e), f ? f + g : (g && (c[d] = g.replace(/\"/g, \"&quot;\")), \"\")\r\n        }), a = a.replace(/~0/, \"\"), a\r\n    }, m = function (a) {\r\n        a = a.replace(/\\n/g, \"\\n\\n\");\r\n        var b = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del|style|section|header|footer|nav|article|aside\", c = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside\";\r\n        return a = a.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm, n), a = a.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside)\\b[^\\r]*?<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm, n), a = a.replace(/(\\n[ ]{0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g, n), a = a.replace(/(\\n\\n[ ]{0,3}<!(--[^\\r]*?--\\s*)+>[ \\t]*(?=\\n{2,}))/g, n), a = a.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g, n), a = a.replace(/\\n\\n/g, \"\\n\"), a\r\n    }, n = function (a, b) {\r\n        var c = b;\r\n        return c = c.replace(/\\n\\n/g, \"\\n\"), c = c.replace(/^\\n/, \"\"), c = c.replace(/\\n+$/g, \"\"), c = \"\\n\\n~K\" + (d.push(c) - 1) + \"K\\n\\n\", c\r\n    }, o = function (a) {\r\n        a = v(a);\r\n        var b = A(\"<hr />\");\r\n        return a = a.replace(/^[ ]{0,2}([ ]?\\*[ ]?){3,}[ \\t]*$/gm, b), a = a.replace(/^[ ]{0,2}([ ]?\\-[ ]?){3,}[ \\t]*$/gm, b), a = a.replace(/^[ ]{0,2}([ ]?\\_[ ]?){3,}[ \\t]*$/gm, b), a = x(a), a = y(a), a = E(a), a = m(a), a = F(a), a\r\n    }, p = function (a) {\r\n        return a = B(a), a = q(a), a = H(a), a = t(a), a = r(a), a = I(a), a = G(a), a = D(a), a = a.replace(/  +\\n/g, \" <br />\\n\"), a\r\n    }, q = function (a) {\r\n        var b = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\r\n        return a = a.replace(b, function (a) {\r\n            var b = a.replace(/(.)<\\/?code>(?=.)/g, \"$1`\");\r\n            return b = N(b, \"\\\\`*_\"), b\r\n        }), a\r\n    }, r = function (a) {\r\n        return a = a.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g, s), a = a.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]\\([ \\t]*()<?(.*?(?:\\(.*?\\).*?)?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g, s), a = a.replace(/(\\[([^\\[\\]]+)\\])()()()()()/g, s), a\r\n    }, s = function (a, d, e, f, g, h, i, j) {\r\n        j == undefined && (j = \"\");\r\n        var k = d, l = e, m = f.toLowerCase(), n = g, o = j;\r\n        if (n == \"\") {\r\n            m == \"\" && (m = l.toLowerCase().replace(/ ?\\n/g, \" \")), n = \"#\" + m;\r\n            if (b[m] != undefined)n = b[m], c[m] != undefined && (o = c[m]); else {\r\n                if (!(k.search(/\\(\\s*\\)$/m) > -1))return k;\r\n                n = \"\"\r\n            }\r\n        }\r\n        n = N(n, \"*_\");\r\n        var p = '<a href=\"' + n + '\"';\r\n        return o != \"\" && (o = o.replace(/\"/g, \"&quot;\"), o = N(o, \"*_\"), p += ' title=\"' + o + '\"'), p += \">\" + l + \"</a>\", p\r\n    }, t = function (a) {\r\n        return a = a.replace(/(!\\[(.*?)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g, u), a = a.replace(/(!\\[(.*?)\\]\\s?\\([ \\t]*()<?(\\S+?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g, u), a\r\n    }, u = function (a, d, e, f, g, h, i, j) {\r\n        var k = d, l = e, m = f.toLowerCase(), n = g, o = j;\r\n        o || (o = \"\");\r\n        if (n == \"\") {\r\n            m == \"\" && (m = l.toLowerCase().replace(/ ?\\n/g, \" \")), n = \"#\" + m;\r\n            if (b[m] == undefined)return k;\r\n            n = b[m], c[m] != undefined && (o = c[m])\r\n        }\r\n        l = l.replace(/\"/g, \"&quot;\"), n = N(n, \"*_\");\r\n        var p = '<img src=\"' + n + '\" alt=\"' + l + '\"';\r\n        return o = o.replace(/\"/g, \"&quot;\"), o = N(o, \"*_\"), p += ' title=\"' + o + '\"', p += \" />\", p\r\n    }, v = function (a) {\r\n        function b(a) {\r\n            return a.replace(/[^\\w]/g, \"\").toLowerCase()\r\n        }\r\n\r\n        return a = a.replace(/^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm, function (a, c) {\r\n            return A('<h1 id=\"' + b(c) + '\">' + p(c) + \"</h1>\")\r\n        }), a = a.replace(/^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm, function (a, c) {\r\n            return A('<h2 id=\"' + b(c) + '\">' + p(c) + \"</h2>\")\r\n        }), a = a.replace(/^(\\#{1,6})[ \\t]*(.+?)[ \\t]*\\#*\\n+/gm, function (a, c, d) {\r\n            var e = c.length;\r\n            return A(\"<h\" + e + ' id=\"' + b(d) + '\">' + p(d) + \"</h\" + e + \">\")\r\n        }), a\r\n    }, w, x = function (a) {\r\n        a += \"~0\";\r\n        var b = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\r\n        return e ? a = a.replace(b, function (a, b, c) {\r\n            var d = b, e = c.search(/[*+-]/g) > -1 ? \"ul\" : \"ol\";\r\n            d = d.replace(/\\n{2,}/g, \"\\n\\n\\n\");\r\n            var f = w(d);\r\n            return f = f.replace(/\\s+$/, \"\"), f = \"<\" + e + \">\" + f + \"</\" + e + \">\\n\", f\r\n        }) : (b = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/g, a = a.replace(b, function (a, b, c, d) {\r\n            var e = b, f = c, g = d.search(/[*+-]/g) > -1 ? \"ul\" : \"ol\", f = f.replace(/\\n{2,}/g, \"\\n\\n\\n\"), h = w(f);\r\n            return h = e + \"<\" + g + \">\\n\" + h + \"</\" + g + \">\\n\", h\r\n        })), a = a.replace(/~0/, \"\"), a\r\n    };\r\n    w = function (a) {\r\n        return e++, a = a.replace(/\\n{2,}$/, \"\\n\"), a += \"~0\", a = a.replace(/(\\n)?(^[ \\t]*)([*+-]|\\d+[.])[ \\t]+([^\\r]+?(\\n{1,2}))(?=\\n*(~0|\\2([*+-]|\\d+[.])[ \\t]+))/gm, function (a, b, c, d, e) {\r\n            var f = e, g = b, h = c;\r\n            return g || f.search(/\\n{2,}/) > -1 ? f = o(L(f)) : (f = x(L(f)), f = f.replace(/\\n$/, \"\"), f = p(f)), \"<li>\" + f + \"</li>\\n\"\r\n        }), a = a.replace(/~0/g, \"\"), e--, a\r\n    };\r\n    var y = function (a) {\r\n        return a += \"~0\", a = a.replace(/(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g, function (a, b, c) {\r\n            var d = b, e = c;\r\n            return d = C(L(d)), d = M(d), d = d.replace(/^\\n+/g, \"\"), d = d.replace(/\\n+$/g, \"\"), d = \"<pre><code>\" + d + \"\\n</code></pre>\", A(d) + e\r\n        }), a = a.replace(/~0/, \"\"), a\r\n    }, z = function (a) {\r\n        return a += \"~0\", a = a.replace(/(?:^|\\n)```(.*)\\n([\\s\\S]*?)\\n```/g, function (a, b, c) {\r\n            var d = b, e = c;\r\n            return e = C(e), e = M(e), e = e.replace(/^\\n+/g, \"\"), e = e.replace(/\\n+$/g, \"\"), e = \"<pre><code\" + (d ? ' class=\"' + d + '\"' : \"\") + \">\" + e + \"\\n</code></pre>\", A(e)\r\n        }), a = a.replace(/~0/, \"\"), a\r\n    }, A = function (a) {\r\n        return a = a.replace(/(^\\n+|\\n+$)/g, \"\"), \"\\n\\n~K\" + (d.push(a) - 1) + \"K\\n\\n\"\r\n    }, B = function (a) {\r\n        return a = a.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm, function (a, b, c, d, e) {\r\n            var f = d;\r\n            return f = f.replace(/^([ \\t]*)/g, \"\"), f = f.replace(/[ \\t]*$/g, \"\"), f = C(f), b + \"<code>\" + f + \"</code>\"\r\n        }), a\r\n    }, C = function (a) {\r\n        return a = a.replace(/&/g, \"&amp;\"), a = a.replace(/</g, \"&lt;\"), a = a.replace(/>/g, \"&gt;\"), a = N(a, \"*_{}[]\\\\\", !1), a\r\n    }, D = function (a) {\r\n        return a = a.replace(/(\\*\\*|__)(?=\\S)([^\\r]*?\\S[*_]*)\\1/g, \"<strong>$2</strong>\"), a = a.replace(/(\\*|_)(?=\\S)([^\\r]*?\\S)\\1/g, \"<em>$2</em>\"), a\r\n    }, E = function (a) {\r\n        return a = a.replace(/((^[ \\t]*>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm, function (a, b) {\r\n            var c = b;\r\n            return c = c.replace(/^[ \\t]*>[ \\t]?/gm, \"~0\"), c = c.replace(/~0/g, \"\"), c = c.replace(/^[ \\t]+$/gm, \"\"), c = o(c), c = c.replace(/(^|\\n)/g, \"$1  \"), c = c.replace(/(\\s*<pre>[^\\r]+?<\\/pre>)/gm, function (a, b) {\r\n                var c = b;\r\n                return c = c.replace(/^  /mg, \"~0\"), c = c.replace(/~0/g, \"\"), c\r\n            }), A(\"<blockquote>\\n\" + c + \"\\n</blockquote>\")\r\n        }), a\r\n    }, F = function (a) {\r\n        a = a.replace(/^\\n+/g, \"\"), a = a.replace(/\\n+$/g, \"\");\r\n        var b = a.split(/\\n{2,}/g), c = [], e = b.length;\r\n        for (var f = 0; f < e; f++) {\r\n            var g = b[f];\r\n            g.search(/~K(\\d+)K/g) >= 0 ? c.push(g) : g.search(/\\S/) >= 0 && (g = p(g), g = g.replace(/^([ \\t]*)/g, \"<p>\"), g += \"</p>\", c.push(g))\r\n        }\r\n        e = c.length;\r\n        for (var f = 0; f < e; f++)while (c[f].search(/~K(\\d+)K/) >= 0) {\r\n            var h = d[RegExp.$1];\r\n            h = h.replace(/\\$/g, \"$$$$\"), c[f] = c[f].replace(/~K\\d+K/, h)\r\n        }\r\n        return c.join(\"\\n\\n\")\r\n    }, G = function (a) {\r\n        return a = a.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g, \"&amp;\"), a = a.replace(/<(?![a-z\\/?\\$!])/gi, \"&lt;\"), a\r\n    }, H = function (a) {\r\n        return a = a.replace(/\\\\(\\\\)/g, O), a = a.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g, O), a\r\n    }, I = function (a) {\r\n        return a = a.replace(/<((https?|ftp|dict):[^'\">\\s]+)>/gi, '<a href=\"$1\">$1</a>'), a = a.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi, function (a, b) {\r\n            return J(K(b))\r\n        }), a\r\n    }, J = function (a) {\r\n        var b = [function (a) {\r\n            return\"&#\" + a.charCodeAt(0) + \";\"\r\n        }, function (a) {\r\n            return\"&#x\" + a.charCodeAt(0).toString(16) + \";\"\r\n        }, function (a) {\r\n            return a\r\n        }];\r\n        return a = \"mailto:\" + a, a = a.replace(/./g, function (a) {\r\n            if (a == \"@\")a = b[Math.floor(Math.random() * 2)](a); else if (a != \":\") {\r\n                var c = Math.random();\r\n                a = c > .9 ? b[2](a) : c > .45 ? b[1](a) : b[0](a)\r\n            }\r\n            return a\r\n        }), a = '<a href=\"' + a + '\">' + a + \"</a>\", a = a.replace(/\">.+:/g, '\">'), a\r\n    }, K = function (a) {\r\n        return a = a.replace(/~E(\\d+)E/g, function (a, b) {\r\n            var c = parseInt(b);\r\n            return String.fromCharCode(c)\r\n        }), a\r\n    }, L = function (a) {\r\n        return a = a.replace(/^(\\t|[ ]{1,4})/gm, \"~0\"), a = a.replace(/~0/g, \"\"), a\r\n    }, M = function (a) {\r\n        return a = a.replace(/\\t(?=\\t)/g, \"    \"), a = a.replace(/\\t/g, \"~A~B\"), a = a.replace(/~B(.+?)~A/g, function (a, b, c) {\r\n            var d = b, e = 4 - d.length % 4;\r\n            for (var f = 0; f < e; f++)d += \" \";\r\n            return d\r\n        }), a = a.replace(/~A/g, \"    \"), a = a.replace(/~B/g, \"\"), a\r\n    }, N = function (a, b, c) {\r\n        var d = \"([\" + b.replace(/([\\[\\]\\\\])/g, \"\\\\$1\") + \"])\";\r\n        c && (d = \"\\\\\\\\\" + d);\r\n        var e = new RegExp(d, \"g\");\r\n        return a = a.replace(e, O), a\r\n    }, O = function (a, b) {\r\n        var c = b.charCodeAt(0);\r\n        return\"~E\" + c + \"E\"\r\n    }\r\n}, typeof module != \"undefined\" && (module.exports = Showdown), typeof define == \"function\" && define.amd && define(\"showdown\", function () {\r\n    return Showdown\r\n});"
  ]
}